<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Filter DSP JS Library Test</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { 
    --bg:#0a0e13; --fg:#f0f4f8; --muted:#94a3b8; --accent:#3b82f6; --grid:#1e293b; 
    --surface:#111827; --border:#374151; --hover:#1f2937;
  }
  * { box-sizing: border-box; }
  body { 
    margin:0; background:var(--bg); color:var(--fg); 
    font:14px/1.5 -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-weight:400;
  }
  header { 
    padding:20px 24px; border-bottom:1px solid var(--border); 
    background:var(--surface); backdrop-filter:blur(10px);
    box-shadow:0 1px 3px rgba(0,0,0,0.1);
  }
  h1 { font-size:18px; margin:0; color:var(--accent); font-weight:600; }
  .row { 
    display:flex; gap:16px; flex-wrap:wrap; align-items:end; 
    max-width:1400px; margin:0 auto;
  }
  .field { 
    display:flex; flex-direction:column; gap:8px; 
    min-width:140px; position:relative;
  }
  .field label { 
    font-size:12px; color:var(--muted); font-weight:500; 
    text-transform:uppercase; letter-spacing:0.5px;
  }
  .field input, .field select { 
    background:var(--surface); border:1px solid var(--border); 
    color:var(--fg); padding:10px 12px; border-radius:8px; 
    min-width:140px; font-size:13px; transition:all 0.2s ease;
    box-shadow:0 1px 2px rgba(0,0,0,0.05);
  }
  .field input:focus, .field select:focus { 
    outline:none; border-color:var(--accent); 
    box-shadow:0 0 0 3px rgba(59,130,246,0.1);
  }
  .field input:hover, .field select:hover {
    border-color:var(--hover); background:var(--hover);
  }
  .field input[type="range"] { 
    width:160px; height:8px; background:var(--grid); 
    border-radius:4px; outline:none; -webkit-appearance:none; 
    appearance:none; border:none; padding:0;
  }
  .field input[type="range"]::-webkit-slider-thumb { 
    -webkit-appearance:none; width:20px; height:20px; 
    background:linear-gradient(135deg, var(--accent), #1d4ed8);
    border-radius:50%; cursor:pointer; box-shadow:0 2px 4px rgba(0,0,0,0.2);
    transition:transform 0.2s ease;
  }
  .field input[type="range"]::-webkit-slider-thumb:hover {
    transform:scale(1.1);
  }
  .field input[type="range"]::-moz-range-thumb {
    width:20px; height:20px; background:linear-gradient(135deg, var(--accent), #1d4ed8);
    border-radius:50%; cursor:pointer; border:none; box-shadow:0 2px 4px rgba(0,0,0,0.2);
  }
  .slider-value { 
    font-size:12px; color:var(--accent); margin-top:4px; 
    text-align:center; font-weight:600; background:rgba(59,130,246,0.1);
    padding:2px 6px; border-radius:4px; display:inline-block;
  }
  main { padding:20px; max-width:1400px; margin:0 auto; }
  .card { 
    background:var(--surface); border:1px solid var(--border); 
    border-radius:12px; padding:20px; display:flex; flex-direction:column; 
    min-height:400px; box-shadow:0 1px 3px rgba(0,0,0,0.1);
    transition:box-shadow 0.2s ease;
  }
  .card:hover { box-shadow:0 4px 6px rgba(0,0,0,0.1); }
  .card h3 { 
    margin:0 0 12px 0; font-size:14px; color:var(--muted); 
    font-weight:600; text-transform:uppercase; letter-spacing:0.5px;
  }
  canvas { width:100%; height:360px; display:block; }
  .sos { grid-column:1 / -1; }
  pre { 
    margin:0; white-space:pre-wrap; word-break:break-word; 
    background:var(--bg); border:1px solid var(--border); 
    border-radius:8px; padding:16px; color:var(--fg); 
    font-family:'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size:12px; line-height:1.5; overflow-x:auto;
  }
  footer { padding:8px 14px; color:var(--muted); border-top:1px solid var(--grid); font-size:12px; }
  a { color:var(--accent); text-decoration:none; }
  .status { padding:8px 12px; background:#1a2330; border:1px solid var(--grid); border-radius:8px; margin:8px 0; font-size:12px; }
  .status.success { border-color:#4ade80; color:#4ade80; }
  .status.error { border-color:#f87171; color:#f87171; }
  
  /* Tab styles */
  .tabs { margin:20px 0; }
  .tab-buttons { 
    display:flex; gap:2px; margin-bottom:0; 
    background:var(--surface); padding:4px; border-radius:8px;
    border:1px solid var(--border);
  }
  .tab-button { 
    background:transparent; border:none; color:var(--muted); 
    padding:10px 20px; border-radius:6px; cursor:pointer; 
    font-size:13px; font-weight:500; transition:all 0.2s ease;
    flex:1; text-align:center;
  }
  .tab-button.active { 
    background:var(--accent); color:white; 
    box-shadow:0 2px 4px rgba(59,130,246,0.3);
  }
  .tab-button:hover:not(.active) { 
    background:var(--hover); color:var(--fg); 
  }
  .tab-content { display:none; }
  .tab-content.active { display:block; }
  .tab-panel { 
    background:var(--surface); border:1px solid var(--border); 
    border-radius:8px; padding:20px; min-height:400px;
    margin-top:8px; box-shadow:0 1px 3px rgba(0,0,0,0.1);
  }
</style>
</head>
<body>
  <header>
    <div class="row">
      <div class="field">
        <label for="family">Family</label>
        <select id="family">
          <option value="butter">Butterworth</option>
          <option value="cheby1">Chebyshev I (Rp)</option>
          <option value="cheby2">Chebyshev II (Rs)</option>
          <option value="ellip">Elliptic (Rp & Rs)</option>
          <option value="linkwitz">Linkwitz–Riley</option>
          <option value="bessel">Bessel (Thomson)</option>
          <option value="fir">FIR (Windowed)</option>
        </select>
      </div>
      <div class="field">
        <label for="kind">Kind</label>
        <select id="kind">
          <option value="lowpass">Lowpass</option>
          <option value="highpass">Highpass</option>
          <option value="bandpass">Bandpass</option>
          <option value="bandstop">Bandstop</option>
        </select>
      </div>

      <div class="field only-iir">
        <label for="order">IIR Order (N)</label>
        <input id="order" type="range" min="2" max="20" step="1" value="6" />
        <div id="order-value" class="slider-value">6</div>
      </div>

      <div class="field only-fir" style="display:none">
        <label for="taps">FIR Taps (odd)</label>
        <input id="taps" type="range" min="11" max="255" step="2" value="101" />
        <div id="taps-value" class="slider-value">101</div>
      </div>

      <div class="field only-cheby1 only-ellip" style="display:none">
        <label for="rp">Passband ripple Rp (dB)</label>
        <input id="rp" type="range" min="0.1" max="3" step="0.1" value="1" />
        <div id="rp-value" class="slider-value">1.0</div>
      </div>
      <div class="field only-cheby2 only-ellip" style="display:none">
        <label for="rs">Stopband ripple Rs (dB)</label>
        <input id="rs" type="range" min="10" max="200" step="1" value="60" />
        <div id="rs-value" class="slider-value">60</div>
      </div>

      <div class="field only-fir" style="display:none">
        <label for="win">Window</label>
        <select id="win">
          <option value="rect">Rectangular</option>
          <option value="hann">Hann</option>
          <option value="hamming" selected>Hamming</option>
          <option value="blackman">Blackman</option>
          <option value="blackmanHarris">Blackman-Harris</option>
          <option value="blackmanNuttall">Blackman-Nuttall</option>
          <option value="nuttall">Nuttall</option>
          <option value="exactBlackman">Exact Blackman</option>
          <option value="bartlett">Bartlett</option>
          <option value="bartlettHann">Bartlett-Hann</option>
          <option value="welch">Welch</option>
          <option value="triangular">Triangular</option>
          <option value="gauss">Gaussian</option>
          <option value="tukey">Tukey</option>
          <option value="poisson">Poisson</option>
          <option value="parzen">Parzen</option>
          <option value="bohman">Bohman</option>
          <option value="lanczos">Lanczos</option>
          <option value="cosine">Cosine</option>
          <option value="flatTop">Flat-top</option>
          <option value="dolphChebyshev">Dolph-Chebyshev</option>
          <option value="taylor">Taylor</option>
          <option value="kaiser">Kaiser</option>
        </select>
      </div>
      <div class="field only-fir only-kaiser" style="display:none">
        <label for="beta">Kaiser β</label>
        <input id="beta" type="range" min="0" max="12" step="0.1" value="6" />
        <div id="beta-value" class="slider-value">6.0</div>
      </div>
      <div class="field only-fir only-tukey" style="display:none">
        <label for="alpha">Tukey α</label>
        <input id="alpha" type="range" min="0" max="1" step="0.05" value="0.5" />
        <div id="alpha-value" class="slider-value">0.5</div>
      </div>
      <div class="field only-fir only-gauss" style="display:none">
        <label for="sigma">Gaussian σ</label>
        <input id="sigma" type="range" min="0.1" max="1" step="0.05" value="0.4" />
        <div id="sigma-value" class="slider-value">0.4</div>
      </div>
      <div class="field only-fir only-poisson" style="display:none">
        <label for="poissonAlpha">Poisson α</label>
        <input id="poissonAlpha" type="range" min="0.5" max="5" step="0.1" value="2" />
        <div id="poissonAlpha-value" class="slider-value">2.0</div>
      </div>

      <div class="field">
        <label for="fs">Sample rate Fs (Hz)</label>
        <input id="fs" type="range" min="1000" max="192000" step="1000" value="48000" />
        <div id="fs-value" class="slider-value">48000</div>
      </div>

      <div class="field only-lp-hp">
        <label for="fc">Fc (Hz)</label>
        <input id="fc" type="range" min="1" max="24000" step="100" value="4000" />
        <div id="fc-value" class="slider-value">4000</div>
      </div>
      <div class="field only-bp-bs" style="display:none">
        <label for="f1">F1 (Hz)</label>
        <input id="f1" type="range" min="1" max="24000" step="100" value="2000" />
        <div id="f1-value" class="slider-value">2000</div>
      </div>
      <div class="field only-bp-bs" style="display:none">
        <label for="f2">F2 (Hz)</label>
        <input id="f2" type="range" min="1" max="24000" step="100" value="8000" />
        <div id="f2-value" class="slider-value">8000</div>
      </div>
    </div>
  </header>

  <main>
    <div class="tabs">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="frequency">Frequency Response</button>
        <button class="tab-button" data-tab="time">Time Domain</button>
        <button class="tab-button" data-tab="poles-zeros">Poles & Zeros</button>
        <button class="tab-button" data-tab="coefficients">Coefficients</button>
      </div>
      
      <div class="tab-content active" id="frequency">
        <div class="tab-panel">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
            <div class="card"><h3>Magnitude Response (dB)</h3><canvas id="magCanvas"></canvas></div>
            <div class="card"><h3>Phase Response (deg, unwrapped)</h3><canvas id="phaseCanvas"></canvas></div>
          </div>
        </div>
      </div>
      
      <div class="tab-content" id="time">
        <div class="tab-panel">
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:15px;">
            <div class="card"><h3>Impulse Response</h3><canvas id="impCanvas"></canvas></div>
            <div class="card"><h3>Group Delay (samples)</h3><canvas id="gdCanvas"></canvas></div>
            <div class="card"><h3>Phase Delay (samples)</h3><canvas id="pdCanvas"></canvas></div>
          </div>
        </div>
      </div>
      
      <div class="tab-content" id="poles-zeros">
        <div class="tab-panel">
          <div class="card"><h3>Z-Plane Poles & Zeros</h3><canvas id="pzCanvas"></canvas></div>
        </div>
      </div>
      
      <div class="tab-content" id="coefficients">
        <div class="tab-panel">
          <div class="card sos"><h3>Second-Order Sections / Taps</h3><pre id="sosOut">// Filter design will appear here</pre></div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    Testing filter-dsp-js library: IIR via analog prototypes + BLT; FIR via windowed-sinc.
  </footer>

  <!-- Load the UMD build of the library -->
  <script src="../lib/dsp-filter-library.min.js?v=1"></script>
  
  <script>
  (() => {
    console.log('Script starting...');
    
    // Check if library loaded successfully
    console.log('Checking DSPFilterLibrary...');
    if (typeof DSPFilterLibrary === 'undefined') {
      console.error('DSPFilterLibrary is undefined');
      return;
    }
    
    console.log('DSPFilterLibrary found:', DSPFilterLibrary);
    console.log('Available exports:', Object.keys(DSPFilterLibrary));
    
    // The FilterDSP class is available as DSPFilterLibrary.FilterDSP in UMD build
    const FilterDSPClass = DSPFilterLibrary.FilterDSP;
    
    if (typeof FilterDSPClass === 'undefined') {
      console.error('FilterDSP class not found in DSPFilterLibrary');
      return;
    }
    
    console.log('FilterDSP class found:', FilterDSPClass);

    // ---------- Tab functionality ----------
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(targetTab).classList.add('active');
          
          // Redraw diagrams when tab is switched
          // Use setTimeout to ensure the tab content is visible before drawing
          setTimeout(() => {
            try {
              // Use efficient redraw function if we have cached data
              if (currentFilter && currentResponse && currentImpResp) {
                redrawDiagrams();
              } else if (typeof design === 'function') {
                // Fallback to full design if no cached data
                design();
              }
            } catch (error) {
              console.log('Tab switch redraw skipped:', error.message);
            }
          }, 10);
        });
      });
    }
    
    initTabs();

    // ---------- UI refs ----------
    const $ = id => document.getElementById(id);
    const familyEl = $('family'), kindEl = $('kind'), orderEl = $('order'), tapsEl = $('taps'),
          rpEl = $('rp'), rsEl = $('rs'), fsEl = $('fs'), fcEl = $('fc'), f1El = $('f1'), f2El = $('f2'),
          winEl = $('win'), betaEl = $('beta'), alphaEl = $('alpha'), sigmaEl = $('sigma'), poissonAlphaEl = $('poissonAlpha');
    const orderVal = $('order-value'), tapsVal = $('taps-value'),
          rpVal = $('rp-value'), rsVal = $('rs-value'),
          fsVal = $('fs-value'), fcVal = $('fc-value'), f1Val = $('f1-value'), f2Val = $('f2-value'),
          betaVal = $('beta-value'), alphaVal = $('alpha-value'), sigmaVal = $('sigma-value'), poissonAlphaVal = $('poissonAlpha-value');
    const magCv = $('magCanvas'), phaseCv = $('phaseCanvas'), impCv = $('impCanvas'),
          gdCv = $('gdCanvas'), pdCv = $('pdCanvas'), pzCv = $('pzCanvas'), sosOut = $('sosOut');

    function displayToggles() {
      const fam = familyEl.value, k = kindEl.value, isFIR = (fam === 'fir');

      document.querySelectorAll('.only-iir').forEach(el => el.style.display = isFIR ? 'none' : '');
      document.querySelectorAll('.only-fir').forEach(el => el.style.display = isFIR ? '' : 'none');
      
      // Show ripple controls for appropriate filter types
      document.querySelectorAll('.only-ellip').forEach(el => el.style.display = (!isFIR && fam === 'ellip') ? '' : 'none');
      document.querySelectorAll('.only-cheby1').forEach(el => el.style.display = (!isFIR && (fam === 'cheby1' || fam === 'ellip')) ? '' : 'none');
      document.querySelectorAll('.only-cheby2').forEach(el => el.style.display = (!isFIR && (fam === 'cheby2' || fam === 'ellip')) ? '' : 'none');
      
      document.querySelectorAll('.only-lp-hp').forEach(el => el.style.display = (k === 'lowpass' || k === 'highpass') ? '' : 'none');
      document.querySelectorAll('.only-bp-bs').forEach(el => el.style.display = (k === 'bandpass' || k === 'bandstop') ? '' : 'none');
      document.querySelectorAll('.only-kaiser').forEach(el => el.style.display = (isFIR && winEl.value === 'kaiser') ? '' : 'none');
      document.querySelectorAll('.only-tukey').forEach(el => el.style.display = (isFIR && winEl.value === 'tukey') ? '' : 'none');
      document.querySelectorAll('.only-gauss').forEach(el => el.style.display = (isFIR && winEl.value === 'gauss') ? '' : 'none');
      document.querySelectorAll('.only-poisson').forEach(el => el.style.display = (isFIR && winEl.value === 'poisson') ? '' : 'none');
    }

    function hookSlider(sl, out) {
      const upd = () => { out.textContent = sl.value; design(); };
      out.textContent = sl.value;
      sl.addEventListener('input', upd);
    }

    // Hook up all sliders and selects
    [orderEl, tapsEl, rpEl, rsEl, fsEl, fcEl, f1El, f2El, betaEl, alphaEl, sigmaEl, poissonAlphaEl].forEach(sl => {
      if (sl) hookSlider(sl, document.getElementById(sl.id + '-value'));
    });
    
    [familyEl, kindEl, winEl].forEach(e => e.addEventListener('change', () => { displayToggles(); design(); }));
    
    // Initial display setup
    displayToggles();

    // ---------- Canvas drawing utilities ----------
    function setupCanvas(canvas) {
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      return { ctx, w: rect.width, h: rect.height };
    }

    function clearCanvas(ctx, w, h) {
      ctx.fillStyle = '#0a1018';
      ctx.fillRect(0, 0, w, h);
    }

    function drawGrid(ctx, w, h, xTicks = 10, yTicks = 8, xLabel = '', yLabel = '', xMin = 0, xMax = 1, yMin = -1, yMax = 1) {
      const padding = 70; // Increased padding to prevent overlap
      const plotW = w - 2 * padding;
      const plotH = h - 2 * padding;
      
      // Clear background
      ctx.fillStyle = '#0a1018';
      ctx.fillRect(0, 0, w, h);
      
      // Draw grid lines
      ctx.strokeStyle = '#1b2330';
      ctx.lineWidth = 1;
      
      // Vertical grid lines
      for (let i = 0; i <= xTicks; i++) {
        const x = padding + (i / xTicks) * plotW;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, padding + plotH);
        ctx.stroke();
      }
      
      // Horizontal grid lines
      for (let i = 0; i <= yTicks; i++) {
        const y = padding + (i / yTicks) * plotH;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + plotW, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.beginPath();
      // X-axis
      ctx.moveTo(padding, padding + plotH);
      ctx.lineTo(padding + plotW, padding + plotH);
      // Y-axis
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + plotH);
      ctx.stroke();
      
      // Draw tick marks and labels
      ctx.fillStyle = '#9ca3af';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      
      // X-axis ticks and labels
      for (let i = 0; i <= xTicks; i++) {
        const x = padding + (i / xTicks) * plotW;
        const value = xMin + (i / xTicks) * (xMax - xMin);
        
        // Tick mark
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, padding + plotH);
        ctx.lineTo(x, padding + plotH + 5);
        ctx.stroke();
        
        // Label
        ctx.fillText(value.toFixed(2), x, padding + plotH + 8);
      }
      
      // Y-axis ticks and labels
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= yTicks; i++) {
        const y = padding + (i / yTicks) * plotH;
        const value = yMax - (i / yTicks) * (yMax - yMin);
        
        // Tick mark
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding - 5, y);
        ctx.stroke();
        
        // Label
        ctx.fillText(value.toFixed(1), padding - 12, y);
      }
      
      // Draw axis labels
      ctx.fillStyle = '#d1d5db';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      
      // X-axis label
      if (xLabel) {
        ctx.save();
        ctx.translate(padding + plotW/2, h - 5);
        ctx.fillText(xLabel, 0, 0);
        ctx.restore();
      }
      
      // Y-axis label
      if (yLabel) {
        ctx.save();
        ctx.translate(15, padding + plotH/2); // Moved further left to avoid overlap
        ctx.rotate(-Math.PI/2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();
      }
      
      return { padding, plotW, plotH };
    }

    function plotLine(ctx, data, w, h, color = '#6bdcff', yMin = null, yMax = null, padding = 70) {
      if (!data || data.length === 0) return;
      
      const plotW = w - 2 * padding;
      const plotH = h - 2 * padding;
      const xMin = 0, xMax = data.length - 1;
      if (yMin === null) yMin = Math.min(...data);
      if (yMax === null) yMax = Math.max(...data);
      
      // Handle edge case where yMin equals yMax
      if (yMin === yMax) {
        yMin -= 1;
        yMax += 1;
      }
      
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < data.length; i++) {
        const x = padding + ((i - xMin) / (xMax - xMin)) * plotW;
        const y = padding + plotH - ((data[i] - yMin) / (yMax - yMin)) * plotH;
        
        // Clamp y values to stay within plot area
        const clampedY = Math.max(padding, Math.min(padding + plotH, y));
        
        if (i === 0) ctx.moveTo(x, clampedY);
        else ctx.lineTo(x, clampedY);
      }
      ctx.stroke();
    }

    // ---------- Diagram redraw function ----------
    let currentFilter = null;
    let currentResponse = null;
    let currentImpResp = null;
    
    function redrawDiagrams() {
      if (!currentFilter || !currentResponse || !currentImpResp) return;
      
      try {
        // Get the currently active tab
        const activeTab = document.querySelector('.tab-content.active');
        if (!activeTab) return;
        
        const tabId = activeTab.id;
        
        // Draw diagrams based on active tab
        if (tabId === 'frequency') {
          // Draw magnitude response
          const { ctx: magCtx, w: magW, h: magH } = setupCanvas(magCv);
          const magMin = Math.min(...currentResponse.magdB);
          const magMax = Math.max(...currentResponse.magdB);
          const magRange = magMax - magMin;
          // Handle edge case where all values are the same
          const padding = magRange === 0 ? 1 : magRange * 0.1;
          const magYMin = magMin - padding;
          const magYMax = magMax + padding;
          const magGrid = drawGrid(magCtx, magW, magH, 10, 8, 'Frequency (Hz)', 'Magnitude (dB)', 
            currentResponse.freqHz[0], currentResponse.freqHz[currentResponse.freqHz.length-1], magYMin, magYMax);
          plotLine(magCtx, currentResponse.magdB, magW, magH, '#6bdcff', magYMin, magYMax, magGrid.padding);
          
          // Draw phase response
          const { ctx: phaseCtx, w: phaseW, h: phaseH } = setupCanvas(phaseCv);
          const phaseGrid = drawGrid(phaseCtx, phaseW, phaseH, 10, 8, 'Frequency (Hz)', 'Phase (deg)', 
            currentResponse.freqHz[0], currentResponse.freqHz[currentResponse.freqHz.length-1], 
            Math.min(...currentResponse.phaseDeg), Math.max(...currentResponse.phaseDeg));
          plotLine(phaseCtx, currentResponse.phaseDeg, phaseW, phaseH, '#4ade80', 
            Math.min(...currentResponse.phaseDeg), Math.max(...currentResponse.phaseDeg), phaseGrid.padding);
        }
        
        if (tabId === 'time') {
          // Draw impulse response
          const { ctx: impCtx, w: impW, h: impH } = setupCanvas(impCv);
          const impGrid = drawGrid(impCtx, impW, impH, 10, 8, 'Sample', 'Amplitude', 
            0, currentImpResp.length-1, Math.min(...currentImpResp), Math.max(...currentImpResp));
          plotLine(impCtx, currentImpResp, impW, impH, '#f87171', 
            Math.min(...currentImpResp), Math.max(...currentImpResp), impGrid.padding);
          
          // Draw group delay
          const { ctx: gdCtx, w: gdW, h: gdH } = setupCanvas(gdCv);
          const gdSamplesTrimmed = currentResponse.gdSamples.slice(1, -1);
          const gdFreqTrimmed = currentResponse.freqHz.slice(1, -1);
          const gdGrid = drawGrid(gdCtx, gdW, gdH, 10, 8, 'Frequency (Hz)', 'Group Delay (samples)', 
            gdFreqTrimmed[0], gdFreqTrimmed[gdFreqTrimmed.length-1], 
            -50, 50);
          plotLine(gdCtx, gdSamplesTrimmed, gdW, gdH, '#fbbf24', 
            -50, 50, gdGrid.padding);
          
          // Draw phase delay
          const { ctx: pdCtx, w: pdW, h: pdH } = setupCanvas(pdCv);
          const pdGrid = drawGrid(pdCtx, pdW, pdH, 10, 8, 'Frequency (Hz)', 'Phase Delay (samples)', 
            currentResponse.freqHz[0], currentResponse.freqHz[currentResponse.freqHz.length-1], 
            Math.min(...currentResponse.pdSamples), Math.max(...currentResponse.pdSamples));
          plotLine(pdCtx, currentResponse.pdSamples, pdW, pdH, '#a78bfa', 
            Math.min(...currentResponse.pdSamples), Math.max(...currentResponse.pdSamples), pdGrid.padding);
        }
        
        if (tabId === 'poles-zeros') {
          // Draw poles and zeros
          const { ctx: pzCtx, w: pzW, h: pzH } = setupCanvas(pzCv);
          const pzGrid = drawGrid(pzCtx, pzW, pzH, 10, 10, 'Real', 'Imaginary', -1.1, 1.1, -1.1, 1.1);
          
          // Use square aspect ratio for pole-zero plot, centered in the grid
          const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH);
          const centerX = pzGrid.padding + pzGrid.plotW / 2;  // Center horizontally in the full grid
          const centerY = pzGrid.padding + pzGrid.plotH / 2;  // Center vertically in the full grid
          
          // Calculate radius for unit circle (radius = 1) using square aspect ratio
          const radius = (plotSize / 2) * (1.0 / 1.1); // Scale to unit circle within the 1.1 range
          
          // Draw unit circle
          pzCtx.strokeStyle = '#374151';
          pzCtx.lineWidth = 2;
          pzCtx.beginPath();
          pzCtx.arc(centerX, centerY, Math.max(radius, 10), 0, 2*Math.PI); // Ensure minimum radius of 10
          pzCtx.stroke();
          
          // Draw poles
          if (currentFilter.zPoles) {
            pzCtx.fillStyle = '#f87171';
            pzCtx.strokeStyle = '#dc2626';
            pzCtx.lineWidth = 3;
            const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH); // Use square aspect ratio
            const plotCenterX = pzGrid.padding + plotSize / 2;
            const plotCenterY = pzGrid.padding + plotSize / 2;
            currentFilter.zPoles.forEach(pole => {
              const x = centerX + (pole.re / 1.1) * (plotSize / 2);
              const y = centerY - (pole.im / 1.1) * (plotSize / 2);
              pzCtx.beginPath();
              pzCtx.arc(x, y, 6, 0, 2*Math.PI);
              pzCtx.fill();
              pzCtx.stroke();
            });
          }
          
          // Draw zeros
          if (currentFilter.zZeros) {
            pzCtx.strokeStyle = '#4ade80';
            pzCtx.lineWidth = 2;
            const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH); // Use square aspect ratio
            const plotCenterX = pzGrid.padding + plotSize / 2;
            const plotCenterY = pzGrid.padding + plotSize / 2;
            currentFilter.zZeros.forEach(zero => {
              const x = centerX + (zero.re / 1.1) * (plotSize / 2);
              const y = centerY - (zero.im / 1.1) * (plotSize / 2);
              pzCtx.beginPath();
              pzCtx.moveTo(x-8, y-8);
              pzCtx.lineTo(x+8, y+8);
              pzCtx.moveTo(x+8, y-8);
              pzCtx.lineTo(x-8, y+8);
              pzCtx.stroke();
            });
          }
          
          // Draw FIR zeros if available
          if (currentFilter.type === 'FIR' && currentFilter.zeros) {
            pzCtx.strokeStyle = '#4ade80';
            pzCtx.lineWidth = 2;
            const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH); // Use square aspect ratio
            const plotCenterX = pzGrid.padding + plotSize / 2;
            const plotCenterY = pzGrid.padding + plotSize / 2;
            currentFilter.zeros().forEach(zero => {
              const x = centerX + (zero.re / 1.1) * (plotSize / 2);
              const y = centerY - (zero.im / 1.1) * (plotSize / 2);
              pzCtx.beginPath();
              pzCtx.moveTo(x-8, y-8);
              pzCtx.lineTo(x+8, y+8);
              pzCtx.moveTo(x+8, y-8);
              pzCtx.lineTo(x-8, y+8);
              pzCtx.stroke();
            });
          }
        }
      } catch (error) {
        console.error('Redraw error:', error);
      }
    }

    // ---------- Biquad combination function ----------
    function combineBiquads(sections) {
      if (!sections || sections.length === 0) {
        return { b: [1], a: [1] };
      }
      
      // Start with the first section
      let combinedB = [...sections[0].b];
      let combinedA = [...sections[0].a];
      
      // Multiply each subsequent section
      for (let i = 1; i < sections.length; i++) {
        const section = sections[i];
        
        // Multiply numerator polynomials (b coefficients)
        combinedB = multiplyPolynomials(combinedB, section.b);
        
        // Multiply denominator polynomials (a coefficients)
        combinedA = multiplyPolynomials(combinedA, section.a);
      }
      
      return { b: combinedB, a: combinedA };
    }
    
    // Polynomial multiplication function
    function multiplyPolynomials(poly1, poly2) {
      const result = new Array(poly1.length + poly2.length - 1).fill(0);
      
      for (let i = 0; i < poly1.length; i++) {
        for (let j = 0; j < poly2.length; j++) {
          result[i + j] += poly1[i] * poly2[j];
        }
      }
      
      return result;
    }

    // ---------- Main design function ----------
    function design() {
      try {
        const fam = familyEl.value, kind = kindEl.value;
        const Fs = parseFloat(fsEl.value);
        const isFIR = (fam === 'fir');
        
        let filter;
        
        if (isFIR) {
          const taps = parseInt(tapsEl.value);
          const window = winEl.value;
          const beta = parseFloat(betaEl.value);
          const alpha = parseFloat(alphaEl.value);
          const sigma = parseFloat(sigmaEl.value);
          const poissonAlpha = parseFloat(poissonAlphaEl.value);
          
          let f1, f2;
          if (kind === 'lowpass' || kind === 'highpass') {
            f1 = parseFloat(fcEl.value);
            f2 = f1;
          } else {
            f1 = parseFloat(f1El.value);
            f2 = parseFloat(f2El.value);
          }
          
          const spec = { kind, taps, Fs, f1, f2, window, beta, alpha, sigma, poissonAlpha };
          filter = FilterDSPClass.designFIR(spec);
        } else {
          const N = parseInt(orderEl.value);
          const Rp = parseFloat(rpEl.value);
          const Rs = parseFloat(rsEl.value);
          
          let f1, f2;
          if (kind === 'lowpass' || kind === 'highpass') {
            f1 = parseFloat(fcEl.value);
            f2 = f1;
          } else {
            f1 = parseFloat(f1El.value);
            f2 = parseFloat(f2El.value);
          }
          
          const spec = { family: fam, kind, N, Rp, Rs, Fs, f1, f2 };
          filter = FilterDSPClass.designIIR(spec);
        }
        
        // Get frequency response
        const response = filter.frequencyGrid(1024);
        
        // Store current data for efficient redrawing
        currentFilter = filter;
        currentResponse = response;
        currentImpResp = filter.impulseResponse(256);
        
        // Draw magnitude response
        const { ctx: magCtx, w: magW, h: magH } = setupCanvas(magCv);
        const magMin = Math.min(...response.magdB);
        const magMax = Math.max(...response.magdB);
        const magRange = magMax - magMin;
        // Handle edge case where all values are the same
        const padding = magRange === 0 ? 1 : magRange * 0.1;
        const magYMin = magMin - padding;
        const magYMax = magMax + padding;
        const magGrid = drawGrid(magCtx, magW, magH, 10, 8, 'Frequency (Hz)', 'Magnitude (dB)', 
          response.freqHz[0], response.freqHz[response.freqHz.length-1], magYMin, magYMax);
        plotLine(magCtx, response.magdB, magW, magH, '#6bdcff', magYMin, magYMax, magGrid.padding);
        
        // Draw phase response
        const { ctx: phaseCtx, w: phaseW, h: phaseH } = setupCanvas(phaseCv);
        const phaseGrid = drawGrid(phaseCtx, phaseW, phaseH, 10, 8, 'Frequency (Hz)', 'Phase (deg)', 
          response.freqHz[0], response.freqHz[response.freqHz.length-1], 
          Math.min(...response.phaseDeg), Math.max(...response.phaseDeg));
        plotLine(phaseCtx, response.phaseDeg, phaseW, phaseH, '#4ade80', 
          Math.min(...response.phaseDeg), Math.max(...response.phaseDeg), phaseGrid.padding);
        
        // Draw impulse response
        const impResp = filter.impulseResponse(256);
        const { ctx: impCtx, w: impW, h: impH } = setupCanvas(impCv);
        const impGrid = drawGrid(impCtx, impW, impH, 10, 8, 'Sample', 'Amplitude', 
          0, impResp.length-1, Math.min(...impResp), Math.max(...impResp));
        plotLine(impCtx, impResp, impW, impH, '#f87171', 
          Math.min(...impResp), Math.max(...impResp), impGrid.padding);
        
        // Draw group delay
        const { ctx: gdCtx, w: gdW, h: gdH } = setupCanvas(gdCv);
        const gdSamplesTrimmed = response.gdSamples.slice(1, -1);
        const gdFreqTrimmed = response.freqHz.slice(1, -1);
        const gdGrid = drawGrid(gdCtx, gdW, gdH, 10, 8, 'Frequency (Hz)', 'Group Delay (samples)', 
          gdFreqTrimmed[0], gdFreqTrimmed[gdFreqTrimmed.length-1], 
          -50, 50);
        plotLine(gdCtx, gdSamplesTrimmed, gdW, gdH, '#fbbf24', 
          -50, 50, gdGrid.padding);
        
        // Draw phase delay
        const { ctx: pdCtx, w: pdW, h: pdH } = setupCanvas(pdCv);
        const pdGrid = drawGrid(pdCtx, pdW, pdH, 10, 8, 'Frequency (Hz)', 'Phase Delay (samples)', 
          response.freqHz[0], response.freqHz[response.freqHz.length-1], 
          Math.min(...response.pdSamples), Math.max(...response.pdSamples));
        plotLine(pdCtx, response.pdSamples, pdW, pdH, '#a78bfa', 
          Math.min(...response.pdSamples), Math.max(...response.pdSamples), pdGrid.padding);
        
        // Draw pole-zero plot
        const { ctx: pzCtx, w: pzW, h: pzH } = setupCanvas(pzCv);
        const pzGrid = drawGrid(pzCtx, pzW, pzH, 10, 10, 'Real', 'Imaginary', -1.1, 1.1, -1.1, 1.1);
        
        // Use square aspect ratio for pole-zero plot, centered in the grid
        const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH);
        const centerX = pzGrid.padding + pzGrid.plotW / 2;  // Center horizontally in the full grid
        const centerY = pzGrid.padding + pzGrid.plotH / 2;  // Center vertically in the full grid
        
        // Calculate radius for unit circle (radius = 1) using square aspect ratio
        const radius = (plotSize / 2) * (1.0 / 1.1); // Scale to unit circle within the 1.1 range
        
        // Draw crosshairs at origin for debugging
        pzCtx.strokeStyle = '#666';
        pzCtx.lineWidth = 1;
        pzCtx.setLineDash([3, 3]);
        pzCtx.beginPath();
        pzCtx.moveTo(centerX - 20, centerY);
        pzCtx.lineTo(centerX + 20, centerY);
        pzCtx.moveTo(centerX, centerY - 20);
        pzCtx.lineTo(centerX, centerY + 20);
        pzCtx.stroke();
        pzCtx.setLineDash([]);
        
        // Draw unit circle
        pzCtx.strokeStyle = '#374151';
        pzCtx.lineWidth = 2;
        pzCtx.beginPath();
        pzCtx.arc(centerX, centerY, Math.max(radius, 10), 0, 2*Math.PI); // Ensure minimum radius of 10
        pzCtx.stroke();
        
        // Draw poles and zeros
        if (filter.type === 'IIR') {
          // Draw poles (circles)
          pzCtx.fillStyle = '#f87171';
          pzCtx.strokeStyle = '#dc2626';
          pzCtx.lineWidth = 3;
          const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH); // Use square aspect ratio
          const plotCenterX = pzGrid.padding + plotSize / 2;
          const plotCenterY = pzGrid.padding + plotSize / 2;
          filter.zPoles.forEach(pole => {
            const x = centerX + (pole.re / 1.1) * (plotSize / 2);
            const y = centerY - (pole.im / 1.1) * (plotSize / 2);
            pzCtx.beginPath();
            pzCtx.arc(x, y, 6, 0, 2*Math.PI);
            pzCtx.fill();
            pzCtx.stroke();
          });
          
          // Draw zeros (X marks)
          pzCtx.strokeStyle = '#4ade80';
          pzCtx.lineWidth = 2;
          filter.zZeros.forEach(zero => {
            const x = centerX + (zero.re / 1.1) * (plotSize / 2);
            const y = centerY - (zero.im / 1.1) * (plotSize / 2);
            pzCtx.beginPath();
            pzCtx.moveTo(x-8, y-8);
            pzCtx.lineTo(x+8, y+8);
            pzCtx.moveTo(x+8, y-8);
            pzCtx.lineTo(x-8, y+8);
            pzCtx.stroke();
          });
        } else {
          // For FIR, draw zeros
          const zeros = filter.zeros();
          pzCtx.strokeStyle = '#4ade80';
          pzCtx.lineWidth = 2;
          const plotSize = Math.min(pzGrid.plotW, pzGrid.plotH); // Use square aspect ratio
          const plotCenterX = pzGrid.padding + plotSize / 2;
          const plotCenterY = pzGrid.padding + plotSize / 2;
          zeros.forEach(zero => {
            const x = centerX + (zero.re / 1.1) * (plotSize / 2);
            const y = centerY - (zero.im / 1.1) * (plotSize / 2);
            pzCtx.beginPath();
            pzCtx.moveTo(x-8, y-8);
            pzCtx.lineTo(x+8, y+8);
            pzCtx.moveTo(x+8, y-8);
            pzCtx.lineTo(x-8, y+8);
            pzCtx.stroke();
          });
        }
        
        // Add labels
        pzCtx.fillStyle = '#9bb0c8';
        pzCtx.font = '12px system-ui';
        pzCtx.textAlign = 'center';
        pzCtx.fillText('1', centerX + radius + 15, centerY + 5);
        pzCtx.fillText('-1', centerX - radius - 15, centerY + 5);
        pzCtx.textAlign = 'right';
        pzCtx.fillText('j', centerX - 5, centerY - radius - 10);
        pzCtx.fillText('-j', centerX - 5, centerY + radius + 15);
        
        // Display filter coefficients
        let output = '';
        if (filter.type === 'IIR') {
          output = '// IIR Filter - Second Order Sections\n';
          filter.sections.forEach((section, i) => {
            output += `// Section ${i + 1}\n`;
            output += `b = [${section.b.map(x => x.toFixed(6)).join(', ')}];\n`;
            output += `a = [${section.a.map(x => x.toFixed(6)).join(', ')}];\n\n`;
          });
          
          // Add combined transfer function
          output += '// Combined Transfer Function (Biquads Multiplied)\n';
          const combined = combineBiquads(filter.sections);
          output += `// Numerator coefficients (b):\n`;
          output += `b_combined = [${combined.b.map(x => x.toFixed(6)).join(', ')}];\n\n`;
          output += `// Denominator coefficients (a):\n`;
          output += `a_combined = [${combined.a.map(x => x.toFixed(6)).join(', ')}];\n\n`;
          output += `// Transfer function: H(z) = (b_combined[0] + b_combined[1]*z^-1 + ... + b_combined[n]*z^-n) / (a_combined[0] + a_combined[1]*z^-1 + ... + a_combined[n]*z^-n)\n`;
        } else {
          output = '// FIR Filter - Taps\n';
          output += `taps = [${filter.taps.map(x => x.toFixed(6)).join(', ')}];\n`;
        }
        sosOut.textContent = output;
        
      } catch (error) {
        console.error('Design error:', error);
        sosOut.textContent = `Error: ${error.message}`;
      }
    }

    // Initial design
    design();
    
  })();
  </script>
</body>
</html>
