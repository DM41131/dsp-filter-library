{"version":3,"file":"dsp-filter-library.min.js","sources":["../src/complex.js","../src/utils.js","../src/fft.js","../src/windows.js","../src/fir.js","../src/base-iir-filter.js","../src/butterworth-filter.js","../src/chebyshev-filter.js","../src/chebyshev-type2-filter.js","../src/linkwitz-riley-filter.js","../src/elliptic-filter.js","../src/bessel-filter.js","../src/iir.js","../src/zdomain.js","../src/filter-class.js","../src/index.js"],"sourcesContent":["// complex.js — Complex number operations for DSP\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\n/**\r\n * @typedef {{re:number, im:number}} Complex\r\n */\r\n\r\n/**\r\n * Complex number operations for digital signal processing\r\n */\r\nexport class ComplexNum {\r\n    /** @returns {Complex} */ \r\n    static of(re = 0, im = 0) { \r\n        return { re, im }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static add(a, b) { \r\n        return { re: a.re + b.re, im: a.im + b.im }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static sub(a, b) { \r\n        return { re: a.re - b.re, im: a.im - b.im }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static mul(a, b) { \r\n        return { re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static scale(a, s) { \r\n        return { re: a.re * s, im: a.im * s }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static conj(a) { \r\n        return { re: a.re, im: -a.im }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static div(a, b) {\r\n        const d = b.re*b.re + b.im*b.im || 1e-300;\r\n        return { re: (a.re*b.re + a.im*b.im)/d, im: (a.im*b.re - a.re*b.im)/d };\r\n    }\r\n    \r\n    /** @returns {number} */ \r\n    static abs(a) { \r\n        return Math.hypot(a.re, a.im); \r\n    }\r\n    \r\n    /** @returns {number} */ \r\n    static arg(a) { \r\n        return Math.atan2(a.im, a.re); \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static expj(theta) { \r\n        return { re: Math.cos(theta), im: Math.sin(theta) }; \r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static pow(a, n) {\r\n        if (n === 0) return { re: 1, im: 0 };\r\n        if (n === 1) return a;\r\n        if (n === -1) return C.div({ re: 1, im: 0 }, a);\r\n        \r\n        if (n > 0) {\r\n            let result = { re: 1, im: 0 };\r\n            for (let i = 0; i < n; i++) {\r\n                result = C.mul(result, a);\r\n            }\r\n            return result;\r\n        } else {\r\n            // For negative powers, use 1/a^n\r\n            let result = { re: 1, im: 0 };\r\n            for (let i = 0; i < -n; i++) {\r\n                result = C.mul(result, a);\r\n            }\r\n            return C.div({ re: 1, im: 0 }, result);\r\n        }\r\n    }\r\n    \r\n    /** @returns {Complex} */ \r\n    static sqrt(a) {\r\n        const r = Math.sqrt(C.abs(a));\r\n        const theta = Math.atan2(a.im, a.re) / 2;\r\n        return { re: r * Math.cos(theta), im: r * Math.sin(theta) };\r\n    }\r\n}\r\n\r\n// Legacy alias for backward compatibility\r\nexport const C = ComplexNum;\r\n","// utils.js — Mathematical utilities for DSP\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\n\r\n/**\r\n * Utility functions for digital signal processing\r\n */\r\nexport class Util {\r\n  /**\r\n   * Next power of 2 >= n.\r\n   * Uses multiplication to avoid 32-bit overflow from bit shifts.\r\n   */\r\n  static nextPow2(n) {\r\n    if (!Number.isFinite(n) || n <= 1) return 1;\r\n    let p = 1;\r\n    while (p < n) p *= 2;\r\n    return p;\r\n  }\r\n\r\n\r\n  /**\r\n   * Inclusive linspace from start to end with n points.\r\n   * n <= 0 → []\r\n   * n = 1 → [start]\r\n   */\r\n  static linspace(start, end, n) {\r\n    if (n <= 0) return [];\r\n    if (n === 1) return [start];\r\n    const step = (end - start) / (n - 1);\r\n    return Array.from({ length: n }, (_, i) => start + i * step);\r\n  }\r\n\r\n\r\n  /** Naive linear convolution (length x+h-1). */\r\n  static convolve(x, h) {\r\n    const y = new Array(x.length + h.length - 1).fill(0);\r\n    for (let i = 0; i < x.length; i++) {\r\n      const xi = x[i];\r\n      for (let j = 0; j < h.length; j++) y[i + j] += xi * h[j];\r\n    }\r\n    return y;\r\n  }\r\n\r\n  /** Real-coefficient polynomial multiplication. */\r\n  static polymul(a, b) {\r\n    const na = a.length, nb = b.length;\r\n    const r = new Array(na + nb - 1).fill(0);\r\n    for (let i = 0; i < na; i++)\r\n      for (let j = 0; j < nb; j++)\r\n        r[i + j] += a[i] * b[j];\r\n    return r;\r\n  }\r\n\r\n  /** Real-coefficient polynomial addition. */\r\n  static polyadd(a, b) {\r\n    const maxLen = Math.max(a.length, b.length);\r\n    const result = new Array(maxLen).fill(0);\r\n    for (let i = 0; i < maxLen; i++) {\r\n      if (i < a.length) result[i] += a[i];\r\n      if (i < b.length) result[i] += b[i];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Build a real-coefficient polynomial from (possibly complex) roots.\r\n   * - Real roots contribute (x - r).\r\n   * - Complex roots contribute (x^2 - 2 Re(r) x + |r|^2).\r\n   * Robust to missing explicit conjugate: if a root has non-negligible\r\n   * imaginary part but no partner is found, we still multiply by its\r\n   * implied conjugate's quadratic.\r\n   */\r\n  static polyfromroots(roots, tol = 1e-12) {\r\n    const used = new Array(roots.length).fill(false);\r\n    let p = [1];\r\n\r\n    for (let i = 0; i < roots.length; i++) {\r\n      if (used[i]) continue;\r\n      const r = roots[i];\r\n\r\n      // Try to find its conjugate partner\r\n      let pair = -1;\r\n      for (let j = i + 1; j < roots.length; j++) {\r\n        if (used[j]) continue;\r\n        const s = roots[j];\r\n        if (Math.abs(r.re - s.re) < tol && Math.abs(r.im + s.im) < tol) {\r\n          pair = j; break;\r\n        }\r\n      }\r\n\r\n      if (Math.abs(r.im) < 1e-14) {\r\n        // Real root\r\n        p = Util.polymul(p, [1, -r.re]);\r\n        used[i] = true;\r\n      } else if (pair >= 0) {\r\n        // Found explicit conjugate\r\n        const a2 = [1, -2 * r.re, r.re * r.re + r.im * r.im];\r\n        p = Util.polymul(p, a2);\r\n        used[i] = used[pair] = true;\r\n      } else {\r\n        // No explicit partner — multiply by the quadratic implied by conjugation\r\n        const a2 = [1, -2 * r.re, r.re * r.re + r.im * r.im];\r\n        p = Util.polymul(p, a2);\r\n        used[i] = true;\r\n      }\r\n    }\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Prewarp digital edge frequency to analog frequency for bilinear transform\r\n   * @param {number} fHz - Digital frequency in Hz\r\n   * @param {number} fs - Sampling frequency in Hz\r\n   * @returns {number} Analog frequency in rad/s\r\n   */\r\n  static prewarp(fHz, fs) {\r\n    return 2 * fs * Math.tan(Math.PI * fHz / fs);\r\n  }\r\n\r\n  /**\r\n   * Pairs conjugate poles for SOS construction\r\n   * @param {C[]} list - List of complex numbers\r\n   * @returns {C[][]} Array of pole pairs\r\n   */\r\n  static pairConjugates(list) {\r\n    const used = new Array(list.length).fill(false);\r\n    const out = [];\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (used[i]) continue;\r\n      const p = list[i];\r\n      let pair = -1;\r\n      for (let j = i + 1; j < list.length; j++) {\r\n        if (used[j]) continue;\r\n        const q = list[j];\r\n        if (Math.abs(p.re - q.re) < 1e-12 && Math.abs(p.im + q.im) < 1e-12) { \r\n          pair = j; \r\n          break; \r\n        }\r\n      }\r\n      if (pair >= 0) { \r\n        out.push([p, list[pair]]); \r\n        used[i] = used[pair] = true; \r\n      } else { \r\n        out.push([p]); \r\n        used[i] = true; \r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Maps analog biquad to digital biquad via bilinear transform\r\n   * @param {number} b2 - Numerator s^2 coefficient\r\n   * @param {number} b1 - Numerator s coefficient\r\n   * @param {number} b0 - Numerator constant\r\n   * @param {number} a2 - Denominator s^2 coefficient\r\n   * @param {number} a1 - Denominator s coefficient\r\n   * @param {number} a0 - Denominator constant\r\n   * @param {number} fs - Sampling frequency\r\n   * @returns {{b: [number, number, number], a: [number, number, number]}} Digital biquad coefficients\r\n   */\r\n  static bilinearMapBiquad(b2, b1, b0, a2, a1, a0, fs) {\r\n    const K = 2 * fs;\r\n\r\n    const B0 = b2 * K * K + b1 * K + b0;\r\n    const B1 = 2 * (b0 - b2 * K * K);\r\n    const B2 = b2 * K * K - b1 * K + b0;\r\n\r\n    const A0 = a2 * K * K + a1 * K + a0;\r\n    const A1 = 2 * (a0 - a2 * K * K);\r\n    const A2 = a2 * K * K - a1 * K + a0;\r\n\r\n    return {\r\n      b: [B0 / A0, B1 / A0, B2 / A0],\r\n      a: [1, A1 / A0, A2 / A0]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Evaluates transfer function H(z) at a real z0\r\n   * @param {number[]} b - Numerator coefficients\r\n   * @param {number[]} a - Denominator coefficients\r\n   * @param {number} z0 - Real z value\r\n   * @returns {number} Transfer function value\r\n   */\r\n  static evalHzAtZ(b, a, z0) {\r\n    const num = b.reduce((acc, bi, i) => acc + bi * Math.pow(z0, -i), 0);\r\n    const den = a.reduce((acc, ai, i) => acc + ai * Math.pow(z0, -i), 0);\r\n    return num / den;\r\n  }\r\n}\r\n","// fft.js — Fast Fourier Transform operations\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\n\r\n/**\r\n * Fast Fourier Transform operations for digital signal processing\r\n */\r\nexport class FFT {\r\n    /** @param {Complex[]} x */\r\n    static fft(x) {\r\n        let n = x.length;\r\n        if (n <= 1) return x;\r\n        if ((n & (n - 1)) !== 0) {\r\n            const m = Util.nextPow2(n);\r\n            return FFT.fft(x.concat(Array.from({ length: m - n }, () => C.of(0, 0))));\r\n        }\r\n        // bit-reverse\r\n        let j = 0;\r\n        for (let i = 1; i < n - 1; i++) {\r\n            let bit = n >> 1;\r\n            for (; j & bit; bit >>= 1) j ^= bit;\r\n            j ^= bit;\r\n            if (i < j) { const t = x[i]; x[i] = x[j]; x[j] = t; }\r\n        }\r\n        // stages\r\n        for (let len = 2; len <= n; len <<= 1) {\r\n            const ang = -2 * Math.PI / len;\r\n            for (let i = 0; i < n; i += len) {\r\n                for (let k = 0; k < len / 2; k++) {\r\n                    const w = C.expj(ang * k);\r\n                    const u = x[i + k];\r\n                    const v = C.mul(x[i + k + (len >> 1)], w);\r\n                    x[i + k] = C.add(u, v);\r\n                    x[i + k + (len >> 1)] = C.sub(u, v);\r\n                }\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** @param {Complex[]} X */\r\n    static ifft(X) {\r\n        const n = X.length;\r\n        return FFT.fft(X.map(C.conj)).map(C.conj).map(v => C.scale(v, 1 / n));\r\n    }\r\n    \r\n    /** @param {number[]} x */\r\n    static rfft(x) {\r\n        const n = Util.nextPow2(x.length);\r\n        const a = Array.from({ length: n }, (_, i) => C.of(x[i] || 0, 0));\r\n        return FFT.fft(a);\r\n    }\r\n    \r\n    /** @param {number[]} x */\r\n    static powerSpectrum(x) {\r\n        return FFT.rfft(x).map(C.abs).map(v => v*v);\r\n    }\r\n}\r\n","// windows.js — Windowing functions for DSP\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\n/**\r\n * Windowing functions for digital signal processing\r\n */\r\nexport class Window {\r\n    static rect(N) { \r\n        return Array.from({ length: N }, () => 1); \r\n    }\r\n    \r\n    static rectangle(N) { \r\n        return Window.rect(N); \r\n    }\r\n    \r\n    static hann(N) { \r\n        return Array.from({ length: N }, (_, n) => 0.5 - 0.5*Math.cos(2*Math.PI*n/(N-1))); \r\n    }\r\n    \r\n    static hamming(N) { \r\n        return Array.from({ length: N }, (_, n) => 0.54 - 0.46*Math.cos(2*Math.PI*n/(N-1))); \r\n    }\r\n    \r\n    static blackman(N) {\r\n        const a0 = 0.42, a1 = 0.5, a2 = 0.08;\r\n        return Array.from({ length: N }, (_, n) =>\r\n            a0 - a1*Math.cos(2*Math.PI*n/(N-1)) + a2*Math.cos(4*Math.PI*n/(N-1)));\r\n    }\r\n    \r\n    static blackmanHarris(N) {\r\n        const a0 = 0.35875, a1 = 0.48829, a2 = 0.14128, a3 = 0.01168;\r\n        return Array.from({ length: N }, (_, n) =>\r\n            a0 - a1*Math.cos(2*Math.PI*n/(N-1)) + a2*Math.cos(4*Math.PI*n/(N-1)) - a3*Math.cos(6*Math.PI*n/(N-1)));\r\n    }\r\n    \r\n    static blackmanNuttall(N) {\r\n        const a0 = 0.3635819, a1 = 0.4891775, a2 = 0.1365995, a3 = 0.0106411;\r\n        return Array.from({ length: N }, (_, n) =>\r\n            a0 - a1*Math.cos(2*Math.PI*n/(N-1)) + a2*Math.cos(4*Math.PI*n/(N-1)) - a3*Math.cos(6*Math.PI*n/(N-1)));\r\n    }\r\n    \r\n    static kaiser(N, beta = 8.6) {\r\n        const denom = _i0(beta), M = N - 1;\r\n        return Array.from({ length: N }, (_, n) => {\r\n            const t = (2*n)/M - 1;\r\n            return _i0(beta * Math.sqrt(1 - t*t)) / denom;\r\n        });\r\n    }\r\n    \r\n    static tukey(N, alpha = 0.5) {\r\n        const M = N - 1;\r\n        return Array.from({ length: N }, (_, n) => {\r\n            const x = n / M;\r\n            if (alpha <= 0) return 1;\r\n            if (alpha >= 1) return 0.5*(1 - Math.cos(2*Math.PI*x));\r\n            if (x < alpha/2) return 0.5*(1 + Math.cos(Math.PI*(2*x/alpha - 1)));\r\n            if (x <= 1 - alpha/2) return 1;\r\n            return 0.5*(1 + Math.cos(Math.PI*(2*x/alpha - 2/alpha + 1)));\r\n        });\r\n    }\r\n    \r\n    static gauss(N, sigma = 0.4) {\r\n        const M = N - 1, m2 = M/2;\r\n        return Array.from({ length: N }, (_, n) => {\r\n            const k = (n - m2) / (sigma * m2);\r\n            return Math.exp(-0.5*k*k);\r\n        });\r\n    }\r\n    \r\n    static bartlett(N) {\r\n        const M = N - 1;\r\n        return Array.from({ length: N }, (_, n) => 1 - Math.abs((n - M/2)/(M/2)));\r\n    }\r\n    \r\n    static bartlettHann(N) {\r\n        const M = N - 1;\r\n        return Array.from({ length: N }, (_, n) => {\r\n            const x = n / M;\r\n            return 0.62 - 0.48*Math.abs(x - 0.5) - 0.38*Math.cos(2*Math.PI*x);\r\n        });\r\n    }\r\n    \r\n    static cosine(N) {\r\n        const M = N - 1;\r\n        return Array.from({ length: N }, (_, n) => Math.sin(Math.PI*n/M));\r\n    }\r\n    \r\n    static lanczos(N) {\r\n        const M = N - 1, m2 = M/2;\r\n        const sinc = (x) => x === 0 ? 1 : Math.sin(Math.PI*x)/(Math.PI*x);\r\n        return Array.from({ length: N }, (_, n) => sinc((n - m2)/m2));\r\n    }\r\n    \r\n    static bohman(N) {\r\n        const M = N - 1, m2 = M/2;\r\n        return Array.from({ length: N }, (_, n) => {\r\n            const x = Math.abs(n - m2) / m2;\r\n            return (x <= 1) ? (1 - x)*Math.cos(Math.PI*x) + (1/Math.PI)*Math.sin(Math.PI*x) : 0;\r\n        });\r\n    }\r\n    \r\n    static flatTop(N) {\r\n        const a0 = 1.0, a1 = 1.93, a2 = 1.29, a3 = 0.388, a4 = 0.028;\r\n        const M = N - 1;\r\n        return Array.from({ length: N }, (_, n) =>\r\n            a0 - a1*Math.cos(2*Math.PI*n/M) + a2*Math.cos(4*Math.PI*n/M) -\r\n            a3*Math.cos(6*Math.PI*n/M) + a4*Math.cos(8*Math.PI*n/M)\r\n        );\r\n    }\r\n    \r\n    /** @param {keyof Window| string} name */\r\n    static byName(name, N, opts = {}) {\r\n        const { beta = 8.6, alpha = 0.5, sigma = 0.4 } = opts || {};\r\n        switch (name) {\r\n            case 'hann': return Window.hann(N);\r\n            case 'hamming': return Window.hamming(N);\r\n            case 'blackman': return Window.blackman(N);\r\n            case 'blackmanHarris': return Window.blackmanHarris(N);\r\n            case 'blackmanNuttall': return Window.blackmanNuttall(N);\r\n            case 'rectangle':\r\n            case 'rect': return Window.rect(N);\r\n            case 'bartlett': return Window.bartlett(N);\r\n            case 'bartlettHann': return Window.bartlettHann(N);\r\n            case 'cosine': return Window.cosine(N);\r\n            case 'lanczos': return Window.lanczos(N);\r\n            case 'bohman': return Window.bohman(N);\r\n            case 'gauss':\r\n            case 'gaussian': return Window.gauss(N, sigma);\r\n            case 'tukey': return Window.tukey(N, alpha);\r\n            case 'kaiser': return Window.kaiser(N, beta);\r\n            case 'flatTop':\r\n            case 'flattop': return Window.flatTop(N);\r\n            default: return Window.rect(N);\r\n        }\r\n    }\r\n}\r\n\r\n// Modified Bessel function of the first kind, order zero\r\nconst _i0 = (x) => {\r\n    const ax = Math.abs(x);\r\n    if (ax < 3.75) {\r\n        const t = x / 3.75, t2 = t*t;\r\n        return 1 + t2 * (3.5156229 + t2 * (3.0899424 + t2 * (1.2067492 +\r\n                t2 * (0.2659732 + t2 * (0.0360768 + t2 * 0.0045813)))));\r\n    } else {\r\n        const t = 3.75 / ax;\r\n        return (Math.exp(ax) / Math.sqrt(ax)) * (\r\n            0.39894228 + t * (0.01328592 + t * (0.00225319 + t * (-0.00157565 +\r\n            t * (0.00916281 + t * (-0.02057706 + t * (0.02635537 + t *\r\n            (-0.01647633 + t * 0.00392377)))))))\r\n        );\r\n    }\r\n};\r\n","// fir.js — Finite Impulse Response filter design\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { FFT } from './fft.js';\r\nimport { Window } from './windows.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FiltKind\r\n * @typedef {{b:number[], a:number[]}} TF\r\n */\r\n\r\n/**\r\n * FIR filter kernels and design functions\r\n */\r\nexport class Kernels {\r\n    static sinc(x) { \r\n        return x === 0 ? 1 : Math.sin(Math.PI * x) / (Math.PI * x); \r\n    }\r\n    \r\n    static idealLowpass(fc, fs, N) {\r\n        const M = N - 1, norm = fc / fs;\r\n        return Array.from({ length: N }, (_, n) => Kernels.sinc((n - M/2) * 2 * norm));\r\n    }\r\n}\r\n\r\n/**\r\n * FIR filter designer\r\n */\r\nexport class FIRDesigner {\r\n    /**\r\n     * @param {FiltKind} kind\r\n     * @param {number|[number,number]} cutoffHz\r\n     * @param {number} fs\r\n     * @param {number} order\r\n     * @param {string} window\r\n     * @returns {TF}\r\n     */\r\n    static design(kind, cutoffHz, fs, order, window = 'hann') {\r\n        const N = order + 1;\r\n        const win = Window.byName(window, N);\r\n        const M = N - 1;\r\n        const applyWin = (h) => h.map((v, i) => v * win[i]);\r\n\r\n        if (kind === 'lowpass') {\r\n            const fc = /** @type {number} */(cutoffHz);\r\n            let h = Kernels.idealLowpass(fc, fs, N);\r\n            const scale = 2 * fc / fs;\r\n            h = h.map(v => v * scale);\r\n            return { b: applyWin(h), a: [1] };\r\n        }\r\n        if (kind === 'highpass') {\r\n            const fc = /** @type {number} */(cutoffHz);\r\n            const lp = FIRDesigner.design('lowpass', fc, fs, order, window).b;\r\n            const b = lp.map((v, n) => (n === M/2 ? 1 - v : -v));\r\n            return { b, a: [1] };\r\n        }\r\n        if (kind === 'bandpass') {\r\n            const [f1, f2] = /** @type {[number,number]} */(cutoffHz);\r\n            const lp2 = FIRDesigner.design('lowpass', f2, fs, order, window).b;\r\n            const lp1 = FIRDesigner.design('lowpass', f1, fs, order, window).b;\r\n            const b = lp2.map((v, i) => v - lp1[i]);\r\n            return { b, a: [1] };\r\n        }\r\n        if (kind === 'bandstop') {\r\n            const [f1, f2] = /** @type {[number,number]} */(cutoffHz);\r\n            const bp = FIRDesigner.design('bandpass', [f1, f2], fs, order, window).b;\r\n            const b = bp.map((v, n) => (n === M/2 ? 1 - v : -v));\r\n            return { b, a: [1] };\r\n        }\r\n        throw new Error('Unsupported FIR type');\r\n    }\r\n\r\n    static apply(b, x) { \r\n        return Util.convolve(x, b); \r\n    }\r\n\r\n    static overlapAdd(b, x, blockSize) {\r\n        const L = blockSize || 1024;\r\n        const M = b.length;\r\n        const Nfft = Util.nextPow2(L + M - 1);\r\n        const B = FFT.fft(Array.from({ length: Nfft }, (_, i) => C.of(b[i] || 0, 0)));\r\n        const y = new Array(x.length + M - 1).fill(0);\r\n        for (let start = 0; start < x.length; start += L) {\r\n            const xblk = Array.from({ length: Nfft }, (_, i) => C.of(x[start + i] || 0, 0));\r\n            const X = FFT.fft(xblk);\r\n            const Y = X.map((Xk, k) => C.mul(Xk, B[k]));\r\n            const yblk = FFT.ifft(Y);\r\n            for (let i = 0; i < L + M - 1; i++) y[start + i] += yblk[i].re;\r\n        }\r\n        return y;\r\n    }\r\n}\r\n","// base-iir-filter.js — Base class for IIR filter design\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FilterKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad\r\n * @typedef {{b: number[], a: number[], sections: Biquad[]}} FilterResult\r\n */\r\n\r\n/**\r\n * Abstract base class for IIR filter design\r\n * Provides common functionality and structure for all IIR filter types\r\n */\r\nexport class BaseIIRFilter {\r\n  /**\r\n   * Validates common filter parameters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @throws {Error} If parameters are invalid\r\n   */\r\n  static validateCommonParameters(kind, cutoffHz, fs, order) {\r\n    if (order < 1) {\r\n      throw new Error('Order must be >= 1');\r\n    }\r\n    \r\n    if (fs <= 0) {\r\n      throw new Error('Sampling frequency must be positive');\r\n    }\r\n    \r\n    if (kind === 'lowpass' || kind === 'highpass') {\r\n      const fc = /** @type {number} */ (cutoffHz);\r\n      if (fc <= 0 || fc >= fs / 2) {\r\n        throw new Error('Cutoff frequency must be 0 < fc < fs/2');\r\n      }\r\n    } else if (kind === 'bandpass' || kind === 'bandstop') {\r\n      const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n      if (!(f1 > 0 && f2 > f1 && f2 < fs / 2)) {\r\n        throw new Error('Invalid band edges: must satisfy 0 < f1 < f2 < fs/2');\r\n      }\r\n    } else {\r\n      throw new Error(`Unsupported filter kind: ${kind}`);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Builds filter from normalized prototype poles\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {C[]} polesNorm - Normalized poles\r\n   * @param {number} normalizeAt - Normalization point (1 for LP, -1 for HP)\r\n   * @param {number} wc - Prewarped cutoff frequency\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static fromPrototype(kind, fs, polesNorm, normalizeAt, wc) {\r\n    /** @type {Biquad[]} */\r\n    const sections = [];\r\n\r\n    const pairs = Util.pairConjugates(polesNorm);\r\n    for (const pair of pairs) {\r\n      const [p1, p2] = pair.length === 2 ? pair : [pair[0], null];\r\n\r\n      // LP (Ωp=1) quadratic\r\n      let a2_lp, a1_lp, a0_lp;\r\n      if (p2) {\r\n        a2_lp = 1;\r\n        a1_lp = -2 * p1.re;\r\n        a0_lp = p1.re * p1.re + p1.im * p1.im;\r\n      } else {\r\n        a2_lp = 0; a1_lp = 1; a0_lp = -p1.re;\r\n      }\r\n\r\n      // Transform to analog LP/HP at Ωc = wc\r\n      let A2, A1, A0; // denom\r\n      let b2, b1, b0; // numer\r\n\r\n      if (kind === 'lowpass') {\r\n        A2 = a2_lp;\r\n        A1 = a1_lp * wc;\r\n        A0 = a0_lp * wc * wc;\r\n        b2 = 0; b1 = 0; b0 = 1;              // constant numerator (LP)\r\n      } else if (kind === 'highpass') {\r\n        // s → Ωc/s\r\n        if (a2_lp !== 0) {\r\n          // second-order: a0 s^2 + a1 Ωc s + a2 Ωc^2\r\n          A2 = a0_lp;\r\n          A1 = a1_lp * wc;\r\n          A0 = a2_lp * wc * wc;\r\n          b2 = 1; b1 = 0; b0 = 0;            // s^2 ⇒ double zero at DC\r\n        } else {\r\n          // first-order: a0 s + a1 Ωc\r\n          A2 = 0;\r\n          A1 = a0_lp;\r\n          A0 = a1_lp * wc;\r\n          b2 = 0; b1 = 1; b0 = 0;            // s ⇒ single zero at DC\r\n        }\r\n      } else {\r\n        throw new Error('fromPrototype supports only lowpass/highpass');\r\n      }\r\n\r\n      sections.push(Util.bilinearMapBiquad(b2, b1, b0, A2, A1, A0, fs));\r\n    }\r\n\r\n    // Compose polynomials, then digital normalization at z0.\r\n    let bPoly = [1], aPoly = [1];\r\n    for (const s of sections) { \r\n      bPoly = Util.polymul(bPoly, s.b); \r\n      aPoly = Util.polymul(aPoly, s.a); \r\n    }\r\n\r\n    const g = 1 / Util.evalHzAtZ(bPoly, aPoly, normalizeAt);\r\n    if (sections.length > 0) {\r\n      // Apply to the LAST section for better conditioning\r\n      const last = sections.length - 1;\r\n      sections[last].b = sections[last].b.map(v => v * g);\r\n    }\r\n\r\n    // Recompute polynomials after gain distribution\r\n    bPoly = [1]; aPoly = [1];\r\n    for (const s of sections) { \r\n      bPoly = Util.polymul(bPoly, s.b); \r\n      aPoly = Util.polymul(aPoly, s.a); \r\n    }\r\n\r\n    return { b: bPoly, a: aPoly, sections };\r\n  }\r\n\r\n  /**\r\n   * Abstract method for pole calculation - must be implemented by subclasses\r\n   * @param {number} order - Filter order\r\n   * @param {...any} params - Additional parameters\r\n   * @returns {C[]} Array of complex poles\r\n   * @abstract\r\n   */\r\n  static calculatePoles(order, ...params) {\r\n    throw new Error('calculatePoles must be implemented by subclass');\r\n  }\r\n\r\n  /**\r\n   * Abstract method for filter design - must be implemented by subclasses\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {...any} params - Additional parameters\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   * @abstract\r\n   */\r\n  static design(kind, cutoffHz, fs, order, ...params) {\r\n    throw new Error('design must be implemented by subclass');\r\n  }\r\n}\r\n","// butterworth-filter.js — Butterworth filter design implementation\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { FIRDesigner } from './fir.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FilterKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad\r\n * @typedef {{b: number[], a: number[], sections: Biquad[]}} FilterResult\r\n */\r\n\r\n/**\r\n * Butterworth filter design class\r\n * Provides a clean, focused interface for Butterworth filter generation\r\n */\r\nexport class ButterworthFilter extends BaseIIRFilter {\r\n\r\n  /**\r\n   * Calculates normalized Butterworth poles for given order\r\n   * @param {number} order - Filter order\r\n   * @returns {C[]} Array of complex poles in left half plane\r\n   */\r\n  static calculatePoles(order) {\r\n    const poles = [];\r\n    for (let k = 0; k < order; k++) {\r\n      const theta = Math.PI * (2 * k + 1 + order) / (2 * order);\r\n      const p = C.of(Math.cos(theta), Math.sin(theta));\r\n      if (p.re < 0) poles.push(p);\r\n    }\r\n    return poles;\r\n  }\r\n\r\n\r\n  /**\r\n   * Designs a lowpass or highpass Butterworth filter\r\n   * @param {FilterKind} kind - 'lowpass' or 'highpass'\r\n   * @param {number} cutoffHz - Cutoff frequency\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designLowHighPass(kind, cutoffHz, fs, order) {\r\n    const fc = /** @type {number} */ (cutoffHz);\r\n    const wc = Util.prewarp(fc, fs);\r\n    const polesNorm = ButterworthFilter.calculatePoles(order);\r\n    const zNorm = (kind === 'lowpass') ? 1 : -1;\r\n    \r\n    return BaseIIRFilter.fromPrototype(kind, fs, polesNorm, zNorm, wc);\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass Butterworth filter using lowpass + highpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandPass(cutoffHz, fs, order) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design highpass filter at f1\r\n    const hpFilter = ButterworthFilter.designLowHighPass('highpass', f1, fs, order);\r\n    \r\n    // Design lowpass filter at f2\r\n    const lpFilter = ButterworthFilter.designLowHighPass('lowpass', f2, fs, order);\r\n    \r\n    // Combine filters by cascading (multiplying transfer functions)\r\n    const combinedB = Util.polymul(hpFilter.b, lpFilter.b);\r\n    const combinedA = Util.polymul(hpFilter.a, lpFilter.a);\r\n    const combinedSections = hpFilter.sections.concat(lpFilter.sections);\r\n    \r\n    return { b: combinedB, a: combinedA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandstop Butterworth filter using parallel lowpass + highpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandStop(cutoffHz, fs, order) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design lowpass filter at f1\r\n    const lpFilter = ButterworthFilter.designLowHighPass('lowpass', f1, fs, order);\r\n    \r\n    // Design highpass filter at f2\r\n    const hpFilter = ButterworthFilter.designLowHighPass('highpass', f2, fs, order);\r\n    \r\n    // For bandstop: H_bandstop(s) = H_lp(s) + H_hp(s)\r\n    // This requires parallel combination (addition) of transfer functions\r\n    // Convert to common denominator and add numerators\r\n    const commonA = Util.polymul(lpFilter.a, hpFilter.a);\r\n    const lpNum = Util.polymul(lpFilter.b, hpFilter.a);\r\n    const hpNum = Util.polymul(hpFilter.b, lpFilter.a);\r\n    const combinedB = Util.polyadd(lpNum, hpNum);\r\n    \r\n    // Combine sections by creating a parallel structure\r\n    const combinedSections = [\r\n      ...lpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() })),\r\n      ...hpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() }))\r\n    ];\r\n    \r\n    return { b: combinedB, a: commonA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass or bandstop Butterworth filter using IIR combinations\r\n   * @param {FilterKind} kind - 'bandpass' or 'bandstop'\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandPassStop(kind, cutoffHz, fs, order) {\r\n    if (kind === 'bandpass') {\r\n      return ButterworthFilter.designBandPass(cutoffHz, fs, order);\r\n    } else if (kind === 'bandstop') {\r\n      return ButterworthFilter.designBandStop(cutoffHz, fs, order);\r\n    }\r\n    throw new Error('Unsupported filter kind for band design');\r\n  }\r\n\r\n\r\n  /**\r\n   * Main design method for Butterworth filters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static design(kind, cutoffHz, fs, order) {\r\n    // Validate parameters using base class method\r\n    ButterworthFilter.validateCommonParameters(kind, cutoffHz, fs, order);\r\n\r\n    // Enforce maximum order limit for IIR filters\r\n    if (order > 12) {\r\n      throw new Error(`Butterworth filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n    }\r\n\r\n    // Route to appropriate design method\r\n    if (kind === 'lowpass' || kind === 'highpass') {\r\n      return ButterworthFilter.designLowHighPass(kind, cutoffHz, fs, order);\r\n    } else if (kind === 'bandpass' || kind === 'bandstop') {\r\n      return ButterworthFilter.designBandPassStop(kind, cutoffHz, fs, order);\r\n    }\r\n\r\n    throw new Error('Unsupported filter kind');\r\n  }\r\n}\r\n","// chebyshev-filter.js — Chebyshev Type 1 filter design implementation\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { FIRDesigner } from './fir.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FilterKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad\r\n * @typedef {{b: number[], a: number[], sections: Biquad[]}} FilterResult\r\n */\r\n\r\n/**\r\n * Chebyshev Type 1 filter design class\r\n * Provides a clean, focused interface for Chebyshev Type 1 filter generation\r\n */\r\nexport class ChebyshevFilter extends BaseIIRFilter {\r\n  /**\r\n   * Validates Chebyshev Type 1 filter parameters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @throws {Error} If parameters are invalid\r\n   */\r\n  static validateParameters(kind, cutoffHz, fs, order, ripple) {\r\n    // Use base class validation first\r\n    ChebyshevFilter.validateCommonParameters(kind, cutoffHz, fs, order);\r\n    \r\n    // Additional Chebyshev-specific validation\r\n    if (ripple <= 0) {\r\n      throw new Error('Passband ripple must be positive');\r\n    }\r\n    \r\n    if (ripple > 10) {\r\n      throw new Error('Passband ripple should be <= 10 dB for practical designs');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates normalized Chebyshev Type 1 poles for given order and ripple\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @returns {C[]} Array of complex poles in left half plane\r\n   */\r\n  static calculatePoles(order, ripple) {\r\n    const eps = Math.sqrt(Math.pow(10, ripple / 10) - 1);\r\n    const alpha = Math.asinh(1 / eps) / order;\r\n    const sinhA = Math.sinh(alpha);\r\n    const coshA = Math.cosh(alpha);\r\n    \r\n    const poles = [];\r\n    for (let k = 0; k < order; k++) {\r\n      const theta = Math.PI * (2 * k + 1) / (2 * order);\r\n      const re = -sinhA * Math.sin(theta);\r\n      const im = coshA * Math.cos(theta);\r\n      const p = C.of(re, im);\r\n      if (p.re < 0) poles.push(p);\r\n    }\r\n    return poles;\r\n  }\r\n\r\n  /**\r\n   * Designs a lowpass or highpass Chebyshev Type 1 filter\r\n   * @param {FilterKind} kind - 'lowpass' or 'highpass'\r\n   * @param {number} cutoffHz - Cutoff frequency\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designLowHighPass(kind, cutoffHz, fs, order, ripple) {\r\n    const fc = /** @type {number} */ (cutoffHz);\r\n    const wc = Util.prewarp(fc, fs);\r\n    const polesNorm = ChebyshevFilter.calculatePoles(order, ripple);\r\n    const zNorm = (kind === 'lowpass') ? 1 : -1;\r\n    \r\n    return BaseIIRFilter.fromPrototype(kind, fs, polesNorm, zNorm, wc);\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass Chebyshev Type 1 filter using lowpass + highpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandPass(cutoffHz, fs, order, ripple) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design highpass filter at f1\r\n    const hpFilter = ChebyshevFilter.designLowHighPass('highpass', f1, fs, order, ripple);\r\n    \r\n    // Design lowpass filter at f2\r\n    const lpFilter = ChebyshevFilter.designLowHighPass('lowpass', f2, fs, order, ripple);\r\n    \r\n    // Combine filters by cascading (multiplying transfer functions)\r\n    const combinedB = Util.polymul(hpFilter.b, lpFilter.b);\r\n    const combinedA = Util.polymul(hpFilter.a, lpFilter.a);\r\n    const combinedSections = hpFilter.sections.concat(lpFilter.sections);\r\n    \r\n    return { b: combinedB, a: combinedA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandstop Chebyshev Type 1 filter using parallel lowpass + highpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandStop(cutoffHz, fs, order, ripple) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design lowpass filter at f1\r\n    const lpFilter = ChebyshevFilter.designLowHighPass('lowpass', f1, fs, order, ripple);\r\n    \r\n    // Design highpass filter at f2\r\n    const hpFilter = ChebyshevFilter.designLowHighPass('highpass', f2, fs, order, ripple);\r\n    \r\n    // For bandstop: H_bandstop(s) = H_lp(s) + H_hp(s)\r\n    // This requires parallel combination (addition) of transfer functions\r\n    // Convert to common denominator and add numerators\r\n    const commonA = Util.polymul(lpFilter.a, hpFilter.a);\r\n    const lpNum = Util.polymul(lpFilter.b, hpFilter.a);\r\n    const hpNum = Util.polymul(hpFilter.b, lpFilter.a);\r\n    const combinedB = Util.polyadd(lpNum, hpNum);\r\n    \r\n    // Combine sections by creating a parallel structure\r\n    const combinedSections = [\r\n      ...lpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() })),\r\n      ...hpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() }))\r\n    ];\r\n    \r\n    return { b: combinedB, a: commonA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass or bandstop Chebyshev Type 1 filter using IIR combinations\r\n   * @param {FilterKind} kind - 'bandpass' or 'bandstop'\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandPassStop(kind, cutoffHz, fs, order, ripple) {\r\n    if (kind === 'bandpass') {\r\n      return ChebyshevFilter.designBandPass(cutoffHz, fs, order, ripple);\r\n    } else if (kind === 'bandstop') {\r\n      return ChebyshevFilter.designBandStop(cutoffHz, fs, order, ripple);\r\n    }\r\n    throw new Error('Unsupported filter kind for band design');\r\n  }\r\n\r\n  /**\r\n   * Main design method for Chebyshev Type 1 filters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} ripple - Passband ripple in dB (default: 1)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static design(kind, cutoffHz, fs, order, ripple = 1) {\r\n    // Validate parameters using Chebyshev-specific validation\r\n    ChebyshevFilter.validateParameters(kind, cutoffHz, fs, order, ripple);\r\n\r\n    // Enforce maximum order limit for IIR filters\r\n    if (order > 12) {\r\n      throw new Error(`Chebyshev filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n    }\r\n\r\n    // Route to appropriate design method\r\n    if (kind === 'lowpass' || kind === 'highpass') {\r\n      return ChebyshevFilter.designLowHighPass(kind, cutoffHz, fs, order, ripple);\r\n    } else if (kind === 'bandpass' || kind === 'bandstop') {\r\n      return ChebyshevFilter.designBandPassStop(kind, cutoffHz, fs, order, ripple);\r\n    }\r\n\r\n    throw new Error('Unsupported filter kind');\r\n  }\r\n\r\n}\r\n","// chebyshev-type2-filter.js — Chebyshev Type 2 (inverse Chebyshev) filter design implementation\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FilterKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad\r\n * @typedef {{b: number[], a: number[], sections: Biquad[]}} FilterResult\r\n */\r\n\r\n/**\r\n * Chebyshev Type 2 (inverse Chebyshev) filter design class\r\n * Provides a clean, focused interface for Chebyshev Type 2 filter generation\r\n */\r\nexport class ChebyshevType2Filter extends BaseIIRFilter {\r\n  /**\r\n   * Validates Chebyshev Type 2 filter parameters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n   * @throws {Error} If parameters are invalid\r\n   */\r\n  static validateParameters(kind, cutoffHz, fs, order, stopbandAttenuation) {\r\n    // Use base class validation first (this exists in your base file)\r\n    ChebyshevType2Filter.validateCommonParameters(kind, cutoffHz, fs, order);\r\n\r\n    // Additional Chebyshev Type 2-specific validation\r\n    if (!(stopbandAttenuation > 0)) {\r\n      throw new Error('Stopband attenuation must be positive');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates normalized inverse-Chebyshev (Type-II) prototype poles and zeros (Ωc=1)\r\n   * Zeros lie on jΩ axis at Ωz = ±sec(theta_k), producing equiripple stopband.\r\n   * @param {number} order\r\n   * @param {number} rs Stopband attenuation in dB\r\n   * @returns {{poles: {re:number,im:number}[], zerosW: number[]}} zerosW are positive Ωz values (we'll add ± pairs)\r\n   */\r\n  static calculatePolesAndZeros(order, rs) {\r\n    // eps2 = 1/(10^(rs/10) - 1); using parameterization with a = asinh(1/sqrt(eps2))/n\r\n    const eps2 = 1 / (Math.pow(10, rs / 10) - 1);\r\n    const a = Math.asinh(1 / Math.sqrt(eps2)) / order;\r\n\r\n    const poles = [];\r\n    for (let k = 1; k <= order; k++) {\r\n      const theta = Math.PI * (2 * k - 1) / (2 * order);\r\n      const re = -Math.sinh(a) * Math.sin(theta);\r\n      const im =  Math.cosh(a) * Math.cos(theta);\r\n      poles.push(C.of(re, im));\r\n    }\r\n\r\n    // Positive-frequency zero magnitudes (we'll create ±jΩ for each)\r\n    const zerosW = [];\r\n    const m = Math.floor(order / 2);\r\n    for (let k = 1; k <= m; k++) {\r\n      const theta = Math.PI * (2 * k - 1) / (2 * order);\r\n      zerosW.push(1 / Math.cos(theta)); // sec(theta)\r\n    }\r\n\r\n    return { poles, zerosW };\r\n  }\r\n\r\n  /**\r\n   * Build LP analog biquad from a conjugate pole pair and an optional zero pair (at ±jΩz).\r\n   * The section is then frequency-scaled by Ωc (= wc) and bilinear-mapped to digital.\r\n   * @param {'lowpass'|'highpass'} kind\r\n   * @param {{re:number, im:number}[]} polePair length 1 or 2 (conjugate pair)\r\n   * @param {number|null} zeroW positive Ωz for zero pair, or null if no finite zeros in this section\r\n   * @param {number} wc prewarped edge (Ωc)\r\n   * @param {number} fs sampling rate (Hz)\r\n   * @returns {Biquad} digital biquad (b,a) with a0=1\r\n   */\r\n  static mapSectionLP_HP(kind, polePair, zeroW, wc, fs) {\r\n    // Denominator LP prototype (normalized at Ωc=1):\r\n    let a2_lp, a1_lp, a0_lp;\r\n    if (polePair.length === 2) {\r\n      const p = polePair[0]; // conjugate partner implied\r\n      a2_lp = 1;\r\n      a1_lp = -2 * p.re;\r\n      a0_lp = p.re * p.re + p.im * p.im;\r\n    } else {\r\n      // First-order leftover when order is odd\r\n      const p = polePair[0];\r\n      a2_lp = 0; a1_lp = 1; a0_lp = -p.re;\r\n    }\r\n\r\n    // Numerator LP prototype: either unity (no finite zeros) or s^2 + Ωz^2\r\n    let b2_lp, b1_lp, b0_lp;\r\n    if (zeroW != null) {\r\n      b2_lp = 1; b1_lp = 0; b0_lp = zeroW * zeroW;\r\n    } else {\r\n      // No finite zeros for this section (odd-order leftover)\r\n      b2_lp = 0; b1_lp = 0; b0_lp = 1;\r\n    }\r\n\r\n    // Frequency scaling to desired Ωc = wc and LP/HP analog mapping (mirror BaseIIRFilter logic)\r\n    let A2, A1, A0, B2, B1, B0;\r\n\r\n    if (kind === 'lowpass') {\r\n      // LP: multiply s by wc in first-order coefficients\r\n      A2 = a2_lp;        A1 = a1_lp * wc;        A0 = a0_lp * wc * wc;\r\n      B2 = b2_lp;        B1 = b1_lp * wc;        B0 = b0_lp * wc * wc;\r\n    } else {\r\n      // HP: s -> wc/s\r\n      if (a2_lp !== 0) {\r\n        // second-order denominator\r\n        A2 = a0_lp;      A1 = a1_lp * wc;        A0 = a2_lp * wc * wc;\r\n      } else {\r\n        // first-order denominator\r\n        A2 = 0;          A1 = a0_lp;             A0 = a1_lp * wc;\r\n      }\r\n\r\n      // numerator mapping under s -> wc/s:\r\n      if (b2_lp !== 0) {\r\n        // b(s) = s^2 + (Ωz)^2 -> B(s) = (wc^2) + (Ωz^2) s^2   (after clearing 1/s^2)\r\n        B2 = b0_lp;      B1 = b1_lp * wc;        B0 = b2_lp * wc * wc;\r\n      } else if (b1_lp !== 0) {\r\n        // (not used here) single zero → maps to s term after transform\r\n        B2 = 0;          B1 = b0_lp;             B0 = b1_lp * wc;\r\n      } else {\r\n        // Constant numerator -> becomes s^2 term after clearing (zero at DC of order 2)\r\n        B2 = b0_lp;      B1 = 0;                 B0 = 0;\r\n      }\r\n    }\r\n\r\n    // Bilinear transform to digital\r\n    return Util.bilinearMapBiquad(B2, B1, B0, A2, A1, A0, fs);\r\n  }\r\n\r\n  /**\r\n   * LP / HP design with proper inverse-Chebyshev zeros\r\n   * @param {'lowpass'|'highpass'} kind\r\n   * @param {number} cutoffHz\r\n   * @param {number} fs\r\n   * @param {number} order\r\n   * @param {number} rs\r\n   * @returns {FilterResult}\r\n   */\r\n  static designLPHP(kind, cutoffHz, fs, order, rs) {\r\n    const wc = Util.prewarp(cutoffHz, fs);\r\n    const { poles, zerosW } = this.calculatePolesAndZeros(order, rs);\r\n\r\n    // Pair poles for SOS\r\n    const polePairs = Util.pairConjugates(poles);\r\n\r\n    // Assign zero pairs to as many sections as available (floor(n/2) of them).\r\n    const sections = [];\r\n    let zi = 0;\r\n    for (const pair of polePairs) {\r\n      const zW = (zi < zerosW.length) ? zerosW[zi++] * wc : null; // scale Ωz by Ωc\r\n      const sec = this.mapSectionLP_HP(kind, pair, zW, wc, fs);\r\n      sections.push(sec);\r\n    }\r\n\r\n    // Compose overall polynomials\r\n    let b = [1], a = [1];\r\n    for (const s of sections) {\r\n      b = Util.polymul(b, s.b);\r\n      a = Util.polymul(a, s.a);\r\n    }\r\n\r\n    // Normalize digital gain\r\n    const zNorm = (kind === 'lowpass') ? 1 : -1; // DC for LP, Nyquist for HP\r\n    const g = 1 / Util.evalHzAtZ(b, a, zNorm);\r\n    // Apply gain to the last section for numerical conditioning\r\n    if (sections.length) {\r\n      const L = sections.length - 1;\r\n      sections[L] = { b: sections[L].b.map(v => v * g), a: sections[L].a.slice() };\r\n      // Recompose b with gain\r\n      b = [1]; a = [1];\r\n      for (const s of sections) {\r\n        b = Util.polymul(b, s.b);\r\n        a = Util.polymul(a, s.a);\r\n      }\r\n    }\r\n\r\n    return { b, a, sections };\r\n  }\r\n\r\n  /**\r\n   * Designs a lowpass Chebyshev Type 2 filter\r\n   */\r\n  static designLowPass(cutoffHz, fs, order, stopbandAttenuation) {\r\n    return this.designLPHP('lowpass', cutoffHz, fs, order, stopbandAttenuation);\r\n  }\r\n\r\n  /**\r\n   * Designs a highpass Chebyshev Type 2 filter\r\n   */\r\n  static designHighPass(cutoffHz, fs, order, stopbandAttenuation) {\r\n    return this.designLPHP('highpass', cutoffHz, fs, order, stopbandAttenuation);\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass Chebyshev Type 2 filter (built from HP@f1 and LP@f2 cascaded)\r\n   * NOTE: This is a practical IIR approach; full LP→BP analog transform can be added if desired.\r\n   */\r\n  static designBandPass(cutoffHz, fs, order, stopbandAttenuation) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    const hp = this.designHighPass(f1, fs, order, stopbandAttenuation);\r\n    const lp = this.designLowPass(f2, fs, order, stopbandAttenuation);\r\n    return {\r\n      b: Util.polymul(hp.b, lp.b),\r\n      a: Util.polymul(hp.a, lp.a),\r\n      sections: [...hp.sections, ...lp.sections]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandstop Chebyshev Type 2 filter (parallel sum of LP@f1 and HP@f2)\r\n   */\r\n  static designBandStop(cutoffHz, fs, order, stopbandAttenuation) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    const lp = this.designLowPass(f1, fs, order, stopbandAttenuation);\r\n    const hp = this.designHighPass(f2, fs, order, stopbandAttenuation);\r\n\r\n    const a = Util.polymul(lp.a, hp.a);\r\n    const b_lp = Util.polymul(lp.b, hp.a);\r\n    const b_hp = Util.polymul(hp.b, lp.a);\r\n    const b = Util.polyadd(b_lp, b_hp);\r\n\r\n    return { b, a, sections: [...lp.sections, ...hp.sections] };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass or bandstop Chebyshev Type 2 filter\r\n   */\r\n  static designBandPassStop(kind, cutoffHz, fs, order, stopbandAttenuation) {\r\n    if (kind === 'bandpass') return this.designBandPass(cutoffHz, fs, order, stopbandAttenuation);\r\n    if (kind === 'bandstop') return this.designBandStop(cutoffHz, fs, order, stopbandAttenuation);\r\n    throw new Error('Unsupported filter kind for band design');\r\n  }\r\n\r\n  /**\r\n   * Main design entry\r\n   */\r\n  static design(kind, cutoffHz, fs, order, stopbandAttenuation = 40) {\r\n    this.validateParameters(kind, cutoffHz, fs, order, stopbandAttenuation);\r\n    \r\n    // Enforce maximum order limit for IIR filters\r\n    if (order > 12) {\r\n      throw new Error(`Chebyshev Type 2 filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n    }\r\n    \r\n    if (kind === 'lowpass')  return this.designLowPass(cutoffHz, fs, order, stopbandAttenuation);\r\n    if (kind === 'highpass') return this.designHighPass(cutoffHz, fs, order, stopbandAttenuation);\r\n    if (kind === 'bandpass' || kind === 'bandstop')\r\n      return this.designBandPassStop(kind, cutoffHz, fs, order, stopbandAttenuation);\r\n    throw new Error('Unsupported filter kind');\r\n  }\r\n}\r\n","// linkwitz-riley-filter.js — Linkwitz-Riley filter design implementation\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { ButterworthFilter } from './butterworth-filter.js';\r\nimport { FIRDesigner } from './fir.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FilterKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad\r\n * @typedef {{b: number[], a: number[], sections: Biquad[]}} FilterResult\r\n */\r\n\r\n/**\r\n * Linkwitz-Riley filter design class\r\n * Provides a clean, focused interface for Linkwitz-Riley filter generation\r\n * Linkwitz-Riley filters are cascades of two same-order Butterworth filters\r\n */\r\nexport class LinkwitzRileyFilter extends BaseIIRFilter {\r\n  /**\r\n   * Validates Linkwitz-Riley filter parameters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (will be adjusted to even if odd)\r\n   * @throws {Error} If parameters are invalid\r\n   */\r\n  static validateParameters(kind, cutoffHz, fs, order) {\r\n    // Use base class validation first\r\n    LinkwitzRileyFilter.validateCommonParameters(kind, cutoffHz, fs, order);\r\n    \r\n    // Additional Linkwitz-Riley-specific validation\r\n    if (order < 2) {\r\n      throw new Error('Order must be >= 2 for Linkwitz-Riley filters');\r\n    }\r\n    \r\n    // Note: We don't throw an error for odd orders, we just adjust them\r\n  }\r\n\r\n  /**\r\n   * Designs a Linkwitz-Riley filter by cascading two Butterworth filters\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (must be even)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static design(kind, cutoffHz, fs, order) {\r\n    // Validate parameters\r\n    LinkwitzRileyFilter.validateParameters(kind, cutoffHz, fs, order);\r\n    \r\n    // Enforce maximum order limit for IIR filters\r\n    if (order > 12) {\r\n      throw new Error(`Linkwitz-Riley filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n    }\r\n    \r\n    // Ensure order is even\r\n    const evenOrder = (order % 2 === 0) ? order : (order + 1);\r\n    const halfOrder = evenOrder / 2;\r\n    \r\n    // Design the base Butterworth filter\r\n    const baseFilter = ButterworthFilter.design(kind, cutoffHz, fs, halfOrder);\r\n    \r\n    // Cascade two identical Butterworth filters\r\n    const cascadedSections = baseFilter.sections.concat(\r\n      baseFilter.sections.map(s => ({ \r\n        b: s.b.slice(), \r\n        a: s.a.slice() \r\n      }))\r\n    );\r\n    \r\n    // Multiply the transfer functions\r\n    const cascadedB = Util.polymul(baseFilter.b, baseFilter.b);\r\n    const cascadedA = Util.polymul(baseFilter.a, baseFilter.a);\r\n    \r\n    return { \r\n      b: cascadedB, \r\n      a: cascadedA, \r\n      sections: cascadedSections \r\n    };\r\n  }\r\n\r\n  /**\r\n   * Designs a lowpass Linkwitz-Riley filter\r\n   * @param {number} cutoffHz - Cutoff frequency\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (must be even)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designLowPass(cutoffHz, fs, order) {\r\n    return LinkwitzRileyFilter.design('lowpass', cutoffHz, fs, order);\r\n  }\r\n\r\n  /**\r\n   * Designs a highpass Linkwitz-Riley filter\r\n   * @param {number} cutoffHz - Cutoff frequency\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (must be even)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designHighPass(cutoffHz, fs, order) {\r\n    return LinkwitzRileyFilter.design('highpass', cutoffHz, fs, order);\r\n  }\r\n\r\n  /**\r\n   * Designs a bandpass Linkwitz-Riley filter using lowpass + highpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (must be even)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandPass(cutoffHz, fs, order) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design highpass Linkwitz-Riley filter at f1\r\n    const hpFilter = LinkwitzRileyFilter.design('highpass', f1, fs, order);\r\n    \r\n    // Design lowpass Linkwitz-Riley filter at f2\r\n    const lpFilter = LinkwitzRileyFilter.design('lowpass', f2, fs, order);\r\n    \r\n    // Combine filters by cascading (multiplying transfer functions)\r\n    const combinedB = Util.polymul(hpFilter.b, lpFilter.b);\r\n    const combinedA = Util.polymul(hpFilter.a, lpFilter.a);\r\n    const combinedSections = hpFilter.sections.concat(lpFilter.sections);\r\n    \r\n    return { b: combinedB, a: combinedA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Designs a bandstop Linkwitz-Riley filter using parallel highpass + lowpass combination\r\n   * @param {[number, number]} cutoffHz - Band edges [f1, f2]\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order (must be even)\r\n   * @returns {FilterResult} Filter coefficients and sections\r\n   */\r\n  static designBandStop(cutoffHz, fs, order) {\r\n    const [f1, f2] = /** @type {[number, number]} */ (cutoffHz);\r\n    \r\n    // Design lowpass Linkwitz-Riley filter at f1\r\n    const lpFilter = LinkwitzRileyFilter.design('lowpass', f1, fs, order);\r\n    \r\n    // Design highpass Linkwitz-Riley filter at f2\r\n    const hpFilter = LinkwitzRileyFilter.design('highpass', f2, fs, order);\r\n    \r\n    // For bandstop: H_bandstop(s) = H_lp(s) + H_hp(s)\r\n    // This requires parallel combination (addition) of transfer functions\r\n    // Convert to common denominator and add numerators\r\n    const commonA = Util.polymul(lpFilter.a, hpFilter.a);\r\n    const lpNum = Util.polymul(lpFilter.b, hpFilter.a);\r\n    const hpNum = Util.polymul(hpFilter.b, lpFilter.a);\r\n    const combinedB = Util.polyadd(lpNum, hpNum);\r\n    \r\n    // Combine sections by creating a parallel structure\r\n    const combinedSections = [\r\n      ...lpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() })),\r\n      ...hpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() }))\r\n    ];\r\n    \r\n    return { b: combinedB, a: commonA, sections: combinedSections };\r\n  }\r\n\r\n  /**\r\n   * Calculates the actual order of the Linkwitz-Riley filter\r\n   * @param {number} requestedOrder - Requested filter order\r\n   * @returns {number} Actual filter order (always even)\r\n   */\r\n  static getActualOrder(requestedOrder) {\r\n    return (requestedOrder % 2 === 0) ? requestedOrder : (requestedOrder + 1);\r\n  }\r\n\r\n  /**\r\n   * Gets the half-order used for the base Butterworth filter\r\n   * @param {number} order - Filter order\r\n   * @returns {number} Half order for base Butterworth filter\r\n   */\r\n  static getHalfOrder(order) {\r\n    return LinkwitzRileyFilter.getActualOrder(order) / 2;\r\n  }\r\n\r\n  /**\r\n   * Calculates the total number of sections in the Linkwitz-Riley filter\r\n   * @param {number} order - Filter order\r\n   * @returns {number} Total number of sections\r\n   */\r\n  static getNumberOfSections(order) {\r\n    const halfOrder = LinkwitzRileyFilter.getHalfOrder(order);\r\n    return halfOrder * 2; // Two cascaded Butterworth filters\r\n  }\r\n\r\n  /**\r\n   * Gets recommended orders for different applications\r\n   * @returns {Object} Object with recommended orders for different use cases\r\n   */\r\n  static getRecommendedOrders() {\r\n    return {\r\n      basic: 2,        // 2nd order (1st order Butterworth cascaded twice)\r\n      standard: 4,     // 4th order (2nd order Butterworth cascaded twice)\r\n      high: 6,         // 6th order (3rd order Butterworth cascaded twice)\r\n      premium: 8,      // 8th order (4th order Butterworth cascaded twice)\r\n      professional: 12 // 12th order (6th order Butterworth cascaded twice)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates that the order is even and adjusts if necessary\r\n   * @param {number} order - Filter order\r\n   * @returns {number} Adjusted order (always even)\r\n   */\r\n  static adjustOrderToEven(order) {\r\n    if (order < 2) {\r\n      return 2; // Minimum order\r\n    }\r\n    return (order % 2 === 0) ? order : (order + 1);\r\n  }\r\n\r\n  /**\r\n   * Gets information about the Linkwitz-Riley filter design\r\n   * @param {number} order - Filter order\r\n   * @returns {Object} Information about the filter design\r\n   */\r\n  static getFilterInfo(order) {\r\n    const actualOrder = LinkwitzRileyFilter.getActualOrder(order);\r\n    const halfOrder = LinkwitzRileyFilter.getHalfOrder(order);\r\n    const sections = LinkwitzRileyFilter.getNumberOfSections(order);\r\n    \r\n    return {\r\n      requestedOrder: order,\r\n      actualOrder: actualOrder,\r\n      halfOrder: halfOrder,\r\n      sections: sections,\r\n      isAdjusted: order !== actualOrder,\r\n      description: `Linkwitz-Riley ${actualOrder}th order (${halfOrder}th order Butterworth cascaded twice)`\r\n    };\r\n  }\r\n}\r\n","import { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { ComplexNum, C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { FIRDesigner } from './fir.js';\r\n\r\n/**\r\n * Elliptic (Cauer) Filter Designer\r\n * \r\n * Elliptic filters have equiripple behavior in both passband and stopband,\r\n * making them the most efficient in terms of filter order for given specifications.\r\n * \r\n * Key characteristics:\r\n * - Equiripple passband (controlled by passband ripple)\r\n * - Equiripple stopband (controlled by stopband attenuation)\r\n * - Finite zeros in the stopband\r\n * - Minimum filter order for given specifications\r\n */\r\nexport class EllipticFilter extends BaseIIRFilter {\r\n    \r\n    /**\r\n     * Design an elliptic filter (unified interface)\r\n     * @param {string} kind - Filter type ('lowpass', 'highpass', 'bandpass', 'bandstop')\r\n     * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n     * @param {number} fs - Sampling frequency\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static design(kind, cutoffHz, fs, order, passbandRipple = 1, stopbandAttenuation = 40) {\r\n        // Enforce maximum order limit for IIR filters\r\n        if (order > 12) {\r\n            throw new Error(`Elliptic filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n        }\r\n        \r\n        switch (kind) {\r\n            case 'lowpass':\r\n                return this.designLowPass(cutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n            case 'highpass':\r\n                return this.designHighPass(cutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n            case 'bandpass':\r\n                if (Array.isArray(cutoffHz) && cutoffHz.length === 2) {\r\n                    return this.designBandPass(cutoffHz[0], cutoffHz[1], fs, order, passbandRipple, stopbandAttenuation);\r\n                }\r\n                throw new Error('Bandpass requires [lowCutoff, highCutoff] frequencies');\r\n            case 'bandstop':\r\n                if (Array.isArray(cutoffHz) && cutoffHz.length === 2) {\r\n                    return this.designBandStop(cutoffHz[0], cutoffHz[1], fs, order, passbandRipple, stopbandAttenuation);\r\n                }\r\n                throw new Error('Bandstop requires [lowCutoff, highCutoff] frequencies');\r\n            default:\r\n                throw new Error(`Unsupported filter type: ${kind}`);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Design an elliptic lowpass filter\r\n     * @param {number} cutoffHz - Cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designLowPass(cutoffHz, fs, order, passbandRipple, stopbandAttenuation) {\r\n        // True Elliptic IIR filter implementation\r\n        const wc = Util.prewarp(cutoffHz, fs);\r\n        \r\n        // Calculate Elliptic poles and zeros\r\n        const { poles, zeros } = this.calculateEllipticPolesAndZeros(order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // Convert to digital filter using bilinear transform\r\n        return this.fromPrototype('lowpass', fs, poles, 1, wc);\r\n    }\r\n    \r\n    /**\r\n     * Design an elliptic highpass filter\r\n     * @param {number} cutoffHz - Cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designHighPass(cutoffHz, fs, order, passbandRipple, stopbandAttenuation) {\r\n        // True Elliptic IIR filter implementation\r\n        const wc = Util.prewarp(cutoffHz, fs);\r\n        \r\n        // Calculate Elliptic poles and zeros\r\n        const { poles, zeros } = this.calculateEllipticPolesAndZeros(order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // Apply highpass transformation (s -> 1/s)\r\n        const transformedPoles = poles.map(p => C.div(C.of(1, 0), p));\r\n        \r\n        return this.fromPrototype('highpass', fs, transformedPoles, -1, wc);\r\n    }\r\n    \r\n    /**\r\n     * Design an elliptic bandpass filter using lowpass + highpass combination\r\n     * @param {number} lowCutoffHz - Lower cutoff frequency in Hz\r\n     * @param {number} highCutoffHz - Upper cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designBandPass(lowCutoffHz, highCutoffHz, fs, order, passbandRipple, stopbandAttenuation) {\r\n        // Design highpass filter at lowCutoffHz\r\n        const hpFilter = this.designHighPass(lowCutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // Design lowpass filter at highCutoffHz\r\n        const lpFilter = this.designLowPass(highCutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // Combine filters by cascading (multiplying transfer functions)\r\n        const combinedB = Util.polymul(hpFilter.b, lpFilter.b);\r\n        const combinedA = Util.polymul(hpFilter.a, lpFilter.a);\r\n        const combinedSections = hpFilter.sections.concat(lpFilter.sections);\r\n        \r\n        return { b: combinedB, a: combinedA, sections: combinedSections };\r\n    }\r\n    \r\n    /**\r\n     * Design an elliptic bandstop filter using parallel highpass + lowpass combination\r\n     * @param {number} lowCutoffHz - Lower cutoff frequency in Hz\r\n     * @param {number} highCutoffHz - Upper cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designBandStop(lowCutoffHz, highCutoffHz, fs, order, passbandRipple, stopbandAttenuation) {\r\n        // Design lowpass filter at lowCutoffHz\r\n        const lpFilter = this.designLowPass(lowCutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // Design highpass filter at highCutoffHz\r\n        const hpFilter = this.designHighPass(highCutoffHz, fs, order, passbandRipple, stopbandAttenuation);\r\n        \r\n        // For bandstop: H_bandstop(s) = H_lp(s) + H_hp(s)\r\n        // This requires parallel combination (addition) of transfer functions\r\n        // Convert to common denominator and add numerators\r\n        const commonA = Util.polymul(lpFilter.a, hpFilter.a);\r\n        const lpNum = Util.polymul(lpFilter.b, hpFilter.a);\r\n        const hpNum = Util.polymul(hpFilter.b, lpFilter.a);\r\n        const combinedB = Util.polyadd(lpNum, hpNum);\r\n        \r\n        // Combine sections by creating a parallel structure\r\n        const combinedSections = [\r\n            ...lpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() })),\r\n            ...hpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() }))\r\n        ];\r\n        \r\n        return { b: combinedB, a: commonA, sections: combinedSections };\r\n    }\r\n    \r\n    /**\r\n     * Calculate elliptic filter poles and zeros\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {Object} {poles, zeros}\r\n     */\r\n    static calculateEllipticPolesAndZeros(order, passbandRipple, stopbandAttenuation) {\r\n        // Convert dB to linear values\r\n        const epsilon = Math.sqrt(Math.pow(10, passbandRipple / 10) - 1);\r\n        const A = Math.pow(10, stopbandAttenuation / 20);\r\n        \r\n        // Calculate selectivity factor\r\n        const k1 = epsilon / Math.sqrt(A * A - 1);\r\n        \r\n        // Calculate modular constant\r\n        const k = this.calculateModularConstant(k1, order);\r\n        \r\n        // Calculate complete elliptic integral\r\n        const K = this.completeEllipticIntegral(k);\r\n        const Kprime = this.completeEllipticIntegral(Math.sqrt(1 - k * k));\r\n        \r\n        // Calculate poles and zeros\r\n        const poles = [];\r\n        const zeros = [];\r\n        \r\n        for (let i = 1; i <= Math.floor(order / 2); i++) {\r\n            const u = (2 * i - 1) * K / order;\r\n            const sn = this.jacobiSn(u, k);\r\n            const cn = this.jacobiCn(u, k);\r\n            const dn = this.jacobiDn(u, k);\r\n            \r\n            // Calculate pole location\r\n            const real = -sn * cn / (1 - sn * sn);\r\n            const imag = dn / (1 - sn * sn);\r\n            poles.push(C.of(real, imag));\r\n            poles.push(C.of(real, -imag)); // Conjugate\r\n            \r\n            // Calculate zero location\r\n            const zeroReal = 1 / (k * sn);\r\n            const zeroImag = 0;\r\n            zeros.push(C.of(zeroReal, zeroImag));\r\n            zeros.push(C.of(zeroReal, -zeroImag)); // Conjugate\r\n        }\r\n        \r\n        // Add real pole/zero for odd orders\r\n        if (order % 2 === 1) {\r\n            const u = K / order;\r\n            const sn = this.jacobiSn(u, k);\r\n            poles.push(C.of(-sn, 0));\r\n            zeros.push(C.of(1 / (k * sn), 0));\r\n        }\r\n        \r\n        return { poles, zeros };\r\n    }\r\n    \r\n    /**\r\n     * Calculate the modular constant k\r\n     * @param {number} k1 - Selectivity factor\r\n     * @param {number} order - Filter order\r\n     * @returns {number} Modular constant\r\n     */\r\n    static calculateModularConstant(k1, order) {\r\n        // This is a simplified calculation\r\n        // In practice, this requires solving a complex equation\r\n        const q = Math.exp(-Math.PI * this.completeEllipticIntegral(Math.sqrt(1 - k1 * k1)) / this.completeEllipticIntegral(k1));\r\n        let k = Math.sqrt(q);\r\n        \r\n        // Refine using Newton's method\r\n        for (let i = 0; i < 10; i++) {\r\n            const K = this.completeEllipticIntegral(k);\r\n            const Kprime = this.completeEllipticIntegral(Math.sqrt(1 - k * k));\r\n            const f = K / Kprime - order * Math.log(q) / Math.PI;\r\n            const df = this.ellipticIntegralDerivative(k);\r\n            k = k - f / df;\r\n        }\r\n        \r\n        return k;\r\n    }\r\n    \r\n    /**\r\n     * Complete elliptic integral of the first kind\r\n     * @param {number} k - Modulus\r\n     * @returns {number} Complete elliptic integral\r\n     */\r\n    static completeEllipticIntegral(k) {\r\n        if (k === 0) return Math.PI / 2;\r\n        if (k === 1) return Infinity;\r\n        \r\n        // Use series expansion for accuracy\r\n        let sum = 1;\r\n        let term = 1;\r\n        const k2 = k * k;\r\n        \r\n        for (let n = 1; n < 100; n++) {\r\n            term *= (2 * n - 1) * (2 * n - 1) * k2 / (2 * n * 2 * n);\r\n            sum += term;\r\n            if (Math.abs(term) < 1e-15) break;\r\n        }\r\n        \r\n        return Math.PI / 2 * sum;\r\n    }\r\n    \r\n    /**\r\n     * Jacobi elliptic function sn(u,k)\r\n     * @param {number} u - Argument\r\n     * @param {number} k - Modulus\r\n     * @returns {number} sn(u,k)\r\n     */\r\n    static jacobiSn(u, k) {\r\n        // Simplified implementation using series expansion\r\n        const k2 = k * k;\r\n        let sum = 0;\r\n        let term = 1;\r\n        \r\n        for (let n = 0; n < 50; n++) {\r\n            sum += term * Math.sin((2 * n + 1) * u);\r\n            term *= k2;\r\n            if (Math.abs(term) < 1e-15) break;\r\n        }\r\n        \r\n        return sum;\r\n    }\r\n    \r\n    /**\r\n     * Jacobi elliptic function cn(u,k)\r\n     * @param {number} u - Argument\r\n     * @param {number} k - Modulus\r\n     * @returns {number} cn(u,k)\r\n     */\r\n    static jacobiCn(u, k) {\r\n        const sn = this.jacobiSn(u, k);\r\n        return Math.sqrt(1 - sn * sn);\r\n    }\r\n    \r\n    /**\r\n     * Jacobi elliptic function dn(u,k)\r\n     * @param {number} u - Argument\r\n     * @param {number} k - Modulus\r\n     * @returns {number} dn(u,k)\r\n     */\r\n    static jacobiDn(u, k) {\r\n        const sn = this.jacobiSn(u, k);\r\n        const k2 = k * k;\r\n        return Math.sqrt(1 - k2 * sn * sn);\r\n    }\r\n    \r\n    /**\r\n     * Derivative of elliptic integral (for Newton's method)\r\n     * @param {number} k - Modulus\r\n     * @returns {number} Derivative\r\n     */\r\n    static ellipticIntegralDerivative(k) {\r\n        const k2 = k * k;\r\n        const kprime2 = 1 - k2;\r\n        return this.completeEllipticIntegral(k) / (k * kprime2) - this.completeEllipticIntegral(Math.sqrt(kprime2)) / (k * k);\r\n    }\r\n    \r\n    /**\r\n     * Get recommended passband ripples for elliptic filters\r\n     * @returns {Array} Array of recommended ripple values in dB\r\n     */\r\n    static getRecommendedPassbandRipples() {\r\n        return [0.1, 0.2, 0.5, 1.0, 2.0, 3.0, 5.0];\r\n    }\r\n    \r\n    /**\r\n     * Get recommended stopband attenuations for elliptic filters\r\n     * @returns {Array} Array of recommended attenuation values in dB\r\n     */\r\n    static getRecommendedStopbandAttenuations() {\r\n        return [20, 30, 40, 50, 60, 70, 80, 90, 100];\r\n    }\r\n    \r\n    /**\r\n     * Calculate actual passband ripple for given parameters\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Target passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Stopband attenuation in dB\r\n     * @returns {number} Actual passband ripple in dB\r\n     */\r\n    static calculateActualPassbandRipple(order, passbandRipple, stopbandAttenuation) {\r\n        // This is a simplified calculation\r\n        // In practice, this requires solving the elliptic filter equations\r\n        const epsilon = Math.sqrt(Math.pow(10, passbandRipple / 10) - 1);\r\n        const A = Math.pow(10, stopbandAttenuation / 20);\r\n        \r\n        // Simplified relationship\r\n        const actualEpsilon = epsilon * Math.pow(A, -1 / order);\r\n        return 10 * Math.log10(1 + actualEpsilon * actualEpsilon);\r\n    }\r\n    \r\n    /**\r\n     * Calculate actual stopband attenuation for given parameters\r\n     * @param {number} order - Filter order\r\n     * @param {number} passbandRipple - Passband ripple in dB\r\n     * @param {number} stopbandAttenuation - Target stopband attenuation in dB\r\n     * @returns {number} Actual stopband attenuation in dB\r\n     */\r\n    static calculateActualStopbandAttenuation(order, passbandRipple, stopbandAttenuation) {\r\n        // This is a simplified calculation\r\n        // In practice, this requires solving the elliptic filter equations\r\n        const epsilon = Math.sqrt(Math.pow(10, passbandRipple / 10) - 1);\r\n        const A = Math.pow(10, stopbandAttenuation / 20);\r\n        \r\n        // Simplified relationship\r\n        const actualA = A * Math.pow(epsilon, 1 / order);\r\n        return 20 * Math.log10(actualA);\r\n    }\r\n}\r\n","import { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { ComplexNum, C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { FIRDesigner } from './fir.js';\r\n\r\n/**\r\n * Bessel Filter Designer\r\n * \r\n * Bessel filters are characterized by maximally flat group delay (linear phase response)\r\n * in the passband. They are commonly used in applications where phase linearity is critical.\r\n * \r\n * Key characteristics:\r\n * - Maximally flat group delay\r\n * - Linear phase response in passband\r\n * - Gradual rolloff in stopband\r\n * - No ripple in passband or stopband\r\n * - Preserves signal shape (minimal distortion)\r\n */\r\nexport class BesselFilter extends BaseIIRFilter {\r\n    \r\n    /**\r\n     * Design a Bessel filter (unified interface)\r\n     * @param {string} kind - Filter type ('lowpass', 'highpass', 'bandpass', 'bandstop')\r\n     * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n     * @param {number} fs - Sampling frequency\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static design(kind, cutoffHz, fs, order) {\r\n        // Enforce maximum order limit for IIR filters\r\n        if (order > 12) {\r\n            throw new Error(`Bessel filter order ${order} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);\r\n        }\r\n        \r\n        switch (kind) {\r\n            case 'lowpass':\r\n                return this.designLowPass(cutoffHz, fs, order);\r\n            case 'highpass':\r\n                return this.designHighPass(cutoffHz, fs, order);\r\n            case 'bandpass':\r\n                if (Array.isArray(cutoffHz) && cutoffHz.length === 2) {\r\n                    return this.designBandPass(cutoffHz[0], cutoffHz[1], fs, order);\r\n                }\r\n                throw new Error('Bandpass requires [lowCutoff, highCutoff] frequencies');\r\n            case 'bandstop':\r\n                if (Array.isArray(cutoffHz) && cutoffHz.length === 2) {\r\n                    return this.designBandStop(cutoffHz[0], cutoffHz[1], fs, order);\r\n                }\r\n                throw new Error('Bandstop requires [lowCutoff, highCutoff] frequencies');\r\n            default:\r\n                throw new Error(`Unsupported filter type: ${kind}`);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Design a Bessel lowpass filter\r\n     * @param {number} cutoffHz - Cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designLowPass(cutoffHz, fs, order) {\r\n        // True Bessel IIR filter implementation\r\n        const wc = Util.prewarp(cutoffHz, fs);\r\n        const poles = this.calculateBesselPoles(order);\r\n        \r\n        // Convert to digital filter using bilinear transform\r\n        return this.fromPrototype('lowpass', fs, poles, 1, wc);\r\n    }\r\n    \r\n    /**\r\n     * Design a Bessel highpass filter\r\n     * @param {number} cutoffHz - Cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designHighPass(cutoffHz, fs, order) {\r\n        // True Bessel IIR filter implementation\r\n        const wc = Util.prewarp(cutoffHz, fs);\r\n        const poles = this.calculateBesselPoles(order);\r\n        \r\n        // Apply highpass transformation (s -> 1/s)\r\n        const transformedPoles = poles.map(p => C.div(C.of(1, 0), p));\r\n        \r\n        return this.fromPrototype('highpass', fs, transformedPoles, -1, wc);\r\n    }\r\n    \r\n    /**\r\n     * Design a Bessel bandpass filter using lowpass + highpass combination\r\n     * @param {number} lowCutoffHz - Lower cutoff frequency in Hz\r\n     * @param {number} highCutoffHz - Upper cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designBandPass(lowCutoffHz, highCutoffHz, fs, order) {\r\n        // Design highpass filter at lowCutoffHz\r\n        const hpFilter = this.designHighPass(lowCutoffHz, fs, order);\r\n        \r\n        // Design lowpass filter at highCutoffHz\r\n        const lpFilter = this.designLowPass(highCutoffHz, fs, order);\r\n        \r\n        // Combine filters by cascading (multiplying transfer functions)\r\n        const combinedB = Util.polymul(hpFilter.b, lpFilter.b);\r\n        const combinedA = Util.polymul(hpFilter.a, lpFilter.a);\r\n        const combinedSections = hpFilter.sections.concat(lpFilter.sections);\r\n        \r\n        return { b: combinedB, a: combinedA, sections: combinedSections };\r\n    }\r\n    \r\n    /**\r\n     * Design a Bessel bandstop filter using parallel highpass + lowpass combination\r\n     * @param {number} lowCutoffHz - Lower cutoff frequency in Hz\r\n     * @param {number} highCutoffHz - Upper cutoff frequency in Hz\r\n     * @param {number} fs - Sampling frequency in Hz\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter coefficients {b, a, sections}\r\n     */\r\n    static designBandStop(lowCutoffHz, highCutoffHz, fs, order) {\r\n        // Design lowpass filter at lowCutoffHz\r\n        const lpFilter = this.designLowPass(lowCutoffHz, fs, order);\r\n        \r\n        // Design highpass filter at highCutoffHz\r\n        const hpFilter = this.designHighPass(highCutoffHz, fs, order);\r\n        \r\n        // For bandstop: H_bandstop(s) = H_lp(s) + H_hp(s)\r\n        // This requires parallel combination (addition) of transfer functions\r\n        // Convert to common denominator and add numerators\r\n        const commonA = Util.polymul(lpFilter.a, hpFilter.a);\r\n        const lpNum = Util.polymul(lpFilter.b, hpFilter.a);\r\n        const hpNum = Util.polymul(hpFilter.b, lpFilter.a);\r\n        const combinedB = Util.polyadd(lpNum, hpNum);\r\n        \r\n        // Combine sections by creating a parallel structure\r\n        const combinedSections = [\r\n            ...lpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() })),\r\n            ...hpFilter.sections.map(s => ({ b: s.b.slice(), a: s.a.slice() }))\r\n        ];\r\n        \r\n        return { b: combinedB, a: commonA, sections: combinedSections };\r\n    }\r\n    \r\n    /**\r\n     * Calculate Bessel filter poles\r\n     * @param {number} order - Filter order\r\n     * @returns {Array} Array of complex poles\r\n     */\r\n    static calculateBesselPoles(order) {\r\n        // Bessel filter poles are the roots of the Bessel polynomial\r\n        // For low orders, we can use pre-calculated values\r\n        const poleSets = {\r\n            1: [C.of(-1, 0)],\r\n            2: [C.of(-1.5, 0.8660254037844386), C.of(-1.5, -0.8660254037844386)],\r\n            3: [C.of(-2.322185354626086, 0), C.of(-1.838907322686957, 1.754380959783721), C.of(-1.838907322686957, -1.754380959783721)],\r\n            4: [C.of(-2.103789397179628, 0.6657060219931349), C.of(-2.103789397179628, -0.6657060219931349), C.of(-1.896210602820372, 1.744447419188405), C.of(-1.896210602820372, -1.744447419188405)],\r\n            5: [C.of(-2.324674303181611, 0), C.of(-2.048290428681656, 1.000044768299361), C.of(-2.048290428681656, -1.000044768299361), C.of(-1.673416736234146, 1.673416736234146), C.of(-1.673416736234146, -1.673416736234146)],\r\n            6: [C.of(-2.132906311462530, 0.4718706301774892), C.of(-2.132906311462530, -0.4718706301774892), C.of(-1.905412542845325, 1.552914270615124), C.of(-1.905412542845325, -1.552914270615124), C.of(-1.606938159156189, 1.606938159156189), C.of(-1.606938159156189, -1.606938159156189)],\r\n            7: [C.of(-2.324674303181611, 0), C.of(-2.048290428681656, 1.000044768299361), C.of(-2.048290428681656, -1.000044768299361), C.of(-1.673416736234146, 1.673416736234146), C.of(-1.673416736234146, -1.673416736234146), C.of(-1.414213562373095, 1.414213562373095), C.of(-1.414213562373095, -1.414213562373095)],\r\n            8: [C.of(-2.132906311462530, 0.4718706301774892), C.of(-2.132906311462530, -0.4718706301774892), C.of(-1.905412542845325, 1.552914270615124), C.of(-1.905412542845325, -1.552914270615124), C.of(-1.606938159156189, 1.606938159156189), C.of(-1.606938159156189, -1.606938159156189), C.of(-1.414213562373095, 1.414213562373095), C.of(-1.414213562373095, -1.414213562373095)],\r\n            9: [C.of(-2.324674303181611, 0), C.of(-2.048290428681656, 1.000044768299361), C.of(-2.048290428681656, -1.000044768299361), C.of(-1.673416736234146, 1.673416736234146), C.of(-1.673416736234146, -1.673416736234146), C.of(-1.414213562373095, 1.414213562373095), C.of(-1.414213562373095, -1.414213562373095), C.of(-1.224744871391589, 1.224744871391589), C.of(-1.224744871391589, -1.224744871391589)],\r\n            10: [C.of(-2.132906311462530, 0.4718706301774892), C.of(-2.132906311462530, -0.4718706301774892), C.of(-1.905412542845325, 1.552914270615124), C.of(-1.905412542845325, -1.552914270615124), C.of(-1.606938159156189, 1.606938159156189), C.of(-1.606938159156189, -1.606938159156189), C.of(-1.414213562373095, 1.414213562373095), C.of(-1.414213562373095, -1.414213562373095), C.of(-1.224744871391589, 1.224744871391589), C.of(-1.224744871391589, -1.224744871391589)]\r\n        };\r\n        \r\n        if (poleSets[order]) {\r\n            return poleSets[order];\r\n        }\r\n        \r\n        // For higher orders, use numerical calculation\r\n        return this.calculateBesselPolesNumerical(order);\r\n    }\r\n    \r\n    /**\r\n     * Calculate Bessel poles numerically for higher orders\r\n     * @param {number} order - Filter order\r\n     * @returns {Array} Array of complex poles\r\n     */\r\n    static calculateBesselPolesNumerical(order) {\r\n        // This is a simplified numerical approach\r\n        // In practice, this would use more sophisticated root-finding algorithms\r\n        \r\n        const poles = [];\r\n        \r\n        // For even orders, all poles are complex conjugate pairs\r\n        if (order % 2 === 0) {\r\n            for (let i = 0; i < order / 2; i++) {\r\n                const angle = (2 * i + 1) * Math.PI / (2 * order);\r\n                const real = -Math.cos(angle);\r\n                const imag = Math.sin(angle);\r\n                poles.push(C.of(real, imag));\r\n                poles.push(C.of(real, -imag));\r\n            }\r\n        } else {\r\n            // For odd orders, one real pole and complex conjugate pairs\r\n            poles.push(C.of(-1, 0));\r\n            for (let i = 0; i < (order - 1) / 2; i++) {\r\n                const angle = (2 * i + 1) * Math.PI / (2 * order);\r\n                const real = -Math.cos(angle);\r\n                const imag = Math.sin(angle);\r\n                poles.push(C.of(real, imag));\r\n                poles.push(C.of(real, -imag));\r\n            }\r\n        }\r\n        \r\n        return poles;\r\n    }\r\n    \r\n    /**\r\n     * Calculate Bessel polynomial coefficients\r\n     * @param {number} order - Filter order\r\n     * @returns {Array} Array of polynomial coefficients\r\n     */\r\n    static calculateBesselPolynomial(order) {\r\n        // Bessel polynomials are defined recursively\r\n        // B_n(s) = (2n-1)B_{n-1}(s) + s^2 B_{n-2}(s)\r\n        \r\n        if (order === 0) return [1];\r\n        if (order === 1) return [1, 1];\r\n        \r\n        let b_n_minus_2 = [1]; // B_0(s) = 1\r\n        let b_n_minus_1 = [1, 1]; // B_1(s) = 1 + s\r\n        \r\n        for (let n = 2; n <= order; n++) {\r\n            const b_n = new Array(n + 1).fill(0);\r\n            \r\n            // (2n-1) * B_{n-1}(s)\r\n            for (let i = 0; i < b_n_minus_1.length; i++) {\r\n                b_n[i] += (2 * n - 1) * b_n_minus_1[i];\r\n            }\r\n            \r\n            // s^2 * B_{n-2}(s) - shift by 2 positions\r\n            for (let i = 0; i < b_n_minus_2.length; i++) {\r\n                b_n[i + 2] += b_n_minus_2[i];\r\n            }\r\n            \r\n            b_n_minus_2 = b_n_minus_1;\r\n            b_n_minus_1 = b_n;\r\n        }\r\n        \r\n        return b_n_minus_1;\r\n    }\r\n    \r\n    /**\r\n     * Get recommended filter orders for Bessel filters\r\n     * @returns {Array} Array of recommended orders\r\n     */\r\n    static getRecommendedOrders() {\r\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    }\r\n    \r\n    /**\r\n     * Calculate group delay for Bessel filter\r\n     * @param {number} order - Filter order\r\n     * @param {number} frequency - Frequency in Hz\r\n     * @param {number} fs - Sampling frequency\r\n     * @returns {number} Group delay in seconds\r\n     */\r\n    static calculateGroupDelay(order, frequency, fs) {\r\n        // Bessel filters have maximally flat group delay\r\n        // The group delay is approximately constant in the passband\r\n        const normalizedFreq = 2 * Math.PI * frequency / fs;\r\n        \r\n        // Simplified group delay calculation\r\n        // In practice, this would be calculated from the filter's phase response\r\n        const groupDelay = order / (2 * Math.PI * frequency);\r\n        \r\n        return Math.max(0, groupDelay);\r\n    }\r\n    \r\n    /**\r\n     * Get Bessel filter characteristics\r\n     * @param {number} order - Filter order\r\n     * @returns {Object} Filter characteristics\r\n     */\r\n    static getCharacteristics(order) {\r\n        const characteristics = {\r\n            1: { groupDelay: 1.0, rolloff: -6, phase: 'Linear' },\r\n            2: { groupDelay: 1.5, rolloff: -12, phase: 'Linear' },\r\n            3: { groupDelay: 2.0, rolloff: -18, phase: 'Linear' },\r\n            4: { groupDelay: 2.5, rolloff: -24, phase: 'Linear' },\r\n            5: { groupDelay: 3.0, rolloff: -30, phase: 'Linear' },\r\n            6: { groupDelay: 3.5, rolloff: -36, phase: 'Linear' },\r\n            7: { groupDelay: 4.0, rolloff: -42, phase: 'Linear' },\r\n            8: { groupDelay: 4.5, rolloff: -48, phase: 'Linear' },\r\n            9: { groupDelay: 5.0, rolloff: -54, phase: 'Linear' },\r\n            10: { groupDelay: 5.5, rolloff: -60, phase: 'Linear' }\r\n        };\r\n        \r\n        return characteristics[order] || { groupDelay: order * 0.5, rolloff: -6 * order, phase: 'Linear' };\r\n    }\r\n}\r\n","// iir.js — Infinite Impulse Response filter design\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { FIRDesigner } from './fir.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\nimport { ButterworthFilter } from './butterworth-filter.js';\r\nimport { ChebyshevFilter } from './chebyshev-filter.js';\r\nimport { ChebyshevType2Filter } from './chebyshev-type2-filter.js';\r\nimport { LinkwitzRileyFilter } from './linkwitz-riley-filter.js';\r\nimport { EllipticFilter } from './elliptic-filter.js';\r\nimport { BesselFilter } from './bessel-filter.js';\r\n\r\n/**\r\n * @typedef {\"lowpass\"|\"highpass\"|\"bandpass\"|\"bandstop\"} FiltKind\r\n * @typedef {{b:number[], a:[number, number, number]}} Biquad // a = [1,a1,a2] (digital biquad)\r\n */\r\n\r\n/**\r\n * IIR filter designer (Butterworth, Chebyshev-I, Chebyshev-II, Linkwitz–Riley)\r\n * \r\n * This class provides a unified interface for IIR filter design by delegating\r\n * to specialized filter classes. It focuses on orchestration rather than\r\n * implementing specific filter algorithms.\r\n */\r\nexport class IIRDesigner {\r\n  // ----------------------------- Filter Design Orchestration -----------------------------\r\n\r\n  /**\r\n   * Builds filter from normalized prototype poles using proper analog transforms,\r\n   * then bilinear; normalize digitally at z0 (DC for LP, Nyquist for HP).\r\n   * Delegates to BaseIIRFilter.fromPrototype for consistency.\r\n   * \r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {C[]} polesNorm - Normalized poles\r\n   * @param {number} normalizeAt - Normalization point (1 for LP, -1 for HP)\r\n   * @param {number} wc - Cutoff frequency in rad/s\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static fromPrototype(kind, fs, polesNorm, normalizeAt, wc) {\r\n    return BaseIIRFilter.fromPrototype(kind, fs, polesNorm, normalizeAt, wc);\r\n  }\r\n\r\n  // ----------------------------- Public Filter Design Interface -----------------------------\r\n\r\n  /**\r\n   * Designs a Butterworth filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static butterworth(kind, cutoffHz, fs, order) {\r\n    return ButterworthFilter.design(kind, cutoffHz, fs, order);\r\n  }\r\n\r\n  /**\r\n   * Designs a Chebyshev Type 1 filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} rp - Passband ripple in dB\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static cheby1(kind, cutoffHz, fs, order, rp = 1) {\r\n    return ChebyshevFilter.design(kind, cutoffHz, fs, order, rp);\r\n  }\r\n\r\n  /**\r\n   * Designs a Chebyshev Type 2 filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} rs - Stopband attenuation in dB\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static cheby2(kind, cutoffHz, fs, order, rs = 40) {\r\n    return ChebyshevType2Filter.design(kind, cutoffHz, fs, order, rs);\r\n  }\r\n\r\n  /**\r\n   * Designs a Linkwitz-Riley filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} orderEven - Filter order (must be even)\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static linkwitzRiley(kind, cutoffHz, fs, orderEven = 4) {\r\n    return LinkwitzRileyFilter.design(kind, cutoffHz, fs, orderEven);\r\n  }\r\n\r\n  /**\r\n   * Designs an Elliptic (Cauer) filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @param {number} rp - Passband ripple in dB\r\n   * @param {number} rs - Stopband attenuation in dB\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static elliptic(kind, cutoffHz, fs, order, rp = 1, rs = 40) {\r\n    return EllipticFilter.design(kind, cutoffHz, fs, order, rp, rs);\r\n  }\r\n\r\n  /**\r\n   * Designs a Bessel filter\r\n   * @param {FilterKind} kind - Filter type\r\n   * @param {number|number[]} cutoffHz - Cutoff frequency(ies)\r\n   * @param {number} fs - Sampling frequency\r\n   * @param {number} order - Filter order\r\n   * @returns {{b: number[], a: number[], sections: Biquad[]}} Filter coefficients and sections\r\n   */\r\n  static bessel(kind, cutoffHz, fs, order) {\r\n    return BesselFilter.design(kind, cutoffHz, fs, order);\r\n  }\r\n}\r\n","// zdomain.js — Z-domain operations for DSP\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { Util } from './utils.js';\r\n\r\n/**\r\n * @typedef {{w:number[], H:Complex[], mag:number[], phase:number[]}} FreqResponse\r\n */\r\n\r\n/**\r\n * Z-domain operations for digital signal processing\r\n */\r\nexport class ZDomain {\r\n    /** @returns {Complex} */\r\n    static evalHz(b, a, z) {\r\n        const zinv = C.div(C.of(1,0), z);\r\n        const pow = (k) => {\r\n            let p = C.of(1,0);\r\n            for (let i = 0; i < k; i++) p = C.mul(p, zinv);\r\n            return p;\r\n        };\r\n        let num = C.of(0,0);\r\n        for (let k = 0; k < b.length; k++) num = C.add(num, C.scale(pow(k), b[k]));\r\n        let den = C.of(1,0);\r\n        for (let k = 1; k < a.length; k++) den = C.add(den, C.scale(pow(k), a[k]));\r\n        return C.div(num, den);\r\n    }\r\n    \r\n    /** @returns {FreqResponse} */\r\n    static freqz(b, a, N = 512) {\r\n        const w = Util.linspace(0, Math.PI, N);\r\n        const H = w.map(wi => ZDomain.evalHz(b, a, C.expj(wi)));\r\n        const mag = H.map(C.abs);\r\n        const phase = H.map(C.arg);\r\n        return { w, H, mag, phase };\r\n    }\r\n    \r\n    static groupDelay(b, a, N = 512) {\r\n        const { w, phase } = ZDomain.freqz(b, a, N);\r\n        const unwrapped = [...phase];\r\n        for (let i = 1; i < unwrapped.length; i++) {\r\n            let d = unwrapped[i] - unwrapped[i-1];\r\n            while (d > Math.PI) { unwrapped[i] -= 2*Math.PI; d -= 2*Math.PI; }\r\n            while (d < -Math.PI) { unwrapped[i] += 2*Math.PI; d += 2*Math.PI; }\r\n        }\r\n        const dw = w[1] - w[0];\r\n        const gd = unwrapped.map((_, i) => (i === 0 || i === unwrapped.length - 1) ? 0\r\n            : -(unwrapped[i+1] - unwrapped[i-1]) / (2*dw));\r\n        return { w, gd };\r\n    }\r\n    \r\n    static isStable(/* a */) { \r\n        return true; // placeholder\r\n    }\r\n}\r\n","// filter-class.js — Main Filter class and operations\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\nimport { ComplexNum as C } from './complex.js';\r\nimport { FIRDesigner } from './fir.js';\r\nimport { IIRDesigner } from './iir.js';\r\nimport { ZDomain } from './zdomain.js';\r\n\r\nexport class Filter {\r\n    constructor(b, a = [1], sections = []) {\r\n        if (Math.abs(a[0] - 1) > 1e-12) {\r\n            b = b.map(v => v / a[0]);\r\n            a = a.map(v => v / a[0]);\r\n        }\r\n        this.b = b.slice();\r\n        this.a = a.slice();\r\n        this.sections = (sections || []).map(s => ({ b: s.b.slice(), a: [1, s.a[1], s.a[2]] }));\r\n\r\n        if (this.sections.length > 0) {\r\n            this._sosState = this.sections.map(() => ({ w1: 0, w2: 0 }));\r\n        } else if (this.a.length === 1) {\r\n            this._firIdx = 0;\r\n            this._firBuf = new Array(this.b.length).fill(0);\r\n        } else {\r\n            const N = Math.max(this.b.length, this.a.length) - 1;\r\n            this._iirW = new Array(N).fill(0);\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        if (this._sosState) this._sosState.forEach(s => { s.w1 = 0; s.w2 = 0; });\r\n        if (this._firBuf) this._firBuf.fill(0), this._firIdx = 0;\r\n        if (this._iirW) this._iirW.fill(0);\r\n    }\r\n\r\n    processSample(x) {\r\n        if (this.sections.length > 0) {\r\n            let v = x;\r\n            for (let i = 0; i < this.sections.length; i++) {\r\n                const { b, a } = this.sections[i];\r\n                const st = this._sosState[i];\r\n                const w0 = v - a[1]*st.w1 - a[2]*st.w2;\r\n                const y0 = b[0]*w0 + b[1]*st.w1 + b[2]*st.w2;\r\n                st.w2 = st.w1; st.w1 = w0;\r\n                v = y0;\r\n            }\r\n            return v;\r\n        }\r\n\r\n        if (this.a.length === 1) {\r\n            this._firBuf[this._firIdx] = x;\r\n            let y = 0, idx = this._firIdx;\r\n            for (let k = 0; k < this.b.length; k++) {\r\n                y += this.b[k] * this._firBuf[idx];\r\n                idx = (idx - 1 + this._firBuf.length) % this._firBuf.length;\r\n            }\r\n            this._firIdx = (this._firIdx + 1) % this._firBuf.length;\r\n            return y;\r\n        }\r\n\r\n        let wn = x;\r\n        for (let k = 1; k < this.a.length; k++) wn -= this.a[k] * (this._iirW[k-1] || 0);\r\n        let yn = this.b[0]*wn;\r\n        for (let k = 1; k < this.b.length; k++) yn += (this._iirW[k-1] || 0) * this.b[k];\r\n        for (let k = this._iirW.length-1; k > 0; k--) this._iirW[k] = this._iirW[k-1];\r\n        this._iirW[0] = wn;\r\n        return yn;\r\n    }\r\n\r\n    applySignal(x) {\r\n        const y = new Array(x.length);\r\n        for (let i=0;i<x.length;i++) y[i] = this.processSample(x[i]);\r\n        return y;\r\n    }\r\n\r\n    frequencyResponse(fs, N = 1024) {\r\n        const fr = ZDomain.freqz(this.b, this.a, N);\r\n        const f = fr.w.map(w => w * fs / (2*Math.PI));\r\n        return { f, mag: fr.mag, phase: fr.phase, H: fr.H };\r\n    }\r\n\r\n    toJSON(){ \r\n        return { b: this.b.slice(), a: this.a.slice() }; \r\n    }\r\n\r\n    static fromTF(b,a){ \r\n        return new Filter(b,a); \r\n    }\r\n    \r\n    static designFIR(kind, cutoffHz, fs, order, window='hann'){\r\n        const tf = FIRDesigner.design(kind, cutoffHz, fs, order, window);\r\n        return new Filter(tf.b, tf.a);\r\n    }\r\n    \r\n    static designButter(kind, cutoffHz, fs, order){\r\n        const result = IIRDesigner.butterworth(kind, cutoffHz, fs, order);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n    \r\n    static designCheby1(kind, cutoffHz, fs, order, rp=1){\r\n        const result = IIRDesigner.cheby1(kind, cutoffHz, fs, order, rp);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n    \r\n    static designCheby2(kind, cutoffHz, fs, order, rs = 40) {\r\n        const result = IIRDesigner.cheby2(kind, cutoffHz, fs, order, rs);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n\r\n    static designLinkwitzRiley(kind, cutoffHz, fs, orderEven = 4) {\r\n        const result = IIRDesigner.linkwitzRiley(kind, cutoffHz, fs, orderEven);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n\r\n    static designElliptic(kind, cutoffHz, fs, order, rp = 1, rs = 40) {\r\n        const result = IIRDesigner.elliptic(kind, cutoffHz, fs, order, rp, rs);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n\r\n    static designBessel(kind, cutoffHz, fs, order) {\r\n        const result = IIRDesigner.bessel(kind, cutoffHz, fs, order);\r\n        return new Filter(result.b, result.a, result.sections);\r\n    }\r\n}\r\n","// index.js — Main entry point for DSP library\r\n// Author: Davit Akobia <dav.akobia@gmail.com>\r\n// License: MIT\r\n\r\n// Core modules\r\nexport { ComplexNum, C } from './complex.js';\r\nexport { Util } from './utils.js';\r\nexport { FFT } from './fft.js';\r\nexport { Window } from './windows.js';\r\nexport { Kernels, FIRDesigner } from './fir.js';\r\nexport { IIRDesigner } from './iir.js';\r\nexport { ZDomain } from './zdomain.js';\r\n\r\n// Individual filter classes\r\nexport { ButterworthFilter } from './butterworth-filter.js';\r\nexport { ChebyshevFilter } from './chebyshev-filter.js';\r\nexport { ChebyshevType2Filter } from './chebyshev-type2-filter.js';\r\nexport { LinkwitzRileyFilter } from './linkwitz-riley-filter.js';\r\nexport { EllipticFilter } from './elliptic-filter.js';\r\nexport { BesselFilter } from './bessel-filter.js';\r\nexport { BaseIIRFilter } from './base-iir-filter.js';\r\n\r\n// Main Filter class\r\nexport { Filter } from './filter-class.js';\r\n\r\n// Import for internal use\r\nimport { ComplexNum, C } from './complex.js';\r\nimport { Util } from './utils.js';\r\nimport { FFT } from './fft.js';\r\nimport { Window } from './windows.js';\r\nimport { Kernels, FIRDesigner } from './fir.js';\r\nimport { IIRDesigner } from './iir.js';\r\nimport { ZDomain } from './zdomain.js';\r\nimport { Filter } from './filter-class.js';\r\nimport { ButterworthFilter } from './butterworth-filter.js';\r\nimport { ChebyshevFilter } from './chebyshev-filter.js';\r\nimport { ChebyshevType2Filter } from './chebyshev-type2-filter.js';\r\nimport { LinkwitzRileyFilter } from './linkwitz-riley-filter.js';\r\nimport { EllipticFilter } from './elliptic-filter.js';\r\nimport { BesselFilter } from './bessel-filter.js';\r\nimport { BaseIIRFilter } from './base-iir-filter.js';\r\n\r\n// Backward compatibility namespaces\r\nexport const FIR = {\r\n    design: (kind, cutoffHz, fs, order, window='hann') => {\r\n        return FIRDesigner.design(kind, cutoffHz, fs, order, window);\r\n    },\r\n    apply: (b, x) => {\r\n        return FIRDesigner.apply(b, x);\r\n    },\r\n    overlapAdd: (b,x,blockSize) => {\r\n        return FIRDesigner.overlapAdd(b,x,blockSize);\r\n    },\r\n};\r\n\r\nexport const IIR = {\r\n    butterworth: (kind, cutoffHz, fs, order) => {\r\n        const result = IIRDesigner.butterworth(kind, cutoffHz, fs, order);\r\n        return { b: result.b, a: result.a };\r\n    },\r\n    cheby1: (kind, cutoffHz, fs, order, rp=1) => {\r\n        const result = IIRDesigner.cheby1(kind, cutoffHz, fs, order, rp);\r\n        return { b: result.b, a: result.a };\r\n    },\r\n    cheby2: (kind, cutoffHz, fs, order, rs=40) => {\r\n        const result = IIRDesigner.cheby2(kind, cutoffHz, fs, order, rs);\r\n        return { b: result.b, a: result.a };\r\n    },\r\n    linkwitzRiley: (kind, cutoffHz, fs, orderEven=4) => {\r\n        const result = IIRDesigner.linkwitzRiley(kind, cutoffHz, fs, orderEven);\r\n        return { b: result.b, a: result.a };\r\n    },\r\n    apply: (b, a, x) => {\r\n        return Filter.fromTF(b,a).applySignal(x);\r\n    },\r\n};\r\n\r\nexport const Z = {\r\n    evalHz: (b,a,z) => ZDomain.evalHz(b,a,z),\r\n    freqz: (b,a,N=512) => ZDomain.freqz(b,a,N),\r\n    groupDelay: (b,a,N=512) => ZDomain.groupDelay(b,a,N),\r\n    isStable: () => ZDomain.isStable(),\r\n};\r\n\r\n// Default export\r\nexport default {\r\n    // Core classes\r\n    ComplexNum, C,\r\n    Util, FFT, Window, Kernels,\r\n    FIRDesigner, IIRDesigner,\r\n    ZDomain, Filter,\r\n    // Individual filter classes\r\n    ButterworthFilter, ChebyshevFilter, ChebyshevType2Filter, LinkwitzRileyFilter, EllipticFilter, BesselFilter, BaseIIRFilter,\r\n    // Backward compatibility\r\n    FIR, IIR, Z,\r\n};\r\n"],"names":["ComplexNum","of","re","im","add","a","b","sub","mul","scale","s","conj","div","d","abs","Math","hypot","arg","atan2","expj","theta","cos","sin","pow","n","C","result","i","sqrt","r","Util","nextPow2","Number","isFinite","p","linspace","start","end","step","Array","from","length","_","convolve","x","h","y","fill","xi","j","polymul","na","nb","polyadd","maxLen","max","polyfromroots","roots","tol","used","pair","a2","prewarp","fHz","fs","tan","PI","pairConjugates","list","out","q","push","bilinearMapBiquad","b2","b1","b0","a1","a0","K","A0","evalHzAtZ","z0","reduce","acc","bi","ai","FFT","fft","m","concat","bit","t","len","ang","k","w","u","v","ifft","X","map","rfft","powerSpectrum","Window","rect","N","rectangle","hann","hamming","blackman","blackmanHarris","blackmanNuttall","kaiser","beta","denom","_i0","M","tukey","alpha","gauss","sigma","m2","exp","bartlett","bartlettHann","cosine","lanczos","sinc","bohman","flatTop","byName","name","opts","ax","t2","Kernels","idealLowpass","fc","norm","FIRDesigner","design","kind","cutoffHz","order","window","win","applyWin","f1","f2","lp2","lp1","Error","apply","overlapAdd","blockSize","L","Nfft","B","xblk","Y","Xk","yblk","BaseIIRFilter","validateCommonParameters","fromPrototype","polesNorm","normalizeAt","wc","sections","pairs","p1","p2","a2_lp","a1_lp","a0_lp","A2","A1","bPoly","aPoly","g","last","calculatePoles","params","ButterworthFilter","poles","designLowHighPass","zNorm","designBandPass","hpFilter","lpFilter","designBandStop","commonA","lpNum","hpNum","slice","designBandPassStop","ChebyshevFilter","validateParameters","ripple","eps","asinh","sinhA","sinh","coshA","cosh","ChebyshevType2Filter","stopbandAttenuation","calculatePolesAndZeros","rs","eps2","zerosW","floor","mapSectionLP_HP","polePair","zeroW","b2_lp","b1_lp","b0_lp","B2","B1","B0","designLPHP","this","polePairs","zi","zW","sec","designLowPass","designHighPass","hp","lp","b_lp","b_hp","LinkwitzRileyFilter","halfOrder","baseFilter","cascadedSections","getActualOrder","requestedOrder","getHalfOrder","getNumberOfSections","getRecommendedOrders","basic","standard","high","premium","professional","adjustOrderToEven","getFilterInfo","actualOrder","isAdjusted","description","EllipticFilter","passbandRipple","isArray","zeros","calculateEllipticPolesAndZeros","transformedPoles","lowCutoffHz","highCutoffHz","epsilon","A","k1","calculateModularConstant","completeEllipticIntegral","sn","jacobiSn","real","jacobiCn","imag","jacobiDn","zeroReal","zeroImag","log","ellipticIntegralDerivative","Infinity","sum","term","k2","kprime2","getRecommendedPassbandRipples","getRecommendedStopbandAttenuations","calculateActualPassbandRipple","actualEpsilon","log10","calculateActualStopbandAttenuation","actualA","BesselFilter","calculateBesselPoles","poleSets","calculateBesselPolesNumerical","angle","calculateBesselPolynomial","b_n_minus_2","b_n_minus_1","b_n","calculateGroupDelay","frequency","groupDelay","getCharacteristics","rolloff","phase","IIRDesigner","butterworth","cheby1","rp","cheby2","linkwitzRiley","orderEven","elliptic","bessel","ZDomain","evalHz","z","zinv","num","den","freqz","H","wi","mag","unwrapped","dw","gd","isStable","Filter","constructor","_sosState","w1","w2","_firIdx","_firBuf","_iirW","reset","forEach","processSample","st","w0","y0","idx","wn","yn","applySignal","frequencyResponse","fr","f","toJSON","fromTF","designFIR","tf","designButter","designCheby1","designCheby2","designLinkwitzRiley","designElliptic","designBessel","FIR","IIR","Z","index"],"mappings":"uPAWO,MAAMA,EAET,SAAOC,CAAGC,EAAK,EAAGC,EAAK,GACnB,MAAO,CAAED,KAAIC,KACjB,CAGA,UAAOC,CAAIC,EAAGC,GACV,MAAO,CAAEJ,GAAIG,EAAEH,GAAKI,EAAEJ,GAAIC,GAAIE,EAAEF,GAAKG,EAAEH,GAC3C,CAGA,UAAOI,CAAIF,EAAGC,GACV,MAAO,CAAEJ,GAAIG,EAAEH,GAAKI,EAAEJ,GAAIC,GAAIE,EAAEF,GAAKG,EAAEH,GAC3C,CAGA,UAAOK,CAAIH,EAAGC,GACV,MAAO,CAAEJ,GAAIG,EAAEH,GAAKI,EAAEJ,GAAKG,EAAEF,GAAKG,EAAEH,GAAIA,GAAIE,EAAEH,GAAKI,EAAEH,GAAKE,EAAEF,GAAKG,EAAEJ,GACvE,CAGA,YAAOO,CAAMJ,EAAGK,GACZ,MAAO,CAAER,GAAIG,EAAEH,GAAKQ,EAAGP,GAAIE,EAAEF,GAAKO,EACtC,CAGA,WAAOC,CAAKN,GACR,MAAO,CAAEH,GAAIG,EAAEH,GAAIC,IAAKE,EAAEF,GAC9B,CAGA,UAAOS,CAAIP,EAAGC,GACV,MAAMO,EAAIP,EAAEJ,GAAGI,EAAEJ,GAAKI,EAAEH,GAAGG,EAAEH,IAAM,OACnC,MAAO,CAAED,IAAKG,EAAEH,GAAGI,EAAEJ,GAAKG,EAAEF,GAAGG,EAAEH,IAAIU,EAAGV,IAAKE,EAAEF,GAAGG,EAAEJ,GAAKG,EAAEH,GAAGI,EAAEH,IAAIU,EACxE,CAGA,UAAOC,CAAIT,GACP,OAAOU,KAAKC,MAAMX,EAAEH,GAAIG,EAAEF,GAC9B,CAGA,UAAOc,CAAIZ,GACP,OAAOU,KAAKG,MAAMb,EAAEF,GAAIE,EAAEH,GAC9B,CAGA,WAAOiB,CAAKC,GACR,MAAO,CAAElB,GAAIa,KAAKM,IAAID,GAAQjB,GAAIY,KAAKO,IAAIF,GAC/C,CAGA,UAAOG,CAAIlB,EAAGmB,GACV,GAAU,IAANA,EAAS,MAAO,CAAEtB,GAAI,EAAGC,GAAI,GACjC,GAAU,IAANqB,EAAS,OAAOnB,EACpB,IAAU,IAANmB,EAAU,OAAOC,EAAEb,IAAI,CAAEV,GAAI,EAAGC,GAAI,GAAKE,GAE7C,GAAImB,EAAI,EAAG,CACP,IAAIE,EAAS,CAAExB,GAAI,EAAGC,GAAI,GAC1B,IAAK,IAAIwB,EAAI,EAAGA,EAAIH,EAAGG,IACnBD,EAASD,EAAEjB,IAAIkB,EAAQrB,GAE3B,OAAOqB,CACX,CAAO,CAEH,IAAIA,EAAS,CAAExB,GAAI,EAAGC,GAAI,GAC1B,IAAK,IAAIwB,EAAI,EAAGA,GAAKH,EAAGG,IACpBD,EAASD,EAAEjB,IAAIkB,EAAQrB,GAE3B,OAAOoB,EAAEb,IAAI,CAAEV,GAAI,EAAGC,GAAI,GAAKuB,EACnC,CACJ,CAGA,WAAOE,CAAKvB,GACR,MAAMwB,EAAId,KAAKa,KAAKH,EAAEX,IAAIT,IACpBe,EAAQL,KAAKG,MAAMb,EAAEF,GAAIE,EAAEH,IAAM,EACvC,MAAO,CAAEA,GAAI2B,EAAId,KAAKM,IAAID,GAAQjB,GAAI0B,EAAId,KAAKO,IAAIF,GACvD,EAIQ,MAACK,EAAIzB,ECrFV,MAAM8B,EAKX,eAAOC,CAASP,GACd,IAAKQ,OAAOC,SAAST,IAAMA,GAAK,EAAG,OAAO,EAC1C,IAAIU,EAAI,EACR,KAAOA,EAAIV,GAAGU,GAAK,EACnB,OAAOA,CACT,CAQA,eAAOC,CAASC,EAAOC,EAAKb,GAC1B,GAAIA,GAAK,EAAG,MAAO,GACnB,GAAU,IAANA,EAAS,MAAO,CAACY,GACrB,MAAME,GAAQD,EAAMD,IAAUZ,EAAI,GAClC,OAAOe,MAAMC,KAAK,CAAEC,OAAQjB,GAAK,CAACkB,EAAGf,IAAMS,EAAQT,EAAIW,EACzD,CAIA,eAAOK,CAASC,EAAGC,GACjB,MAAMC,EAAI,IAAIP,MAAMK,EAAEH,OAASI,EAAEJ,OAAS,GAAGM,KAAK,GAClD,IAAK,IAAIpB,EAAI,EAAGA,EAAIiB,EAAEH,OAAQd,IAAK,CACjC,MAAMqB,EAAKJ,EAAEjB,GACb,IAAK,IAAIsB,EAAI,EAAGA,EAAIJ,EAAEJ,OAAQQ,IAAKH,EAAEnB,EAAIsB,IAAMD,EAAKH,EAAEI,EACxD,CACA,OAAOH,CACT,CAGA,cAAOI,CAAQ7C,EAAGC,GAChB,MAAM6C,EAAK9C,EAAEoC,OAAQW,EAAK9C,EAAEmC,OACtBZ,EAAI,IAAIU,MAAMY,EAAKC,EAAK,GAAGL,KAAK,GACtC,IAAK,IAAIpB,EAAI,EAAGA,EAAIwB,EAAIxB,IACtB,IAAK,IAAIsB,EAAI,EAAGA,EAAIG,EAAIH,IACtBpB,EAAEF,EAAIsB,IAAM5C,EAAEsB,GAAKrB,EAAE2C,GACzB,OAAOpB,CACT,CAGA,cAAOwB,CAAQhD,EAAGC,GAChB,MAAMgD,EAASvC,KAAKwC,IAAIlD,EAAEoC,OAAQnC,EAAEmC,QAC9Bf,EAAS,IAAIa,MAAMe,GAAQP,KAAK,GACtC,IAAK,IAAIpB,EAAI,EAAGA,EAAI2B,EAAQ3B,IACtBA,EAAItB,EAAEoC,SAAQf,EAAOC,IAAMtB,EAAEsB,IAC7BA,EAAIrB,EAAEmC,SAAQf,EAAOC,IAAMrB,EAAEqB,IAEnC,OAAOD,CACT,CAUA,oBAAO8B,CAAcC,EAAOC,EAAM,OAChC,MAAMC,EAAO,IAAIpB,MAAMkB,EAAMhB,QAAQM,MAAK,GAC1C,IAAIb,EAAI,CAAC,GAET,IAAK,IAAIP,EAAI,EAAGA,EAAI8B,EAAMhB,OAAQd,IAAK,CACrC,GAAIgC,EAAKhC,GAAI,SACb,MAAME,EAAI4B,EAAM9B,GAGhB,IAAIiC,GAAO,EACX,IAAK,IAAIX,EAAItB,EAAI,EAAGsB,EAAIQ,EAAMhB,OAAQQ,IAAK,CACzC,GAAIU,EAAKV,GAAI,SACb,MAAMvC,EAAI+C,EAAMR,GAChB,GAAIlC,KAAKD,IAAIe,EAAE3B,GAAKQ,EAAER,IAAMwD,GAAO3C,KAAKD,IAAIe,EAAE1B,GAAKO,EAAEP,IAAMuD,EAAK,CAC9DE,EAAOX,EAAG,KACZ,CACF,CAEA,GAAIlC,KAAKD,IAAIe,EAAE1B,IAAM,MAEnB+B,EAAIJ,EAAKoB,QAAQhB,EAAG,CAAC,GAAIL,EAAE3B,KAC3ByD,EAAKhC,IAAK,OACL,GAAIiC,GAAQ,EAAG,CAEpB,MAAMC,EAAK,CAAC,GAAG,EAAKhC,EAAE3B,GAAI2B,EAAE3B,GAAK2B,EAAE3B,GAAK2B,EAAE1B,GAAK0B,EAAE1B,IACjD+B,EAAIJ,EAAKoB,QAAQhB,EAAG2B,GACpBF,EAAKhC,GAAKgC,EAAKC,IAAQ,CACzB,KAAO,CAEL,MAAMC,EAAK,CAAC,GAAG,EAAKhC,EAAE3B,GAAI2B,EAAE3B,GAAK2B,EAAE3B,GAAK2B,EAAE1B,GAAK0B,EAAE1B,IACjD+B,EAAIJ,EAAKoB,QAAQhB,EAAG2B,GACpBF,EAAKhC,IAAK,CACZ,CACF,CACA,OAAOO,CACT,CAQA,cAAO4B,CAAQC,EAAKC,GAClB,OAAO,EAAIA,EAAKjD,KAAKkD,IAAIlD,KAAKmD,GAAKH,EAAMC,EAC3C,CAOA,qBAAOG,CAAeC,GACpB,MAAMT,EAAO,IAAIpB,MAAM6B,EAAK3B,QAAQM,MAAK,GACnCsB,EAAM,GACZ,IAAK,IAAI1C,EAAI,EAAGA,EAAIyC,EAAK3B,OAAQd,IAAK,CACpC,GAAIgC,EAAKhC,GAAI,SACb,MAAMO,EAAIkC,EAAKzC,GACf,IAAIiC,GAAO,EACX,IAAK,IAAIX,EAAItB,EAAI,EAAGsB,EAAImB,EAAK3B,OAAQQ,IAAK,CACxC,GAAIU,EAAKV,GAAI,SACb,MAAMqB,EAAIF,EAAKnB,GACf,GAAIlC,KAAKD,IAAIoB,EAAEhC,GAAKoE,EAAEpE,IAAM,OAASa,KAAKD,IAAIoB,EAAE/B,GAAKmE,EAAEnE,IAAM,MAAO,CAClEyD,EAAOX,EACP,KACF,CACF,CACIW,GAAQ,GACVS,EAAIE,KAAK,CAACrC,EAAGkC,EAAKR,KAClBD,EAAKhC,GAAKgC,EAAKC,IAAQ,IAEvBS,EAAIE,KAAK,CAACrC,IACVyB,EAAKhC,IAAK,EAEd,CACA,OAAO0C,CACT,CAaA,wBAAOG,CAAkBC,EAAIC,EAAIC,EAAId,EAAIe,EAAIC,EAAIb,GAC/C,MAAMc,EAAI,EAAId,EAMRe,EAAKlB,EAAKiB,EAAIA,EAAIF,EAAKE,EAAID,EAIjC,MAAO,CACLvE,EAAG,EATMmE,EAAKK,EAAIA,EAAIJ,EAAKI,EAAIH,GAStBI,EARA,GAAKJ,EAAKF,EAAKK,EAAIA,GAQVC,GAPTN,EAAKK,EAAIA,EAAIJ,EAAKI,EAAIH,GAOJI,GAC3B1E,EAAG,CAAC,EALK,GAAKwE,EAAKhB,EAAKiB,EAAIA,GAKhBC,GAJHlB,EAAKiB,EAAIA,EAAIF,EAAKE,EAAID,GAIVE,GAEzB,CASA,gBAAOC,CAAU1E,EAAGD,EAAG4E,GAGrB,OAFY3E,EAAE4E,OAAO,CAACC,EAAKC,EAAIzD,IAAMwD,EAAMC,EAAKrE,KAAKQ,IAAI0D,GAAKtD,GAAI,GACtDtB,EAAE6E,OAAO,CAACC,EAAKE,EAAI1D,IAAMwD,EAAME,EAAKtE,KAAKQ,IAAI0D,GAAKtD,GAAI,EAEpE,ECrLK,MAAM2D,EAET,UAAOC,CAAI3C,GACP,IAAIpB,EAAIoB,EAAEH,OACV,GAAIjB,GAAK,EAAG,OAAOoB,EACnB,GAAKpB,EAAKA,EAAI,EAAW,CACrB,MAAMgE,EAAI1D,EAAKC,SAASP,GACxB,OAAO8D,EAAIC,IAAI3C,EAAE6C,OAAOlD,MAAMC,KAAK,CAAEC,OAAQ+C,EAAIhE,GAAK,IAAMC,EAAExB,GAAG,EAAG,KACxE,CAEA,IAAIgD,EAAI,EACR,IAAK,IAAItB,EAAI,EAAGA,EAAIH,EAAI,EAAGG,IAAK,CAC5B,IAAI+D,EAAMlE,GAAK,EACf,KAAOyB,EAAIyC,EAAKA,IAAQ,EAAGzC,GAAKyC,EAEhC,GADAzC,GAAKyC,EACD/D,EAAIsB,EAAG,CAAE,MAAM0C,EAAI/C,EAAEjB,GAAIiB,EAAEjB,GAAKiB,EAAEK,GAAIL,EAAEK,GAAK0C,CAAG,CACxD,CAEA,IAAK,IAAIC,EAAM,EAAGA,GAAOpE,EAAGoE,IAAQ,EAAG,CACnC,MAAMC,GAAM,EAAK9E,KAAKmD,GAAK0B,EAC3B,IAAK,IAAIjE,EAAI,EAAGA,EAAIH,EAAGG,GAAKiE,EACxB,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAM,EAAGE,IAAK,CAC9B,MAAMC,EAAItE,EAAEN,KAAK0E,EAAMC,GACjBE,EAAIpD,EAAEjB,EAAImE,GACVG,EAAIxE,EAAEjB,IAAIoC,EAAEjB,EAAImE,GAAKF,GAAO,IAAKG,GACvCnD,EAAEjB,EAAImE,GAAKrE,EAAErB,IAAI4F,EAAGC,GACpBrD,EAAEjB,EAAImE,GAAKF,GAAO,IAAMnE,EAAElB,IAAIyF,EAAGC,EACrC,CAER,CACA,OAAOrD,CACX,CAGA,WAAOsD,CAAKC,GACR,MAAM3E,EAAI2E,EAAE1D,OACZ,OAAO6C,EAAIC,IAAIY,EAAEC,IAAI3E,EAAEd,OAAOyF,IAAI3E,EAAEd,MAAMyF,IAAIH,GAAKxE,EAAEhB,MAAMwF,EAAG,EAAIzE,GACtE,CAGA,WAAO6E,CAAKzD,GACR,MAAMpB,EAAIM,EAAKC,SAASa,EAAEH,QACpBpC,EAAIkC,MAAMC,KAAK,CAAEC,OAAQjB,GAAK,CAACkB,EAAGf,IAAMF,EAAExB,GAAG2C,EAAEjB,IAAM,EAAG,IAC9D,OAAO2D,EAAIC,IAAIlF,EACnB,CAGA,oBAAOiG,CAAc1D,GACjB,OAAO0C,EAAIe,KAAKzD,GAAGwD,IAAI3E,EAAEX,KAAKsF,IAAIH,GAAKA,EAAEA,EAC7C,ECpDG,MAAMM,EACT,WAAOC,CAAKC,GACR,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,IAAM,EAC3C,CAEA,gBAAOC,CAAUD,GACb,OAAOF,EAAOC,KAAKC,EACvB,CAEA,WAAOE,CAAKF,GACR,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAAM,GAAM,GAAIT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IACjF,CAEA,cAAOG,CAAQH,GACX,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAAM,IAAO,IAAKT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IACnF,CAEA,eAAOI,CAASJ,GAEZ,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAD1B,IAAW,GAEVT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAFJ,IAEa1F,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IACzE,CAEA,qBAAOK,CAAeL,GAElB,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAD1B,OAAc,OAEbT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAFG,OAEM1F,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAFhB,OAEyB1F,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAC1G,CAEA,sBAAOM,CAAgBN,GAEnB,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAD1B,SAAgB,SAEfT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAFO,SAEE1F,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAFV,SAEmB1F,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,GAAGiF,EAAE,IAC1G,CAEA,aAAOO,CAAOP,EAAGQ,EAAO,KACpB,MAAMC,EAAQC,EAAIF,GAAOG,EAAIX,EAAI,EACjC,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KACjC,MAAMmE,EAAK,EAAEnE,EAAG4F,EAAI,EACpB,OAAOD,EAAIF,EAAOlG,KAAKa,KAAK,EAAI+D,EAAEA,IAAMuB,GAEhD,CAEA,YAAOG,CAAMZ,EAAGa,EAAQ,IACpB,MAAMF,EAAIX,EAAI,EACd,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KACjC,MAAMoB,EAAIpB,EAAI4F,EACd,OAAIE,GAAS,EAAU,EACnBA,GAAS,EAAU,IAAK,EAAIvG,KAAKM,IAAI,EAAEN,KAAKmD,GAAGtB,IAC/CA,EAAI0E,EAAM,EAAU,IAAK,EAAIvG,KAAKM,IAAIN,KAAKmD,IAAI,EAAEtB,EAAE0E,EAAQ,KAC3D1E,GAAK,EAAI0E,EAAM,EAAU,EACtB,IAAK,EAAIvG,KAAKM,IAAIN,KAAKmD,IAAI,EAAEtB,EAAE0E,EAAQ,EAAEA,EAAQ,MAEhE,CAEA,YAAOC,CAAMd,EAAGe,EAAQ,IACpB,MAAiBC,GAAPhB,EAAI,GAAU,EACxB,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KACjC,MAAMsE,GAAKtE,EAAIiG,IAAOD,EAAQC,GAC9B,OAAO1G,KAAK2G,KAAI,GAAK5B,EAAEA,IAE/B,CAEA,eAAO6B,CAASlB,GACZ,MAAMW,EAAIX,EAAI,EACd,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAAM,EAAIT,KAAKD,KAAKU,EAAI4F,EAAE,IAAIA,EAAE,IACzE,CAEA,mBAAOQ,CAAanB,GAChB,MAAMW,EAAIX,EAAI,EACd,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KACjC,MAAMoB,EAAIpB,EAAI4F,EACd,MAAO,IAAO,IAAKrG,KAAKD,IAAI8B,EAAI,IAAO,IAAK7B,KAAKM,IAAI,EAAEN,KAAKmD,GAAGtB,IAEvE,CAEA,aAAOiF,CAAOpB,GACV,MAAMW,EAAIX,EAAI,EACd,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAAMT,KAAKO,IAAIP,KAAKmD,GAAG1C,EAAE4F,GAClE,CAEA,cAAOU,CAAQrB,GACX,MAAiBgB,GAAPhB,EAAI,GAAU,EAExB,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KAAMuG,OADjB,KAAZnF,GACmCpB,EAAIiG,GAAIA,GAD3B,EAAI1G,KAAKO,IAAIP,KAAKmD,GAAGtB,IAAI7B,KAAKmD,GAAGtB,GAAlD,IAACA,GAElB,CAEA,aAAOoF,CAAOvB,GACV,MAAiBgB,GAAPhB,EAAI,GAAU,EACxB,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,KACjC,MAAMoB,EAAI7B,KAAKD,IAAIU,EAAIiG,GAAMA,EAC7B,OAAQ7E,GAAK,GAAM,EAAIA,GAAG7B,KAAKM,IAAIN,KAAKmD,GAAGtB,GAAM,EAAE7B,KAAKmD,GAAInD,KAAKO,IAAIP,KAAKmD,GAAGtB,GAAK,GAE1F,CAEA,cAAOqF,CAAQxB,GACX,MACMW,EAAIX,EAAI,EACd,OAAOlE,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAF1B,EAAU,KAGTT,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,EAAE4F,GAHD,KAGSrG,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,EAAE4F,GAHnB,KAIpCrG,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,EAAE4F,GAJ2B,KAInBrG,KAAKM,IAAI,EAAEN,KAAKmD,GAAG1C,EAAE4F,GAE7D,CAGA,aAAOc,CAAOC,EAAM1B,EAAG2B,EAAO,CAAA,GAC1B,MAAMnB,KAAEA,EAAO,IAAGK,MAAEA,EAAQ,GAAGE,MAAEA,EAAQ,IAAQY,GAAQ,GACzD,OAAQD,GACJ,IAAK,OAAQ,OAAO5B,EAAOI,KAAKF,GAChC,IAAK,UAAW,OAAOF,EAAOK,QAAQH,GACtC,IAAK,WAAY,OAAOF,EAAOM,SAASJ,GACxC,IAAK,iBAAkB,OAAOF,EAAOO,eAAeL,GACpD,IAAK,kBAAmB,OAAOF,EAAOQ,gBAAgBN,GACtD,IAAK,YACL,IAAK,OAYL,QAAS,OAAOF,EAAOC,KAAKC,GAX5B,IAAK,WAAY,OAAOF,EAAOoB,SAASlB,GACxC,IAAK,eAAgB,OAAOF,EAAOqB,aAAanB,GAChD,IAAK,SAAU,OAAOF,EAAOsB,OAAOpB,GACpC,IAAK,UAAW,OAAOF,EAAOuB,QAAQrB,GACtC,IAAK,SAAU,OAAOF,EAAOyB,OAAOvB,GACpC,IAAK,QACL,IAAK,WAAY,OAAOF,EAAOgB,MAAMd,EAAGe,GACxC,IAAK,QAAS,OAAOjB,EAAOc,MAAMZ,EAAGa,GACrC,IAAK,SAAU,OAAOf,EAAOS,OAAOP,EAAGQ,GACvC,IAAK,UACL,IAAK,UAAW,OAAOV,EAAO0B,QAAQxB,GAG9C,EAIJ,MAAMU,EAAOvE,IACT,MAAMyF,EAAKtH,KAAKD,IAAI8B,GACpB,GAAIyF,EAAK,KAAM,CACX,MAAM1C,EAAI/C,EAAI,KAAM0F,EAAK3C,EAAEA,EAC3B,OAAO,EAAI2C,GAAM,UAAYA,GAAM,UAAYA,GAAM,UAC7CA,GAAM,SAAYA,GAAM,SAAiB,SAALA,MAChD,CAAO,CACH,MAAM3C,EAAI,KAAO0C,EACjB,OAAQtH,KAAK2G,IAAIW,GAAMtH,KAAKa,KAAKyG,IAC7B,UAAa1C,GAAK,UAAaA,GAAK,UAAaA,GACjDA,GAAK,UAAaA,GAAmBA,GAAK,UAAaA,GACpC,UAAJA,EAAd,YADsB,YAD+B,aAI9D,GCvIG,MAAM4C,EACT,WAAOR,CAAKnF,GACR,OAAa,IAANA,EAAU,EAAI7B,KAAKO,IAAIP,KAAKmD,GAAKtB,IAAM7B,KAAKmD,GAAKtB,EAC5D,CAEA,mBAAO4F,CAAaC,EAAIzE,EAAIyC,GACxB,MAAMW,EAAIX,EAAI,EAAGiC,EAAOD,EAAKzE,EAC7B,OAAOzB,MAAMC,KAAK,CAAEC,OAAQgE,GAAK,CAAC/D,EAAGlB,IAAM+G,EAAQR,KAAiB,GAAXvG,EAAI4F,EAAE,GAASsB,GAC5E,EAMG,MAAMC,EAST,aAAOC,CAAOC,EAAMC,EAAU9E,EAAI+E,EAAOC,EAAS,QAC9C,MAAMvC,EAAIsC,EAAQ,EACZE,EAAM1C,EAAO2B,OAAOc,EAAQvC,GAC5BW,EAAIX,EAAI,EACRyC,EAAYrG,GAAMA,EAAEuD,IAAI,CAACH,EAAGtE,IAAMsE,EAAIgD,EAAItH,IAEhD,GAAa,YAATkH,EAAoB,CACpB,MAAMJ,EAAE,EACR,IAAI5F,EAAI0F,EAAQC,aAAaC,EAAIzE,EAAIyC,GACrC,MAAMhG,EAAQ,EAAIgI,EAAKzE,EAEvB,OADAnB,EAAIA,EAAEuD,IAAIH,GAAKA,EAAIxF,GACZ,CAAEH,EAAG4I,EAASrG,GAAIxC,EAAG,CAAC,GACjC,CACA,GAAa,aAATwI,EAAqB,CACrB,MAAMJ,EAAE,EAGR,MAAO,CAAEnI,EAFEqI,EAAYC,OAAO,UAAWH,EAAIzE,EAAI+E,EAAOC,GAAQ1I,EACnD8F,IAAI,CAACH,EAAGzE,IAAOA,IAAM4F,EAAE,EAAI,EAAInB,GAAKA,GACrC5F,EAAG,CAAC,GACpB,CACA,GAAa,aAATwI,EAAqB,CACrB,MAAOM,EAAIC,GAAG,EACRC,EAAMV,EAAYC,OAAO,UAAWQ,EAAIpF,EAAI+E,EAAOC,GAAQ1I,EAC3DgJ,EAAMX,EAAYC,OAAO,UAAWO,EAAInF,EAAI+E,EAAOC,GAAQ1I,EAEjE,MAAO,CAAEA,EADC+I,EAAIjD,IAAI,CAACH,EAAGtE,IAAMsE,EAAIqD,EAAI3H,IACxBtB,EAAG,CAAC,GACpB,CACA,GAAa,aAATwI,EAAqB,CACrB,MAAOM,EAAIC,GAAG,EAGd,MAAO,CAAE9I,EAFEqI,EAAYC,OAAO,WAAY,CAACO,EAAIC,GAAKpF,EAAI+E,EAAOC,GAAQ1I,EAC1D8F,IAAI,CAACH,EAAGzE,IAAOA,IAAM4F,EAAE,EAAI,EAAInB,GAAKA,GACrC5F,EAAG,CAAC,GACpB,CACA,MAAM,IAAIkJ,MAAM,uBACpB,CAEA,YAAOC,CAAMlJ,EAAGsC,GACZ,OAAOd,EAAKa,SAASC,EAAGtC,EAC5B,CAEA,iBAAOmJ,CAAWnJ,EAAGsC,EAAG8G,GACpB,MAAMC,EAAID,GAAa,KACjBtC,EAAI9G,EAAEmC,OACNmH,EAAO9H,EAAKC,SAAS4H,EAAIvC,EAAI,GAC7ByC,EAAIvE,EAAIC,IAAIhD,MAAMC,KAAK,CAAEC,OAAQmH,GAAQ,CAAClH,EAAGf,IAAMF,EAAExB,GAAGK,EAAEqB,IAAM,EAAG,KACnEmB,EAAI,IAAIP,MAAMK,EAAEH,OAAS2E,EAAI,GAAGrE,KAAK,GAC3C,IAAK,IAAIX,EAAQ,EAAGA,EAAQQ,EAAEH,OAAQL,GAASuH,EAAG,CAC9C,MAAMG,EAAOvH,MAAMC,KAAK,CAAEC,OAAQmH,GAAQ,CAAClH,EAAGf,IAAMF,EAAExB,GAAG2C,EAAER,EAAQT,IAAM,EAAG,IAEtEoI,EADIzE,EAAIC,IAAIuE,GACN1D,IAAI,CAAC4D,EAAIlE,IAAMrE,EAAEjB,IAAIwJ,EAAIH,EAAE/D,KACjCmE,EAAO3E,EAAIY,KAAK6D,GACtB,IAAK,IAAIpI,EAAI,EAAGA,EAAIgI,EAAIvC,EAAI,EAAGzF,IAAKmB,EAAEV,EAAQT,IAAMsI,EAAKtI,GAAGzB,EAChE,CACA,OAAO4C,CACX,EC5EG,MAAMoH,EASX,+BAAOC,CAAyBtB,EAAMC,EAAU9E,EAAI+E,GAClD,GAAIA,EAAQ,EACV,MAAM,IAAIQ,MAAM,sBAGlB,GAAIvF,GAAM,EACR,MAAM,IAAIuF,MAAM,uCAGlB,GAAa,YAATV,GAA+B,aAATA,EAAqB,CAE7C,GADQ,GACE,GADF,GACa7E,EAAK,EACxB,MAAM,IAAIuF,MAAM,yCAEpB,KAAO,IAAa,aAATV,GAAgC,aAATA,EAMhC,MAAM,IAAIU,MAAM,4BAA4BV,KANS,CACrD,MAAOM,EAAIC,GAAG,EACd,KAAMD,EAAK,GAAKC,EAAKD,GAAMC,EAAKpF,EAAK,GACnC,MAAM,IAAIuF,MAAM,sDAEpB,CAEA,CACF,CAYA,oBAAOa,CAAcvB,EAAM7E,EAAIqG,EAAWC,EAAaC,GAErD,MAAMC,EAAW,GAEXC,EAAQ3I,EAAKqC,eAAekG,GAClC,IAAK,MAAMzG,KAAQ6G,EAAO,CACxB,MAAOC,EAAIC,GAAsB,IAAhB/G,EAAKnB,OAAemB,EAAO,CAACA,EAAK,GAAI,MAGtD,IAAIgH,EAAOC,EAAOC,EAUdC,EAAIC,EAAIjG,EACRN,EAAIC,EAAIC,EAEZ,GAZIgG,GACFC,EAAQ,EACRC,GAAQ,EAAKH,EAAGxK,GAChB4K,EAAQJ,EAAGxK,GAAKwK,EAAGxK,GAAKwK,EAAGvK,GAAKuK,EAAGvK,KAEnCyK,EAAQ,EAAGC,EAAQ,EAAGC,GAASJ,EAAGxK,IAOvB,YAAT2I,EACFkC,EAAKH,EACLI,EAAKH,EAAQN,EACbxF,EAAK+F,EAAQP,EAAKA,EAClB9F,EAAK,EAAGC,EAAK,EAAGC,EAAK,MAChB,IAAa,aAATkE,EAgBT,MAAM,IAAIU,MAAM,gDAdF,IAAVqB,GAEFG,EAAKD,EACLE,EAAKH,EAAQN,EACbxF,EAAK6F,EAAQL,EAAKA,EAClB9F,EAAK,EAAGC,EAAK,EAAGC,EAAK,IAGrBoG,EAAK,EACLC,EAAKF,EACL/F,EAAK8F,EAAQN,EACb9F,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAIzB,CAEA6F,EAASjG,KAAKzC,EAAK0C,kBAAkBC,EAAIC,EAAIC,EAAIoG,EAAIC,EAAIjG,EAAIf,GAC/D,CAGA,IAAIiH,EAAQ,CAAC,GAAIC,EAAQ,CAAC,GAC1B,IAAK,MAAMxK,KAAK8J,EACdS,EAAQnJ,EAAKoB,QAAQ+H,EAAOvK,EAAEJ,GAC9B4K,EAAQpJ,EAAKoB,QAAQgI,EAAOxK,EAAEL,GAGhC,MAAM8K,EAAI,EAAIrJ,EAAKkD,UAAUiG,EAAOC,EAAOZ,GAC3C,GAAIE,EAAS/H,OAAS,EAAG,CAEvB,MAAM2I,EAAOZ,EAAS/H,OAAS,EAC/B+H,EAASY,GAAM9K,EAAIkK,EAASY,GAAM9K,EAAE8F,IAAIH,GAAKA,EAAIkF,EACnD,CAGAF,EAAQ,CAAC,GAAIC,EAAQ,CAAC,GACtB,IAAK,MAAMxK,KAAK8J,EACdS,EAAQnJ,EAAKoB,QAAQ+H,EAAOvK,EAAEJ,GAC9B4K,EAAQpJ,EAAKoB,QAAQgI,EAAOxK,EAAEL,GAGhC,MAAO,CAAEC,EAAG2K,EAAO5K,EAAG6K,EAAOV,WAC/B,CASA,qBAAOa,CAAetC,KAAUuC,GAC9B,MAAM,IAAI/B,MAAM,iDAClB,CAYA,aAAOX,CAAOC,EAAMC,EAAU9E,EAAI+E,KAAUuC,GAC1C,MAAM,IAAI/B,MAAM,yCAClB,ECzIK,MAAMgC,UAA0BrB,EAOrC,qBAAOmB,CAAetC,GACpB,MAAMyC,EAAQ,GACd,IAAK,IAAI1F,EAAI,EAAGA,EAAIiD,EAAOjD,IAAK,CAC9B,MAAM1E,EAAQL,KAAKmD,IAAM,EAAI4B,EAAI,EAAIiD,IAAU,EAAIA,GAC7C7G,EAAIT,EAAExB,GAAGc,KAAKM,IAAID,GAAQL,KAAKO,IAAIF,IACrCc,EAAEhC,GAAK,GAAGsL,EAAMjH,KAAKrC,EAC3B,CACA,OAAOsJ,CACT,CAWA,wBAAOC,CAAkB5C,EAAMC,EAAU9E,EAAI+E,GAC3C,MAAMN,EAAE,EACF8B,EAAKzI,EAAKgC,QAAQ2E,EAAIzE,GACtBqG,EAAYkB,EAAkBF,eAAetC,GAC7C2C,EAAkB,YAAT7C,EAAsB,GAAI,EAEzC,OAAOqB,EAAcE,cAAcvB,EAAM7E,EAAIqG,EAAWqB,EAAOnB,EACjE,CASA,qBAAOoB,CAAe7C,EAAU9E,EAAI+E,GAClC,MAAOI,EAAIC,GAAG,EAGRwC,EAAWL,EAAkBE,kBAAkB,WAAYtC,EAAInF,EAAI+E,GAGnE8C,EAAWN,EAAkBE,kBAAkB,UAAWrC,EAAIpF,EAAI+E,GAOxE,MAAO,CAAEzI,EAJSwB,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASvL,GAI7BD,EAHLyB,EAAKoB,QAAQ0I,EAASvL,EAAGwL,EAASxL,GAGfmK,SAFZoB,EAASpB,SAAS/E,OAAOoG,EAASrB,UAG7D,CASA,qBAAOsB,CAAehD,EAAU9E,EAAI+E,GAClC,MAAOI,EAAIC,GAAG,EAGRyC,EAAWN,EAAkBE,kBAAkB,UAAWtC,EAAInF,EAAI+E,GAGlE6C,EAAWL,EAAkBE,kBAAkB,WAAYrC,EAAIpF,EAAI+E,GAKnEgD,EAAUjK,EAAKoB,QAAQ2I,EAASxL,EAAGuL,EAASvL,GAC5C2L,EAAQlK,EAAKoB,QAAQ2I,EAASvL,EAAGsL,EAASvL,GAC1C4L,EAAQnK,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASxL,GAShD,MAAO,CAAEC,EARSwB,EAAKuB,QAAQ2I,EAAOC,GAQf5L,EAAG0L,EAASvB,SALV,IACpBqB,EAASrB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,cACrDN,EAASpB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,YAI5D,CAUA,yBAAOC,CAAmBtD,EAAMC,EAAU9E,EAAI+E,GAC5C,GAAa,aAATF,EACF,OAAO0C,EAAkBI,eAAe7C,EAAU9E,EAAI+E,GACjD,GAAa,aAATF,EACT,OAAO0C,EAAkBO,eAAehD,EAAU9E,EAAI+E,GAExD,MAAM,IAAIQ,MAAM,0CAClB,CAWA,aAAOX,CAAOC,EAAMC,EAAU9E,EAAI+E,GAKhC,GAHAwC,EAAkBpB,yBAAyBtB,EAAMC,EAAU9E,EAAI+E,GAG3DA,EAAQ,GACV,MAAM,IAAIQ,MAAM,4BAA4BR,uIAI9C,GAAa,YAATF,GAA+B,aAATA,EACxB,OAAO0C,EAAkBE,kBAAkB5C,EAAMC,EAAU9E,EAAI+E,GAC1D,GAAa,aAATF,GAAgC,aAATA,EAChC,OAAO0C,EAAkBY,mBAAmBtD,EAAMC,EAAU9E,EAAI+E,GAGlE,MAAM,IAAIQ,MAAM,0BAClB,ECvIK,MAAM6C,UAAwBlC,EAUnC,yBAAOmC,CAAmBxD,EAAMC,EAAU9E,EAAI+E,EAAOuD,GAKnD,GAHAF,EAAgBjC,yBAAyBtB,EAAMC,EAAU9E,EAAI+E,GAGzDuD,GAAU,EACZ,MAAM,IAAI/C,MAAM,oCAGlB,GAAI+C,EAAS,GACX,MAAM,IAAI/C,MAAM,2DAEpB,CAQA,qBAAO8B,CAAetC,EAAOuD,GAC3B,MAAMC,EAAMxL,KAAKa,KAAKb,KAAKQ,IAAI,GAAI+K,EAAS,IAAM,GAC5ChF,EAAQvG,KAAKyL,MAAM,EAAID,GAAOxD,EAC9B0D,EAAQ1L,KAAK2L,KAAKpF,GAClBqF,EAAQ5L,KAAK6L,KAAKtF,GAElBkE,EAAQ,GACd,IAAK,IAAI1F,EAAI,EAAGA,EAAIiD,EAAOjD,IAAK,CAC9B,MAAM1E,EAAQL,KAAKmD,IAAM,EAAI4B,EAAI,IAAM,EAAIiD,GACrC7I,GAAMuM,EAAQ1L,KAAKO,IAAIF,GACvBjB,EAAKwM,EAAQ5L,KAAKM,IAAID,GACtBc,EAAIT,EAAExB,GAAGC,EAAIC,GACf+B,EAAEhC,GAAK,GAAGsL,EAAMjH,KAAKrC,EAC3B,CACA,OAAOsJ,CACT,CAWA,wBAAOC,CAAkB5C,EAAMC,EAAU9E,EAAI+E,EAAOuD,GAClD,MAAM7D,EAAE,EACF8B,EAAKzI,EAAKgC,QAAQ2E,EAAIzE,GACtBqG,EAAY+B,EAAgBf,eAAetC,EAAOuD,GAClDZ,EAAkB,YAAT7C,EAAsB,GAAI,EAEzC,OAAOqB,EAAcE,cAAcvB,EAAM7E,EAAIqG,EAAWqB,EAAOnB,EACjE,CAUA,qBAAOoB,CAAe7C,EAAU9E,EAAI+E,EAAOuD,GACzC,MAAOnD,EAAIC,GAAG,EAGRwC,EAAWQ,EAAgBX,kBAAkB,WAAYtC,EAAInF,EAAI+E,EAAOuD,GAGxET,EAAWO,EAAgBX,kBAAkB,UAAWrC,EAAIpF,EAAI+E,EAAOuD,GAO7E,MAAO,CAAEhM,EAJSwB,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASvL,GAI7BD,EAHLyB,EAAKoB,QAAQ0I,EAASvL,EAAGwL,EAASxL,GAGfmK,SAFZoB,EAASpB,SAAS/E,OAAOoG,EAASrB,UAG7D,CAUA,qBAAOsB,CAAehD,EAAU9E,EAAI+E,EAAOuD,GACzC,MAAOnD,EAAIC,GAAG,EAGRyC,EAAWO,EAAgBX,kBAAkB,UAAWtC,EAAInF,EAAI+E,EAAOuD,GAGvEV,EAAWQ,EAAgBX,kBAAkB,WAAYrC,EAAIpF,EAAI+E,EAAOuD,GAKxEP,EAAUjK,EAAKoB,QAAQ2I,EAASxL,EAAGuL,EAASvL,GAC5C2L,EAAQlK,EAAKoB,QAAQ2I,EAASvL,EAAGsL,EAASvL,GAC1C4L,EAAQnK,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASxL,GAShD,MAAO,CAAEC,EARSwB,EAAKuB,QAAQ2I,EAAOC,GAQf5L,EAAG0L,EAASvB,SALV,IACpBqB,EAASrB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,cACrDN,EAASpB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,YAI5D,CAWA,yBAAOC,CAAmBtD,EAAMC,EAAU9E,EAAI+E,EAAOuD,GACnD,GAAa,aAATzD,EACF,OAAOuD,EAAgBT,eAAe7C,EAAU9E,EAAI+E,EAAOuD,GACtD,GAAa,aAATzD,EACT,OAAOuD,EAAgBN,eAAehD,EAAU9E,EAAI+E,EAAOuD,GAE7D,MAAM,IAAI/C,MAAM,0CAClB,CAWA,aAAOX,CAAOC,EAAMC,EAAU9E,EAAI+E,EAAOuD,EAAS,GAKhD,GAHAF,EAAgBC,mBAAmBxD,EAAMC,EAAU9E,EAAI+E,EAAOuD,GAG1DvD,EAAQ,GACV,MAAM,IAAIQ,MAAM,0BAA0BR,uIAI5C,GAAa,YAATF,GAA+B,aAATA,EACxB,OAAOuD,EAAgBX,kBAAkB5C,EAAMC,EAAU9E,EAAI+E,EAAOuD,GAC/D,GAAa,aAATzD,GAAgC,aAATA,EAChC,OAAOuD,EAAgBD,mBAAmBtD,EAAMC,EAAU9E,EAAI+E,EAAOuD,GAGvE,MAAM,IAAI/C,MAAM,0BAClB,ECzKK,MAAMsD,UAA6B3C,EAUxC,yBAAOmC,CAAmBxD,EAAMC,EAAU9E,EAAI+E,EAAO+D,GAKnD,GAHAD,EAAqB1C,yBAAyBtB,EAAMC,EAAU9E,EAAI+E,KAG5D+D,EAAsB,GAC1B,MAAM,IAAIvD,MAAM,wCAEpB,CASA,6BAAOwD,CAAuBhE,EAAOiE,GAEnC,MAAMC,EAAO,GAAKlM,KAAKQ,IAAI,GAAIyL,EAAK,IAAM,GACpC3M,EAAIU,KAAKyL,MAAM,EAAIzL,KAAKa,KAAKqL,IAASlE,EAEtCyC,EAAQ,GACd,IAAK,IAAI1F,EAAI,EAAGA,GAAKiD,EAAOjD,IAAK,CAC/B,MAAM1E,EAAQL,KAAKmD,IAAM,EAAI4B,EAAI,IAAM,EAAIiD,GACrC7I,GAAMa,KAAK2L,KAAKrM,GAAKU,KAAKO,IAAIF,GAC9BjB,EAAMY,KAAK6L,KAAKvM,GAAKU,KAAKM,IAAID,GACpCoK,EAAMjH,KAAK9C,EAAExB,GAAGC,EAAIC,GACtB,CAGA,MAAM+M,EAAS,GACT1H,EAAIzE,KAAKoM,MAAMpE,EAAQ,GAC7B,IAAK,IAAIjD,EAAI,EAAGA,GAAKN,EAAGM,IAAK,CAC3B,MAAM1E,EAAQL,KAAKmD,IAAM,EAAI4B,EAAI,IAAM,EAAIiD,GAC3CmE,EAAO3I,KAAK,EAAIxD,KAAKM,IAAID,GAC3B,CAEA,MAAO,CAAEoK,QAAO0B,SAClB,CAYA,sBAAOE,CAAgBvE,EAAMwE,EAAUC,EAAO/C,EAAIvG,GAEhD,IAAI4G,EAAOC,EAAOC,EAadyC,EAAOC,EAAOC,EASd1C,EAAIC,EAAIjG,EAAI2I,EAAIC,EAAIC,EArBxB,GAAwB,IAApBP,EAAS5K,OAAc,CACzB,MAAMP,EAAImL,EAAS,GACnBzC,EAAQ,EACRC,GAAQ,EAAK3I,EAAEhC,GACf4K,EAAQ5I,EAAEhC,GAAKgC,EAAEhC,GAAKgC,EAAE/B,GAAK+B,EAAE/B,EACjC,KAAO,CAGLyK,EAAQ,EAAGC,EAAQ,EAAGC,GADZuC,EAAS,GACcnN,EACnC,CA0CA,OAtCa,MAAToN,GACFC,EAAQ,EAAGC,EAAQ,EAAGC,EAAQH,EAAQA,IAGtCC,EAAQ,EAAGC,EAAQ,EAAGC,EAAQ,GAMnB,YAAT5E,GAEFkC,EAAKH,EAAcI,EAAKH,EAAQN,EAAWxF,EAAK+F,EAAQP,EAAKA,EAC7DmD,EAAKH,EAAcI,EAAKH,EAAQjD,EAAWqD,EAAKH,EAAQlD,EAAKA,IAG/C,IAAVK,GAEFG,EAAKD,EAAYE,EAAKH,EAAQN,EAAWxF,EAAK6F,EAAQL,EAAKA,IAG3DQ,EAAK,EAAYC,EAAKF,EAAmB/F,EAAK8F,EAAQN,GAI1C,IAAVgD,GAEFG,EAAKD,EAAYE,EAAKH,EAAQjD,EAAWqD,EAAKL,EAAQhD,EAAKA,GACxC,IAAViD,GAETE,EAAK,EAAYC,EAAKF,EAAmBG,EAAKJ,EAAQjD,IAGtDmD,EAAKD,EAAYE,EAAK,EAAmBC,EAAK,IAK3C9L,EAAK0C,kBAAkBkJ,EAAIC,EAAIC,EAAI7C,EAAIC,EAAIjG,EAAIf,EACxD,CAWA,iBAAO6J,CAAWhF,EAAMC,EAAU9E,EAAI+E,EAAOiE,GAC3C,MAAMzC,EAAKzI,EAAKgC,QAAQgF,EAAU9E,IAC5BwH,MAAEA,EAAK0B,OAAEA,GAAWY,KAAKf,uBAAuBhE,EAAOiE,GAGvDe,EAAYjM,EAAKqC,eAAeqH,GAGhChB,EAAW,GACjB,IAAIwD,EAAK,EACT,IAAK,MAAMpK,KAAQmK,EAAW,CAC5B,MAAME,EAAMD,EAAKd,EAAOzK,OAAUyK,EAAOc,KAAQzD,EAAK,KAChD2D,EAAMJ,KAAKV,gBAAgBvE,EAAMjF,EAAMqK,EAAI1D,EAAIvG,GACrDwG,EAASjG,KAAK2J,EAChB,CAGA,IAAI5N,EAAI,CAAC,GAAID,EAAI,CAAC,GAClB,IAAK,MAAMK,KAAK8J,EACdlK,EAAIwB,EAAKoB,QAAQ5C,EAAGI,EAAEJ,GACtBD,EAAIyB,EAAKoB,QAAQ7C,EAAGK,EAAEL,GAIxB,MAAMqL,EAAkB,YAAT7C,EAAsB,GAAI,EACnCsC,EAAI,EAAIrJ,EAAKkD,UAAU1E,EAAGD,EAAGqL,GAEnC,GAAIlB,EAAS/H,OAAQ,CACnB,MAAMkH,EAAIa,EAAS/H,OAAS,EAC5B+H,EAASb,GAAK,CAAErJ,EAAGkK,EAASb,GAAGrJ,EAAE8F,IAAIH,GAAKA,EAAIkF,GAAI9K,EAAGmK,EAASb,GAAGtJ,EAAE6L,SAEnE5L,EAAI,CAAC,GAAID,EAAI,CAAC,GACd,IAAK,MAAMK,KAAK8J,EACdlK,EAAIwB,EAAKoB,QAAQ5C,EAAGI,EAAEJ,GACtBD,EAAIyB,EAAKoB,QAAQ7C,EAAGK,EAAEL,EAE1B,CAEA,MAAO,CAAEC,IAAGD,IAAGmK,WACjB,CAKA,oBAAO2D,CAAcrF,EAAU9E,EAAI+E,EAAO+D,GACxC,OAAOgB,KAAKD,WAAW,UAAW/E,EAAU9E,EAAI+E,EAAO+D,EACzD,CAKA,qBAAOsB,CAAetF,EAAU9E,EAAI+E,EAAO+D,GACzC,OAAOgB,KAAKD,WAAW,WAAY/E,EAAU9E,EAAI+E,EAAO+D,EAC1D,CAMA,qBAAOnB,CAAe7C,EAAU9E,EAAI+E,EAAO+D,GACzC,MAAO3D,EAAIC,GAAG,EACRiF,EAAKP,KAAKM,eAAejF,EAAInF,EAAI+E,EAAO+D,GACxCwB,EAAKR,KAAKK,cAAc/E,EAAIpF,EAAI+E,EAAO+D,GAC7C,MAAO,CACLxM,EAAGwB,EAAKoB,QAAQmL,EAAG/N,EAAGgO,EAAGhO,GACzBD,EAAGyB,EAAKoB,QAAQmL,EAAGhO,EAAGiO,EAAGjO,GACzBmK,SAAU,IAAI6D,EAAG7D,YAAa8D,EAAG9D,UAErC,CAKA,qBAAOsB,CAAehD,EAAU9E,EAAI+E,EAAO+D,GACzC,MAAO3D,EAAIC,GAAG,EACRkF,EAAKR,KAAKK,cAAchF,EAAInF,EAAI+E,EAAO+D,GACvCuB,EAAKP,KAAKM,eAAehF,EAAIpF,EAAI+E,EAAO+D,GAExCzM,EAAIyB,EAAKoB,QAAQoL,EAAGjO,EAAGgO,EAAGhO,GAC1BkO,EAAOzM,EAAKoB,QAAQoL,EAAGhO,EAAG+N,EAAGhO,GAC7BmO,EAAO1M,EAAKoB,QAAQmL,EAAG/N,EAAGgO,EAAGjO,GAGnC,MAAO,CAAEC,EAFCwB,EAAKuB,QAAQkL,EAAMC,GAEjBnO,IAAGmK,SAAU,IAAI8D,EAAG9D,YAAa6D,EAAG7D,UAClD,CAKA,yBAAO2B,CAAmBtD,EAAMC,EAAU9E,EAAI+E,EAAO+D,GACnD,GAAa,aAATjE,EAAqB,OAAOiF,KAAKnC,eAAe7C,EAAU9E,EAAI+E,EAAO+D,GACzE,GAAa,aAATjE,EAAqB,OAAOiF,KAAKhC,eAAehD,EAAU9E,EAAI+E,EAAO+D,GACzE,MAAM,IAAIvD,MAAM,0CAClB,CAKA,aAAOX,CAAOC,EAAMC,EAAU9E,EAAI+E,EAAO+D,EAAsB,IAI7D,GAHAgB,KAAKzB,mBAAmBxD,EAAMC,EAAU9E,EAAI+E,EAAO+D,GAG/C/D,EAAQ,GACV,MAAM,IAAIQ,MAAM,iCAAiCR,uIAGnD,GAAa,YAATF,EAAqB,OAAOiF,KAAKK,cAAcrF,EAAU9E,EAAI+E,EAAO+D,GACxE,GAAa,aAATjE,EAAqB,OAAOiF,KAAKM,eAAetF,EAAU9E,EAAI+E,EAAO+D,GACzE,GAAa,aAATjE,GAAgC,aAATA,EACzB,OAAOiF,KAAK3B,mBAAmBtD,EAAMC,EAAU9E,EAAI+E,EAAO+D,GAC5D,MAAM,IAAIvD,MAAM,0BAClB,EC3OK,MAAMkF,UAA4BvE,EASvC,yBAAOmC,CAAmBxD,EAAMC,EAAU9E,EAAI+E,GAK5C,GAHA0F,EAAoBtE,yBAAyBtB,EAAMC,EAAU9E,EAAI+E,GAG7DA,EAAQ,EACV,MAAM,IAAIQ,MAAM,gDAIpB,CAUA,aAAOX,CAAOC,EAAMC,EAAU9E,EAAI+E,GAKhC,GAHA0F,EAAoBpC,mBAAmBxD,EAAMC,EAAU9E,EAAI+E,GAGvDA,EAAQ,GACV,MAAM,IAAIQ,MAAM,+BAA+BR,uIAIjD,MACM2F,GADa3F,EAAQ,GAAM,EAAKA,EAASA,EAAQ,GACzB,EAGxB4F,EAAapD,EAAkB3C,OAAOC,EAAMC,EAAU9E,EAAI0K,GAG1DE,EAAmBD,EAAWnE,SAAS/E,OAC3CkJ,EAAWnE,SAASpE,IAAI1F,IAAC,CACvBJ,EAAGI,EAAEJ,EAAE4L,QACP7L,EAAGK,EAAEL,EAAE6L,YAQX,MAAO,CACL5L,EAJgBwB,EAAKoB,QAAQyL,EAAWrO,EAAGqO,EAAWrO,GAKtDD,EAJgByB,EAAKoB,QAAQyL,EAAWtO,EAAGsO,EAAWtO,GAKtDmK,SAAUoE,EAEd,CASA,oBAAOT,CAAcrF,EAAU9E,EAAI+E,GACjC,OAAO0F,EAAoB7F,OAAO,UAAWE,EAAU9E,EAAI+E,EAC7D,CASA,qBAAOqF,CAAetF,EAAU9E,EAAI+E,GAClC,OAAO0F,EAAoB7F,OAAO,WAAYE,EAAU9E,EAAI+E,EAC9D,CASA,qBAAO4C,CAAe7C,EAAU9E,EAAI+E,GAClC,MAAOI,EAAIC,GAAG,EAGRwC,EAAW6C,EAAoB7F,OAAO,WAAYO,EAAInF,EAAI+E,GAG1D8C,EAAW4C,EAAoB7F,OAAO,UAAWQ,EAAIpF,EAAI+E,GAO/D,MAAO,CAAEzI,EAJSwB,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASvL,GAI7BD,EAHLyB,EAAKoB,QAAQ0I,EAASvL,EAAGwL,EAASxL,GAGfmK,SAFZoB,EAASpB,SAAS/E,OAAOoG,EAASrB,UAG7D,CASA,qBAAOsB,CAAehD,EAAU9E,EAAI+E,GAClC,MAAOI,EAAIC,GAAG,EAGRyC,EAAW4C,EAAoB7F,OAAO,UAAWO,EAAInF,EAAI+E,GAGzD6C,EAAW6C,EAAoB7F,OAAO,WAAYQ,EAAIpF,EAAI+E,GAK1DgD,EAAUjK,EAAKoB,QAAQ2I,EAASxL,EAAGuL,EAASvL,GAC5C2L,EAAQlK,EAAKoB,QAAQ2I,EAASvL,EAAGsL,EAASvL,GAC1C4L,EAAQnK,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASxL,GAShD,MAAO,CAAEC,EARSwB,EAAKuB,QAAQ2I,EAAOC,GAQf5L,EAAG0L,EAASvB,SALV,IACpBqB,EAASrB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,cACrDN,EAASpB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,YAI5D,CAOA,qBAAO2C,CAAeC,GACpB,OAAQA,EAAiB,GAAM,EAAKA,EAAkBA,EAAiB,CACzE,CAOA,mBAAOC,CAAahG,GAClB,OAAO0F,EAAoBI,eAAe9F,GAAS,CACrD,CAOA,0BAAOiG,CAAoBjG,GAEzB,OAAmB,EADD0F,EAAoBM,aAAahG,EAErD,CAMA,2BAAOkG,GACL,MAAO,CACLC,MAAO,EACPC,SAAU,EACVC,KAAM,EACNC,QAAS,EACTC,aAAc,GAElB,CAOA,wBAAOC,CAAkBxG,GACvB,OAAIA,EAAQ,EACH,EAEDA,EAAQ,GAAM,EAAKA,EAASA,EAAQ,CAC9C,CAOA,oBAAOyG,CAAczG,GACnB,MAAM0G,EAAchB,EAAoBI,eAAe9F,GACjD2F,EAAYD,EAAoBM,aAAahG,GAGnD,MAAO,CACL+F,eAAgB/F,EAChB0G,YAAaA,EACbf,UAAWA,EACXlE,SANeiE,EAAoBO,oBAAoBjG,GAOvD2G,WAAY3G,IAAU0G,EACtBE,YAAa,kBAAkBF,cAAwBf,wCAE3D,EC3NK,MAAMkB,UAAuB1F,EAYhC,aAAOtB,CAAOC,EAAMC,EAAU9E,EAAI+E,EAAO8G,EAAiB,EAAG/C,EAAsB,IAE/E,GAAI/D,EAAQ,GACR,MAAM,IAAIQ,MAAM,yBAAyBR,uIAG7C,OAAQF,GACJ,IAAK,UACD,OAAOiF,KAAKK,cAAcrF,EAAU9E,EAAI+E,EAAO8G,EAAgB/C,GACnE,IAAK,WACD,OAAOgB,KAAKM,eAAetF,EAAU9E,EAAI+E,EAAO8G,EAAgB/C,GACpE,IAAK,WACD,GAAIvK,MAAMuN,QAAQhH,IAAiC,IAApBA,EAASrG,OACpC,OAAOqL,KAAKnC,eAAe7C,EAAS,GAAIA,EAAS,GAAI9E,EAAI+E,EAAO8G,EAAgB/C,GAEpF,MAAM,IAAIvD,MAAM,yDACpB,IAAK,WACD,GAAIhH,MAAMuN,QAAQhH,IAAiC,IAApBA,EAASrG,OACpC,OAAOqL,KAAKhC,eAAehD,EAAS,GAAIA,EAAS,GAAI9E,EAAI+E,EAAO8G,EAAgB/C,GAEpF,MAAM,IAAIvD,MAAM,yDACpB,QACI,MAAM,IAAIA,MAAM,4BAA4BV,KAExD,CAWA,oBAAOsF,CAAcrF,EAAU9E,EAAI+E,EAAO8G,EAAgB/C,GAEtD,MAAMvC,EAAKzI,EAAKgC,QAAQgF,EAAU9E,IAG5BwH,MAAEA,EAAKuE,MAAEA,GAAUjC,KAAKkC,+BAA+BjH,EAAO8G,EAAgB/C,GAGpF,OAAOgB,KAAK1D,cAAc,UAAWpG,EAAIwH,EAAO,EAAGjB,EACvD,CAWA,qBAAO6D,CAAetF,EAAU9E,EAAI+E,EAAO8G,EAAgB/C,GAEvD,MAAMvC,EAAKzI,EAAKgC,QAAQgF,EAAU9E,IAG5BwH,MAAEA,EAAKuE,MAAEA,GAAUjC,KAAKkC,+BAA+BjH,EAAO8G,EAAgB/C,GAG9EmD,EAAmBzE,EAAMpF,IAAIlE,GAAKT,EAAEb,IAAIa,EAAExB,GAAG,EAAG,GAAIiC,IAE1D,OAAO4L,KAAK1D,cAAc,WAAYpG,EAAIiM,GAAkB,EAAI1F,EACpE,CAYA,qBAAOoB,CAAeuE,EAAaC,EAAcnM,EAAI+E,EAAO8G,EAAgB/C,GAExE,MAAMlB,EAAWkC,KAAKM,eAAe8B,EAAalM,EAAI+E,EAAO8G,EAAgB/C,GAGvEjB,EAAWiC,KAAKK,cAAcgC,EAAcnM,EAAI+E,EAAO8G,EAAgB/C,GAO7E,MAAO,CAAExM,EAJSwB,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASvL,GAI7BD,EAHLyB,EAAKoB,QAAQ0I,EAASvL,EAAGwL,EAASxL,GAGfmK,SAFZoB,EAASpB,SAAS/E,OAAOoG,EAASrB,UAG/D,CAYA,qBAAOsB,CAAeoE,EAAaC,EAAcnM,EAAI+E,EAAO8G,EAAgB/C,GAExE,MAAMjB,EAAWiC,KAAKK,cAAc+B,EAAalM,EAAI+E,EAAO8G,EAAgB/C,GAGtElB,EAAWkC,KAAKM,eAAe+B,EAAcnM,EAAI+E,EAAO8G,EAAgB/C,GAKxEf,EAAUjK,EAAKoB,QAAQ2I,EAASxL,EAAGuL,EAASvL,GAC5C2L,EAAQlK,EAAKoB,QAAQ2I,EAASvL,EAAGsL,EAASvL,GAC1C4L,EAAQnK,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASxL,GAShD,MAAO,CAAEC,EARSwB,EAAKuB,QAAQ2I,EAAOC,GAQf5L,EAAG0L,EAASvB,SALV,IAClBqB,EAASrB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,cACrDN,EAASpB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,YAIhE,CASA,qCAAO8D,CAA+BjH,EAAO8G,EAAgB/C,GAEzD,MAAMsD,EAAUrP,KAAKa,KAAKb,KAAKQ,IAAI,GAAIsO,EAAiB,IAAM,GACxDQ,EAAItP,KAAKQ,IAAI,GAAIuL,EAAsB,IAGvCwD,EAAKF,EAAUrP,KAAKa,KAAKyO,EAAIA,EAAI,GAGjCvK,EAAIgI,KAAKyC,yBAAyBD,EAAIvH,GAGtCjE,EAAIgJ,KAAK0C,yBAAyB1K,GACzBgI,KAAK0C,yBAAyBzP,KAAKa,KAAK,EAAIkE,EAAIA,IAG/D,MAAM0F,EAAQ,GACRuE,EAAQ,GAEd,IAAK,IAAIpO,EAAI,EAAGA,GAAKZ,KAAKoM,MAAMpE,EAAQ,GAAIpH,IAAK,CAC7C,MAAMqE,GAAK,EAAIrE,EAAI,GAAKmD,EAAIiE,EACtB0H,EAAK3C,KAAK4C,SAAS1K,EAAGF,GAKtB6K,GAAQF,EAJH3C,KAAK8C,SAAS5K,EAAGF,IAIH,EAAI2K,EAAKA,GAC5BI,EAJK/C,KAAKgD,SAAS9K,EAAGF,IAIT,EAAI2K,EAAKA,GAC5BjF,EAAMjH,KAAK9C,EAAExB,GAAG0Q,EAAME,IACtBrF,EAAMjH,KAAK9C,EAAExB,GAAG0Q,GAAOE,IAGvB,MAAME,EAAW,GAAKjL,EAAI2K,GACpBO,EAAW,EACjBjB,EAAMxL,KAAK9C,EAAExB,GAAG8Q,EAAUC,IAC1BjB,EAAMxL,KAAK9C,EAAExB,GAAG8Q,GAAWC,GAC/B,CAGA,GAAIjI,EAAQ,GAAM,EAAG,CACjB,MAAM/C,EAAIlB,EAAIiE,EACR0H,EAAK3C,KAAK4C,SAAS1K,EAAGF,GAC5B0F,EAAMjH,KAAK9C,EAAExB,IAAIwQ,EAAI,IACrBV,EAAMxL,KAAK9C,EAAExB,GAAG,GAAK6F,EAAI2K,GAAK,GAClC,CAEA,MAAO,CAAEjF,QAAOuE,QACpB,CAQA,+BAAOQ,CAAyBD,EAAIvH,GAGhC,MAAMzE,EAAIvD,KAAK2G,KAAK3G,KAAKmD,GAAK4J,KAAK0C,yBAAyBzP,KAAKa,KAAK,EAAI0O,EAAKA,IAAOxC,KAAK0C,yBAAyBF,IACpH,IAAIxK,EAAI/E,KAAKa,KAAK0C,GAGlB,IAAK,IAAI3C,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAKzBmE,IAJUgI,KAAK0C,yBAAyB1K,GACzBgI,KAAK0C,yBAAyBzP,KAAKa,KAAK,EAAIkE,EAAIA,IACxCiD,EAAQhI,KAAKkQ,IAAI3M,GAAKvD,KAAKmD,IACvC4J,KAAKoD,2BAA2BpL,EAE/C,CAEA,OAAOA,CACX,CAOA,+BAAO0K,CAAyB1K,GAC5B,GAAU,IAANA,EAAS,OAAO/E,KAAKmD,GAAK,EAC9B,GAAU,IAAN4B,EAAS,OAAOqL,IAGpB,IAAIC,EAAM,EACNC,EAAO,EACX,MAAMC,EAAKxL,EAAIA,EAEf,IAAK,IAAItE,EAAI,EAAGA,EAAI,MAChB6P,IAAS,EAAI7P,EAAI,IAAM,EAAIA,EAAI,GAAK8P,GAAM,EAAI9P,EAAI,EAAIA,GACtD4P,GAAOC,IACHtQ,KAAKD,IAAIuQ,GAAQ,QAHA7P,KAMzB,OAAOT,KAAKmD,GAAK,EAAIkN,CACzB,CAQA,eAAOV,CAAS1K,EAAGF,GAEf,MAAMwL,EAAKxL,EAAIA,EACf,IAAIsL,EAAM,EACNC,EAAO,EAEX,IAAK,IAAI7P,EAAI,EAAGA,EAAI,KAChB4P,GAAOC,EAAOtQ,KAAKO,KAAK,EAAIE,EAAI,GAAKwE,GACrCqL,GAAQC,IACJvQ,KAAKD,IAAIuQ,GAAQ,QAHD7P,KAMxB,OAAO4P,CACX,CAQA,eAAOR,CAAS5K,EAAGF,GACf,MAAM2K,EAAK3C,KAAK4C,SAAS1K,EAAGF,GAC5B,OAAO/E,KAAKa,KAAK,EAAI6O,EAAKA,EAC9B,CAQA,eAAOK,CAAS9K,EAAGF,GACf,MAAM2K,EAAK3C,KAAK4C,SAAS1K,EAAGF,GACtBwL,EAAKxL,EAAIA,EACf,OAAO/E,KAAKa,KAAK,EAAI0P,EAAKb,EAAKA,EACnC,CAOA,iCAAOS,CAA2BpL,GAC9B,MACMyL,EAAU,EADLzL,EAAIA,EAEf,OAAOgI,KAAK0C,yBAAyB1K,IAAMA,EAAIyL,GAAWzD,KAAK0C,yBAAyBzP,KAAKa,KAAK2P,KAAazL,EAAIA,EACvH,CAMA,oCAAO0L,GACH,MAAO,CAAC,GAAK,GAAK,GAAK,EAAK,EAAK,EAAK,EAC1C,CAMA,yCAAOC,GACH,MAAO,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC5C,CASA,oCAAOC,CAA8B3I,EAAO8G,EAAgB/C,GAGxD,MAAMsD,EAAUrP,KAAKa,KAAKb,KAAKQ,IAAI,GAAIsO,EAAiB,IAAM,GACxDQ,EAAItP,KAAKQ,IAAI,GAAIuL,EAAsB,IAGvC6E,EAAgBvB,EAAUrP,KAAKQ,IAAI8O,GAAG,EAAKtH,GACjD,OAAO,GAAKhI,KAAK6Q,MAAM,EAAID,EAAgBA,EAC/C,CASA,yCAAOE,CAAmC9I,EAAO8G,EAAgB/C,GAG7D,MAAMsD,EAAUrP,KAAKa,KAAKb,KAAKQ,IAAI,GAAIsO,EAAiB,IAAM,GAIxDiC,EAHI/Q,KAAKQ,IAAI,GAAIuL,EAAsB,IAGzB/L,KAAKQ,IAAI6O,EAAS,EAAIrH,GAC1C,OAAO,GAAKhI,KAAK6Q,MAAME,EAC3B,EC1VG,MAAMC,UAAqB7H,EAU9B,aAAOtB,CAAOC,EAAMC,EAAU9E,EAAI+E,GAE9B,GAAIA,EAAQ,GACR,MAAM,IAAIQ,MAAM,uBAAuBR,uIAG3C,OAAQF,GACJ,IAAK,UACD,OAAOiF,KAAKK,cAAcrF,EAAU9E,EAAI+E,GAC5C,IAAK,WACD,OAAO+E,KAAKM,eAAetF,EAAU9E,EAAI+E,GAC7C,IAAK,WACD,GAAIxG,MAAMuN,QAAQhH,IAAiC,IAApBA,EAASrG,OACpC,OAAOqL,KAAKnC,eAAe7C,EAAS,GAAIA,EAAS,GAAI9E,EAAI+E,GAE7D,MAAM,IAAIQ,MAAM,yDACpB,IAAK,WACD,GAAIhH,MAAMuN,QAAQhH,IAAiC,IAApBA,EAASrG,OACpC,OAAOqL,KAAKhC,eAAehD,EAAS,GAAIA,EAAS,GAAI9E,EAAI+E,GAE7D,MAAM,IAAIQ,MAAM,yDACpB,QACI,MAAM,IAAIA,MAAM,4BAA4BV,KAExD,CASA,oBAAOsF,CAAcrF,EAAU9E,EAAI+E,GAE/B,MAAMwB,EAAKzI,EAAKgC,QAAQgF,EAAU9E,GAC5BwH,EAAQsC,KAAKkE,qBAAqBjJ,GAGxC,OAAO+E,KAAK1D,cAAc,UAAWpG,EAAIwH,EAAO,EAAGjB,EACvD,CASA,qBAAO6D,CAAetF,EAAU9E,EAAI+E,GAEhC,MAAMwB,EAAKzI,EAAKgC,QAAQgF,EAAU9E,GAI5BiM,EAHQnC,KAAKkE,qBAAqBjJ,GAGT3C,IAAIlE,GAAKT,EAAEb,IAAIa,EAAExB,GAAG,EAAG,GAAIiC,IAE1D,OAAO4L,KAAK1D,cAAc,WAAYpG,EAAIiM,GAAkB,EAAI1F,EACpE,CAUA,qBAAOoB,CAAeuE,EAAaC,EAAcnM,EAAI+E,GAEjD,MAAM6C,EAAWkC,KAAKM,eAAe8B,EAAalM,EAAI+E,GAGhD8C,EAAWiC,KAAKK,cAAcgC,EAAcnM,EAAI+E,GAOtD,MAAO,CAAEzI,EAJSwB,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASvL,GAI7BD,EAHLyB,EAAKoB,QAAQ0I,EAASvL,EAAGwL,EAASxL,GAGfmK,SAFZoB,EAASpB,SAAS/E,OAAOoG,EAASrB,UAG/D,CAUA,qBAAOsB,CAAeoE,EAAaC,EAAcnM,EAAI+E,GAEjD,MAAM8C,EAAWiC,KAAKK,cAAc+B,EAAalM,EAAI+E,GAG/C6C,EAAWkC,KAAKM,eAAe+B,EAAcnM,EAAI+E,GAKjDgD,EAAUjK,EAAKoB,QAAQ2I,EAASxL,EAAGuL,EAASvL,GAC5C2L,EAAQlK,EAAKoB,QAAQ2I,EAASvL,EAAGsL,EAASvL,GAC1C4L,EAAQnK,EAAKoB,QAAQ0I,EAAStL,EAAGuL,EAASxL,GAShD,MAAO,CAAEC,EARSwB,EAAKuB,QAAQ2I,EAAOC,GAQf5L,EAAG0L,EAASvB,SALV,IAClBqB,EAASrB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,cACrDN,EAASpB,SAASpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAGK,EAAEL,EAAE6L,YAIhE,CAOA,2BAAO8F,CAAqBjJ,GAGxB,MAAMkJ,EAAW,CACb,EAAG,CAACxQ,EAAExB,IAAG,EAAI,IACb,EAAG,CAACwB,EAAExB,QAAS,mBAAqBwB,EAAExB,SAAS,oBAC/C,EAAG,CAACwB,EAAExB,IAAG,kBAAoB,GAAIwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,oBACvG,EAAG,CAACwB,EAAExB,IAAG,kBAAoB,mBAAqBwB,EAAExB,uBAAuB,mBAAsBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,uBAAuB,oBACvK,EAAG,CAACwB,EAAExB,sBAAuB,GAAIwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,oBAClM,EAAG,CAACwB,EAAExB,IAAG,iBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAsBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,IAAG,mBAAoB,oBAClQ,EAAG,CAACwB,EAAExB,IAAG,kBAAoB,GAAIwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,oBAC7R,EAAG,CAACwB,EAAExB,IAAG,iBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAsBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,uBAAuB,mBAAqBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,oBAC7V,EAAG,CAACwB,EAAExB,IAAG,kBAAoB,GAAIwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,IAAG,sCAAyCwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,uBAAuB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,IAAG,mBAAoB,mBAAqBwB,EAAExB,IAAG,kBAAoB,mBAAoBwB,EAAExB,uBAAuB,oBACxX,GAAI,CAACwB,EAAExB,qBAAuB,mBAAqBwB,EAAExB,sBAAuB,mBAAsBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,uBAAuB,mBAAqBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,uBAAuB,mBAAqBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,uBAAuB,mBAAqBwB,EAAExB,sBAAuB,mBAAoBwB,EAAExB,uBAAuB,qBAG7b,OAAIgS,EAASlJ,GACFkJ,EAASlJ,GAIb+E,KAAKoE,8BAA8BnJ,EAC9C,CAOA,oCAAOmJ,CAA8BnJ,GAIjC,MAAMyC,EAAQ,GAGd,GAAIzC,EAAQ,GAAM,EACd,IAAK,IAAIpH,EAAI,EAAGA,EAAIoH,EAAQ,EAAGpH,IAAK,CAChC,MAAMwQ,GAAS,EAAIxQ,EAAI,GAAKZ,KAAKmD,IAAM,EAAI6E,GACrC4H,GAAQ5P,KAAKM,IAAI8Q,GACjBtB,EAAO9P,KAAKO,IAAI6Q,GACtB3G,EAAMjH,KAAK9C,EAAExB,GAAG0Q,EAAME,IACtBrF,EAAMjH,KAAK9C,EAAExB,GAAG0Q,GAAOE,GAC3B,KACG,CAEHrF,EAAMjH,KAAK9C,EAAExB,IAAG,EAAI,IACpB,IAAK,IAAI0B,EAAI,EAAGA,GAAKoH,EAAQ,GAAK,EAAGpH,IAAK,CACtC,MAAMwQ,GAAS,EAAIxQ,EAAI,GAAKZ,KAAKmD,IAAM,EAAI6E,GACrC4H,GAAQ5P,KAAKM,IAAI8Q,GACjBtB,EAAO9P,KAAKO,IAAI6Q,GACtB3G,EAAMjH,KAAK9C,EAAExB,GAAG0Q,EAAME,IACtBrF,EAAMjH,KAAK9C,EAAExB,GAAG0Q,GAAOE,GAC3B,CACJ,CAEA,OAAOrF,CACX,CAOA,gCAAO4G,CAA0BrJ,GAI7B,GAAc,IAAVA,EAAa,MAAO,CAAC,GACzB,GAAc,IAAVA,EAAa,MAAO,CAAC,EAAG,GAE5B,IAAIsJ,EAAc,CAAC,GACfC,EAAc,CAAC,EAAG,GAEtB,IAAK,IAAI9Q,EAAI,EAAGA,GAAKuH,EAAOvH,IAAK,CAC7B,MAAM+Q,EAAM,IAAIhQ,MAAMf,EAAI,GAAGuB,KAAK,GAGlC,IAAK,IAAIpB,EAAI,EAAGA,EAAI2Q,EAAY7P,OAAQd,IACpC4Q,EAAI5Q,KAAO,EAAIH,EAAI,GAAK8Q,EAAY3Q,GAIxC,IAAK,IAAIA,EAAI,EAAGA,EAAI0Q,EAAY5P,OAAQd,IACpC4Q,EAAI5Q,EAAI,IAAM0Q,EAAY1Q,GAG9B0Q,EAAcC,EACdA,EAAcC,CAClB,CAEA,OAAOD,CACX,CAMA,2BAAOrD,GACH,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACvC,CASA,0BAAOuD,CAAoBzJ,EAAO0J,EAAWzO,GAOzC,MAAM0O,EAAa3J,GAAS,EAAIhI,KAAKmD,GAAKuO,GAE1C,OAAO1R,KAAKwC,IAAI,EAAGmP,EACvB,CAOA,yBAAOC,CAAmB5J,GActB,MAbwB,CACpB,EAAG,CAAE2J,WAAY,EAAKE,SAAS,EAAIC,MAAO,UAC1C,EAAG,CAAEH,WAAY,IAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,EAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,IAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,EAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,IAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,EAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,IAAKE,SAAS,GAAKC,MAAO,UAC3C,EAAG,CAAEH,WAAY,EAAKE,SAAS,GAAKC,MAAO,UAC3C,GAAI,CAAEH,WAAY,IAAKE,SAAS,GAAKC,MAAO,WAGzB9J,IAAU,CAAE2J,WAAoB,GAAR3J,EAAa6J,SAAS,EAAK7J,EAAO8J,MAAO,SAC5F,ECtQG,MAAMC,EAeX,oBAAO1I,CAAcvB,EAAM7E,EAAIqG,EAAWC,EAAaC,GACrD,OAAOL,EAAcE,cAAcvB,EAAM7E,EAAIqG,EAAWC,EAAaC,EACvE,CAYA,kBAAOwI,CAAYlK,EAAMC,EAAU9E,EAAI+E,GACrC,OAAOwC,EAAkB3C,OAAOC,EAAMC,EAAU9E,EAAI+E,EACtD,CAWA,aAAOiK,CAAOnK,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAK,GAC5C,OAAO7G,EAAgBxD,OAAOC,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAC3D,CAWA,aAAOC,CAAOrK,EAAMC,EAAU9E,EAAI+E,EAAOiE,EAAK,IAC5C,OAAOH,EAAqBjE,OAAOC,EAAMC,EAAU9E,EAAI+E,EAAOiE,EAChE,CAUA,oBAAOmG,CAActK,EAAMC,EAAU9E,EAAIoP,EAAY,GACnD,OAAO3E,EAAoB7F,OAAOC,EAAMC,EAAU9E,EAAIoP,EACxD,CAYA,eAAOC,CAASxK,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAK,EAAGjG,EAAK,IACtD,OAAO4C,EAAehH,OAAOC,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAIjG,EAC9D,CAUA,aAAOsG,CAAOzK,EAAMC,EAAU9E,EAAI+E,GAChC,OAAOgJ,EAAanJ,OAAOC,EAAMC,EAAU9E,EAAI+E,EACjD,EC5GK,MAAMwK,EAET,aAAOC,CAAOlT,EAAGD,EAAGoT,GAChB,MAAMC,EAAOjS,EAAEb,IAAIa,EAAExB,GAAG,EAAE,GAAIwT,GACxBlS,EAAOuE,IACT,IAAI5D,EAAIT,EAAExB,GAAG,EAAE,GACf,IAAK,IAAI0B,EAAI,EAAGA,EAAImE,EAAGnE,IAAKO,EAAIT,EAAEjB,IAAI0B,EAAGwR,GACzC,OAAOxR,GAEX,IAAIyR,EAAMlS,EAAExB,GAAG,EAAE,GACjB,IAAK,IAAI6F,EAAI,EAAGA,EAAIxF,EAAEmC,OAAQqD,IAAK6N,EAAMlS,EAAErB,IAAIuT,EAAKlS,EAAEhB,MAAMc,EAAIuE,GAAIxF,EAAEwF,KACtE,IAAI8N,EAAMnS,EAAExB,GAAG,EAAE,GACjB,IAAK,IAAI6F,EAAI,EAAGA,EAAIzF,EAAEoC,OAAQqD,IAAK8N,EAAMnS,EAAErB,IAAIwT,EAAKnS,EAAEhB,MAAMc,EAAIuE,GAAIzF,EAAEyF,KACtE,OAAOrE,EAAEb,IAAI+S,EAAKC,EACtB,CAGA,YAAOC,CAAMvT,EAAGD,EAAGoG,EAAI,KACnB,MAAMV,EAAIjE,EAAKK,SAAS,EAAGpB,KAAKmD,GAAIuC,GAC9BqN,EAAI/N,EAAEK,IAAI2N,GAAMR,EAAQC,OAAOlT,EAAGD,EAAGoB,EAAEN,KAAK4S,KAC5CC,EAAMF,EAAE1N,IAAI3E,EAAEX,KACd+R,EAAQiB,EAAE1N,IAAI3E,EAAER,KACtB,MAAO,CAAE8E,IAAG+N,IAAGE,MAAKnB,QACxB,CAEA,iBAAOH,CAAWpS,EAAGD,EAAGoG,EAAI,KACxB,MAAMV,EAAEA,EAAC8M,MAAEA,GAAUU,EAAQM,MAAMvT,EAAGD,EAAGoG,GACnCwN,EAAY,IAAIpB,GACtB,IAAK,IAAIlR,EAAI,EAAGA,EAAIsS,EAAUxR,OAAQd,IAAK,CACvC,IAAId,EAAIoT,EAAUtS,GAAKsS,EAAUtS,EAAE,GACnC,KAAOd,EAAIE,KAAKmD,IAAM+P,EAAUtS,IAAM,EAAEZ,KAAKmD,GAAIrD,GAAK,EAAEE,KAAKmD,GAC7D,KAAOrD,GAAKE,KAAKmD,IAAM+P,EAAUtS,IAAM,EAAEZ,KAAKmD,GAAIrD,GAAK,EAAEE,KAAKmD,EAClE,CACA,MAAMgQ,EAAKnO,EAAE,GAAKA,EAAE,GAGpB,MAAO,CAAEA,IAAGoO,GAFDF,EAAU7N,IAAI,CAAC1D,EAAGf,IAAa,IAANA,GAAWA,IAAMsS,EAAUxR,OAAS,EAAK,IACrEwR,EAAUtS,EAAE,GAAKsS,EAAUtS,EAAE,KAAO,EAAEuS,IAElD,CAEA,eAAOE,GACH,OAAO,CACX,EC9CG,MAAMC,EACT,WAAAC,CAAYhU,EAAGD,EAAI,CAAC,GAAImK,EAAW,IAS/B,GARIzJ,KAAKD,IAAIT,EAAE,GAAK,GAAK,QACrBC,EAAIA,EAAE8F,IAAIH,GAAKA,EAAI5F,EAAE,IACrBA,EAAIA,EAAE+F,IAAIH,GAAKA,EAAI5F,EAAE,KAEzByN,KAAKxN,EAAIA,EAAE4L,QACX4B,KAAKzN,EAAIA,EAAE6L,QACX4B,KAAKtD,UAAYA,GAAY,IAAIpE,IAAI1F,IAAC,CAAOJ,EAAGI,EAAEJ,EAAE4L,QAAS7L,EAAG,CAAC,EAAGK,EAAEL,EAAE,GAAIK,EAAEL,EAAE,OAE5EyN,KAAKtD,SAAS/H,OAAS,EACvBqL,KAAKyG,UAAYzG,KAAKtD,SAASpE,IAAI,KAAA,CAASoO,GAAI,EAAGC,GAAI,UACpD,GAAsB,IAAlB3G,KAAKzN,EAAEoC,OACdqL,KAAK4G,QAAU,EACf5G,KAAK6G,QAAU,IAAIpS,MAAMuL,KAAKxN,EAAEmC,QAAQM,KAAK,OAC1C,CACH,MAAM0D,EAAI1F,KAAKwC,IAAIuK,KAAKxN,EAAEmC,OAAQqL,KAAKzN,EAAEoC,QAAU,EACnDqL,KAAK8G,MAAQ,IAAIrS,MAAMkE,GAAG1D,KAAK,EACnC,CACJ,CAEA,KAAA8R,GACQ/G,KAAKyG,WAAWzG,KAAKyG,UAAUO,QAAQpU,IAAOA,EAAE8T,GAAK,EAAG9T,EAAE+T,GAAK,IAC/D3G,KAAK6G,UAAS7G,KAAK6G,QAAQ5R,KAAK,GAAI+K,KAAK4G,QAAU,GACnD5G,KAAK8G,OAAO9G,KAAK8G,MAAM7R,KAAK,EACpC,CAEA,aAAAgS,CAAcnS,GACV,GAAIkL,KAAKtD,SAAS/H,OAAS,EAAG,CAC1B,IAAIwD,EAAIrD,EACR,IAAK,IAAIjB,EAAI,EAAGA,EAAImM,KAAKtD,SAAS/H,OAAQd,IAAK,CAC3C,MAAMrB,EAAEA,EAACD,EAAEA,GAAMyN,KAAKtD,SAAS7I,GACzBqT,EAAKlH,KAAKyG,UAAU5S,GACpBsT,EAAKhP,EAAI5F,EAAE,GAAG2U,EAAGR,GAAKnU,EAAE,GAAG2U,EAAGP,GAC9BS,EAAK5U,EAAE,GAAG2U,EAAK3U,EAAE,GAAG0U,EAAGR,GAAKlU,EAAE,GAAG0U,EAAGP,GAC1CO,EAAGP,GAAKO,EAAGR,GAAIQ,EAAGR,GAAKS,EACvBhP,EAAIiP,CACR,CACA,OAAOjP,CACX,CAEA,GAAsB,IAAlB6H,KAAKzN,EAAEoC,OAAc,CACrBqL,KAAK6G,QAAQ7G,KAAK4G,SAAW9R,EAC7B,IAAIE,EAAI,EAAGqS,EAAMrH,KAAK4G,QACtB,IAAK,IAAI5O,EAAI,EAAGA,EAAIgI,KAAKxN,EAAEmC,OAAQqD,IAC/BhD,GAAKgL,KAAKxN,EAAEwF,GAAKgI,KAAK6G,QAAQQ,GAC9BA,GAAOA,EAAM,EAAIrH,KAAK6G,QAAQlS,QAAUqL,KAAK6G,QAAQlS,OAGzD,OADAqL,KAAK4G,SAAW5G,KAAK4G,QAAU,GAAK5G,KAAK6G,QAAQlS,OAC1CK,CACX,CAEA,IAAIsS,EAAKxS,EACT,IAAK,IAAIkD,EAAI,EAAGA,EAAIgI,KAAKzN,EAAEoC,OAAQqD,IAAKsP,GAAMtH,KAAKzN,EAAEyF,IAAMgI,KAAK8G,MAAM9O,EAAE,IAAM,GAC9E,IAAIuP,EAAKvH,KAAKxN,EAAE,GAAG8U,EACnB,IAAK,IAAItP,EAAI,EAAGA,EAAIgI,KAAKxN,EAAEmC,OAAQqD,IAAKuP,IAAOvH,KAAK8G,MAAM9O,EAAE,IAAM,GAAKgI,KAAKxN,EAAEwF,GAC9E,IAAK,IAAIA,EAAIgI,KAAK8G,MAAMnS,OAAO,EAAGqD,EAAI,EAAGA,IAAKgI,KAAK8G,MAAM9O,GAAKgI,KAAK8G,MAAM9O,EAAE,GAE3E,OADAgI,KAAK8G,MAAM,GAAKQ,EACTC,CACX,CAEA,WAAAC,CAAY1S,GACR,MAAME,EAAI,IAAIP,MAAMK,EAAEH,QACtB,IAAK,IAAId,EAAE,EAAEA,EAAEiB,EAAEH,OAAOd,IAAKmB,EAAEnB,GAAKmM,KAAKiH,cAAcnS,EAAEjB,IACzD,OAAOmB,CACX,CAEA,iBAAAyS,CAAkBvR,EAAIyC,EAAI,MACtB,MAAM+O,EAAKjC,EAAQM,MAAM/F,KAAKxN,EAAGwN,KAAKzN,EAAGoG,GAEzC,MAAO,CAAEgP,EADCD,EAAGzP,EAAEK,IAAIL,GAAKA,EAAI/B,GAAM,EAAEjD,KAAKmD,KAC7B8P,IAAKwB,EAAGxB,IAAKnB,MAAO2C,EAAG3C,MAAOiB,EAAG0B,EAAG1B,EACpD,CAEA,MAAA4B,GACI,MAAO,CAAEpV,EAAGwN,KAAKxN,EAAE4L,QAAS7L,EAAGyN,KAAKzN,EAAE6L,QAC1C,CAEA,aAAOyJ,CAAOrV,EAAED,GACZ,OAAO,IAAIgU,EAAO/T,EAAED,EACxB,CAEA,gBAAOuV,CAAU/M,EAAMC,EAAU9E,EAAI+E,EAAOC,EAAO,QAC/C,MAAM6M,EAAKlN,EAAYC,OAAOC,EAAMC,EAAU9E,EAAI+E,EAAOC,GACzD,OAAO,IAAIqL,EAAOwB,EAAGvV,EAAGuV,EAAGxV,EAC/B,CAEA,mBAAOyV,CAAajN,EAAMC,EAAU9E,EAAI+E,GACpC,MAAMrH,EAASoR,EAAYC,YAAYlK,EAAMC,EAAU9E,EAAI+E,GAC3D,OAAO,IAAIsL,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,CAEA,mBAAOuL,CAAalN,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAG,GAC9C,MAAMvR,EAASoR,EAAYE,OAAOnK,EAAMC,EAAU9E,EAAI+E,EAAOkK,GAC7D,OAAO,IAAIoB,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,CAEA,mBAAOwL,CAAanN,EAAMC,EAAU9E,EAAI+E,EAAOiE,EAAK,IAChD,MAAMtL,EAASoR,EAAYI,OAAOrK,EAAMC,EAAU9E,EAAI+E,EAAOiE,GAC7D,OAAO,IAAIqH,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,CAEA,0BAAOyL,CAAoBpN,EAAMC,EAAU9E,EAAIoP,EAAY,GACvD,MAAM1R,EAASoR,EAAYK,cAActK,EAAMC,EAAU9E,EAAIoP,GAC7D,OAAO,IAAIiB,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,CAEA,qBAAO0L,CAAerN,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAK,EAAGjG,EAAK,IAC1D,MAAMtL,EAASoR,EAAYO,SAASxK,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAIjG,GACnE,OAAO,IAAIqH,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,CAEA,mBAAO2L,CAAatN,EAAMC,EAAU9E,EAAI+E,GACpC,MAAMrH,EAASoR,EAAYQ,OAAOzK,EAAMC,EAAU9E,EAAI+E,GACtD,OAAO,IAAIsL,EAAO3S,EAAOpB,EAAGoB,EAAOrB,EAAGqB,EAAO8I,SACjD,EChFQ,MAAC4L,EAAM,CACfxN,OAAQ,CAACC,EAAMC,EAAU9E,EAAI+E,EAAOC,EAAO,SAChCL,EAAYC,OAAOC,EAAMC,EAAU9E,EAAI+E,EAAOC,GAEzDQ,MAAO,CAAClJ,EAAGsC,IACA+F,EAAYa,MAAMlJ,EAAGsC,GAEhC6G,WAAY,CAACnJ,EAAEsC,EAAE8G,IACNf,EAAYc,WAAWnJ,EAAEsC,EAAE8G,IAI7B2M,EAAM,CACftD,YAAa,CAAClK,EAAMC,EAAU9E,EAAI+E,KAC9B,MAAMrH,EAASoR,EAAYC,YAAYlK,EAAMC,EAAU9E,EAAI+E,GAC3D,MAAO,CAAEzI,EAAGoB,EAAOpB,EAAGD,EAAGqB,EAAOrB,IAEpC2S,OAAQ,CAACnK,EAAMC,EAAU9E,EAAI+E,EAAOkK,EAAG,KACnC,MAAMvR,EAASoR,EAAYE,OAAOnK,EAAMC,EAAU9E,EAAI+E,EAAOkK,GAC7D,MAAO,CAAE3S,EAAGoB,EAAOpB,EAAGD,EAAGqB,EAAOrB,IAEpC6S,OAAQ,CAACrK,EAAMC,EAAU9E,EAAI+E,EAAOiE,EAAG,MACnC,MAAMtL,EAASoR,EAAYI,OAAOrK,EAAMC,EAAU9E,EAAI+E,EAAOiE,GAC7D,MAAO,CAAE1M,EAAGoB,EAAOpB,EAAGD,EAAGqB,EAAOrB,IAEpC8S,cAAe,CAACtK,EAAMC,EAAU9E,EAAIoP,EAAU,KAC1C,MAAM1R,EAASoR,EAAYK,cAActK,EAAMC,EAAU9E,EAAIoP,GAC7D,MAAO,CAAE9S,EAAGoB,EAAOpB,EAAGD,EAAGqB,EAAOrB,IAEpCmJ,MAAO,CAAClJ,EAAGD,EAAGuC,IACHyR,EAAOsB,OAAOrV,EAAED,GAAGiV,YAAY1S,IAIjC0T,EAAI,CACb9C,OAAQ,CAAClT,EAAED,EAAEoT,IAAMF,EAAQC,OAAOlT,EAAED,EAAEoT,GACtCI,MAAO,CAACvT,EAAED,EAAEoG,EAAE,MAAQ8M,EAAQM,MAAMvT,EAAED,EAAEoG,GACxCiM,WAAY,CAACpS,EAAED,EAAEoG,EAAE,MAAQ8M,EAAQb,WAAWpS,EAAED,EAAEoG,GAClD2N,SAAU,IAAMb,EAAQa,YAI5B,IAAAmC,EAAe,CAEXvW,aAAYyB,IACZK,OAAMwD,MAAKiB,SAAQgC,UACnBI,cAAamK,cACbS,UAASc,SAET9I,oBAAmBa,kBAAiBS,uBAAsB4B,sBAAqBmB,iBAAgBmC,eAAc7H,gBAE7GkM,MAAKC,MAAKC"}