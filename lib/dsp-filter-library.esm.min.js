class t{static of(t=0,r=0){return{re:t,im:r}}static add(t,r){return{re:t.re+r.re,im:t.im+r.im}}static sub(t,r){return{re:t.re-r.re,im:t.im-r.im}}static mul(t,r){return{re:t.re*r.re-t.im*r.im,im:t.re*r.im+t.im*r.re}}static scale(t,r){return{re:t.re*r,im:t.im*r}}static conj(t){return{re:t.re,im:-t.im}}static div(t,r){const e=r.re*r.re+r.im*r.im||1e-300;return{re:(t.re*r.re+t.im*r.im)/e,im:(t.im*r.re-t.re*r.im)/e}}static abs(t){return Math.hypot(t.re,t.im)}static arg(t){return Math.atan2(t.im,t.re)}static expj(t){return{re:Math.cos(t),im:Math.sin(t)}}}const r=t;class e{static nextPow2(t){let r=1;for(;r<t;)r<<=1;return r}static clamp(t,r,e){return Math.min(e,Math.max(r,t))}static linspace(t,r,e){if(e<=1)return[t];const a=(r-t)/(e-1);return Array.from({length:e},(r,e)=>t+e*a)}static polyval(r,e){if("number"==typeof e){let t=0;for(let a=0;a<r.length;a++)t=t*e+r[a];return t}{let a=t.of(0,0);for(let s=0;s<r.length;s++)a=t.add(t.mul(a,e),t.of(r[s],0));return a}}static convolve(t,r){const e=new Array(t.length+r.length-1).fill(0);for(let a=0;a<t.length;a++){const s=t[a];for(let t=0;t<r.length;t++)e[a+t]+=s*r[t]}return e}static polymul(t,r){const e=t.length,a=r.length,s=new Array(e+a-1).fill(0);for(let n=0;n<e;n++)for(let e=0;e<a;e++)s[n+e]+=t[n]*r[e];return s}static polyfromroots(t){const r=new Array(t.length).fill(!1);let a=[1];for(let s=0;s<t.length;s++){if(r[s])continue;const n=t[s];let i=-1;for(let e=s+1;e<t.length;e++){if(r[e])continue;const a=t[e];if(Math.abs(n.re-a.re)<1e-12&&Math.abs(n.im+a.im)<1e-12){i=e;break}}if(Math.abs(n.im)<1e-14||i<0)a=e.polymul(a,[1,-n.re]),r[s]=!0;else{const t=[1,-2*n.re,n.re*n.re+n.im*n.im];a=e.polymul(a,t),r[s]=r[i]=!0}}return a}}class a{static fft(r){let s=r.length;if(s<=1)return r;if(s&s-1){const n=e.nextPow2(s);return a.fft(r.concat(Array.from({length:n-s},()=>t.of(0,0))))}let n=0;for(let t=1;t<s-1;t++){let e=s>>1;for(;n&e;e>>=1)n^=e;if(n^=e,t<n){const e=r[t];r[t]=r[n],r[n]=e}}for(let e=2;e<=s;e<<=1){const a=-2*Math.PI/e;for(let n=0;n<s;n+=e)for(let s=0;s<e/2;s++){const i=t.expj(a*s),o=r[n+s],c=t.mul(r[n+s+(e>>1)],i);r[n+s]=t.add(o,c),r[n+s+(e>>1)]=t.sub(o,c)}}return r}static ifft(r){const e=r.length;return a.fft(r.map(t.conj)).map(t.conj).map(r=>t.scale(r,1/e))}static rfft(r){const s=e.nextPow2(r.length),n=Array.from({length:s},(e,a)=>t.of(r[a]||0,0));return a.fft(n)}static powerSpectrum(r){return a.rfft(r).map(t.abs).map(t=>t*t)}}class s{static rect(t){return Array.from({length:t},()=>1)}static rectangle(t){return s.rect(t)}static hann(t){return Array.from({length:t},(r,e)=>.5-.5*Math.cos(2*Math.PI*e/(t-1)))}static hamming(t){return Array.from({length:t},(r,e)=>.54-.46*Math.cos(2*Math.PI*e/(t-1)))}static blackman(t){return Array.from({length:t},(r,e)=>.42-.5*Math.cos(2*Math.PI*e/(t-1))+.08*Math.cos(4*Math.PI*e/(t-1)))}static blackmanHarris(t){return Array.from({length:t},(r,e)=>.35875-.48829*Math.cos(2*Math.PI*e/(t-1))+.14128*Math.cos(4*Math.PI*e/(t-1))-.01168*Math.cos(6*Math.PI*e/(t-1)))}static blackmanNuttall(t){return Array.from({length:t},(r,e)=>.3635819-.4891775*Math.cos(2*Math.PI*e/(t-1))+.1365995*Math.cos(4*Math.PI*e/(t-1))-.0106411*Math.cos(6*Math.PI*e/(t-1)))}static kaiser(t,r=8.6){const e=n(r),a=t-1;return Array.from({length:t},(t,s)=>{const i=2*s/a-1;return n(r*Math.sqrt(1-i*i))/e})}static tukey(t,r=.5){const e=t-1;return Array.from({length:t},(t,a)=>{const s=a/e;return r<=0?1:r>=1?.5*(1-Math.cos(2*Math.PI*s)):s<r/2?.5*(1+Math.cos(Math.PI*(2*s/r-1))):s<=1-r/2?1:.5*(1+Math.cos(Math.PI*(2*s/r-2/r+1)))})}static gauss(t,r=.4){const e=(t-1)/2;return Array.from({length:t},(t,a)=>{const s=(a-e)/(r*e);return Math.exp(-.5*s*s)})}static bartlett(t){const r=t-1;return Array.from({length:t},(t,e)=>1-Math.abs((e-r/2)/(r/2)))}static bartlettHann(t){const r=t-1;return Array.from({length:t},(t,e)=>{const a=e/r;return.62-.48*Math.abs(a-.5)-.38*Math.cos(2*Math.PI*a)})}static cosine(t){const r=t-1;return Array.from({length:t},(t,e)=>Math.sin(Math.PI*e/r))}static lanczos(t){const r=(t-1)/2;return Array.from({length:t},(t,e)=>{return 0===(a=(e-r)/r)?1:Math.sin(Math.PI*a)/(Math.PI*a);var a})}static bohman(t){const r=(t-1)/2;return Array.from({length:t},(t,e)=>{const a=Math.abs(e-r)/r;return a<=1?(1-a)*Math.cos(Math.PI*a)+1/Math.PI*Math.sin(Math.PI*a):0})}static flatTop(t){const r=t-1;return Array.from({length:t},(t,e)=>1-1.93*Math.cos(2*Math.PI*e/r)+1.29*Math.cos(4*Math.PI*e/r)-.388*Math.cos(6*Math.PI*e/r)+.028*Math.cos(8*Math.PI*e/r))}static byName(t,r,e={}){const{beta:a=8.6,alpha:n=.5,sigma:i=.4}=e||{};switch(t){case"hann":return s.hann(r);case"hamming":return s.hamming(r);case"blackman":return s.blackman(r);case"blackmanHarris":return s.blackmanHarris(r);case"blackmanNuttall":return s.blackmanNuttall(r);case"rectangle":case"rect":default:return s.rect(r);case"bartlett":return s.bartlett(r);case"bartlettHann":return s.bartlettHann(r);case"cosine":return s.cosine(r);case"lanczos":return s.lanczos(r);case"bohman":return s.bohman(r);case"gauss":case"gaussian":return s.gauss(r,i);case"tukey":return s.tukey(r,n);case"kaiser":return s.kaiser(r,a);case"flatTop":case"flattop":return s.flatTop(r)}}}const n=t=>{const r=Math.abs(t);if(r<3.75){const r=t/3.75,e=r*r;return 1+e*(3.5156229+e*(3.0899424+e*(1.2067492+e*(.2659732+e*(.0360768+.0045813*e)))))}{const t=3.75/r;return Math.exp(r)/Math.sqrt(r)*(.39894228+t*(.01328592+t*(.00225319+t*(t*(.00916281+t*(t*(.02635537+t*(.00392377*t-.01647633))-.02057706))-.00157565))))}};class i{static sinc(t){return 0===t?1:Math.sin(Math.PI*t)/(Math.PI*t)}static idealLowpass(t,r,e){const a=e-1,s=t/r;return Array.from({length:e},(t,r)=>i.sinc(2*(r-a/2)*s))}}class o{static design(t,r,e,a,n="hann"){const c=a+1,h=s.byName(n,c),l=c-1,f=t=>t.map((t,r)=>t*h[r]);if("lowpass"===t){const t=r;let a=i.idealLowpass(t,e,c);const s=2*t/e;return a=a.map(t=>t*s),{b:f(a),a:[1]}}if("highpass"===t){const t=r;return{b:o.design("lowpass",t,e,a,n).b.map((t,r)=>r===l/2?1-t:-t),a:[1]}}if("bandpass"===t){const[t,s]=r,i=o.design("lowpass",s,e,a,n).b,c=o.design("lowpass",t,e,a,n).b;return{b:i.map((t,r)=>t-c[r]),a:[1]}}if("bandstop"===t){const[t,s]=r;return{b:o.design("bandpass",[t,s],e,a,n).b.map((t,r)=>r===l/2?1-t:-t),a:[1]}}throw new Error("Unsupported FIR type")}static apply(t,r){return e.convolve(r,t)}static overlapAdd(r,s,n){const i=n||1024,o=r.length,c=e.nextPow2(i+o-1),h=a.fft(Array.from({length:c},(e,a)=>t.of(r[a]||0,0))),l=new Array(s.length+o-1).fill(0);for(let r=0;r<s.length;r+=i){const e=Array.from({length:c},(e,a)=>t.of(s[r+a]||0,0)),n=a.fft(e).map((r,e)=>t.mul(r,h[e])),f=a.ifft(n);for(let t=0;t<i+o-1;t++)l[r+t]+=f[t].re}return l}}class c{static prewarp(t,r){return 2*r*Math.tan(Math.PI*t/r)}}class h{static butterworthPoles(r){const e=[];for(let a=0;a<r;a++){const s=Math.PI*(2*a+1+r)/(2*r),n=t.of(Math.cos(s),Math.sin(s));n.re<0&&e.push(n)}return e}static cheby1Poles(r,e=1){const a=Math.sqrt(Math.pow(10,e/10)-1),s=(n=1/a,Math.log(n+Math.sqrt(n*n+1))/r);var n;const i=Math.sinh(s),o=Math.cosh(s),c=[];for(let e=0;e<r;e++){const a=Math.PI*(2*e+1)/(2*r),s=-i*Math.sin(a),n=o*Math.cos(a),h=t.of(s,n);h.re<0&&c.push(h)}return c}static pairConjugates(t){const r=new Array(t.length).fill(!1),e=[];for(let a=0;a<t.length;a++){if(r[a])continue;const s=t[a];let n=-1;for(let e=a+1;e<t.length;e++){if(r[e])continue;const a=t[e];if(Math.abs(s.re-a.re)<1e-12&&Math.abs(s.im+a.im)<1e-12){n=e;break}}n>=0?(e.push([s,t[n]]),r[a]=r[n]=!0):(e.push([s]),r[a]=!0)}return e}static bilinearBiquad(t,r,e,a,s){const n=2/(1/s),i=t*n*n+r*n+e;let o;return o="lowpass"===a?[1,2,1]:"highpass"===a?[1,-2,1]:[1,0,-1],{b:o,a:[1,(-2*t*n*n+2*e)/i,(t*n*n-r*n+e)/i]}}static fromPrototype(t,r,a,s){const n=[],i=h.pairConjugates(a);for(const e of i){const[a,s]=2===e.length?e:[e[0],null];let i,o,c;if(s){i=1,o=-2*a.re,c=a.re*a.re+a.im*a.im}else i=0,o=1,c=-a.re;n.push(h.bilinearBiquad(i,o,c,t,r))}let o=[1],c=[1];for(const t of n)o=e.polymul(o,t.b),c=e.polymul(c,t.a);const l=1/((t,r,e)=>t.reduce((t,r,a)=>t+r*Math.pow(e,-a),0)/r.reduce((t,r,a)=>t+r*Math.pow(e,-a),0))(o,c,s);o=o.map(t=>t*l);for(const t of n)t.b=t.b.map(t=>t*l);const f=c[0];if(Math.abs(f-1)>1e-14){o=o.map(t=>t/f),c=c.map(t=>t/f);for(const t of n)t.b=t.b.map(t=>t/f),t.a=[1,t.a[1]/f,t.a[2]/f]}return{b:o,a:c,sections:n}}static butterworth(r,e,a,s){if(s<1)throw new Error("Order must be >= 1");if("lowpass"===r||"highpass"===r){const n=e,i=c.prewarp(n,a),o=h.butterworthPoles(s).map(r=>t.scale(r,i)),l="lowpass"===r?1:-1,f=h.fromPrototype(r,a,o,l);return{b:f.b,a:f.a,sections:f.sections}}if("bandpass"===r||"bandstop"===r){const[t,n]=e;if(!(t>0&&n>t&&n<a/2))throw new Error("Invalid band edges");const i=Math.max(64,8*s),c=o.design(r,[t,n],a,i,"hamming");return{b:c.b,a:c.a,sections:[]}}throw new Error("Unsupported IIR kind")}static cheby1(r,e,a,s,n=1){if(s<1)throw new Error("Order must be >= 1");if("lowpass"===r||"highpass"===r){const i=e,o=c.prewarp(i,a),l=h.cheby1Poles(s,n).map(r=>t.scale(r,o)),f="lowpass"===r?1:-1,u=h.fromPrototype(r,a,l,f);return{b:u.b,a:u.a,sections:u.sections}}if("bandpass"===r||"bandstop"===r){const[t,n]=e;if(!(t>0&&n>t&&n<a/2))throw new Error("Invalid band edges");const i=Math.max(64,8*s),c=o.design(r,[t,n],a,i,"hamming");return{b:c.b,a:c.a,sections:[]}}throw new Error("Unsupported IIR kind")}}class l{static evalHz(r,e,a){const s=t.div(t.of(1,0),a),n=r=>{let e=t.of(1,0);for(let a=0;a<r;a++)e=t.mul(e,s);return e};let i=t.of(0,0);for(let e=0;e<r.length;e++)i=t.add(i,t.scale(n(e),r[e]));let o=t.of(1,0);for(let r=1;r<e.length;r++)o=t.add(o,t.scale(n(r),e[r]));return t.div(i,o)}static freqz(r,a,s=512){const n=e.linspace(0,Math.PI,s),i=n.map(e=>l.evalHz(r,a,t.expj(e))),o=i.map(t.abs),c=i.map(t.arg);return{w:n,H:i,mag:o,phase:c}}static groupDelay(t,r,e=512){const{w:a,phase:s}=l.freqz(t,r,e),n=[...s];for(let t=1;t<n.length;t++){let r=n[t]-n[t-1];for(;r>Math.PI;)n[t]-=2*Math.PI,r-=2*Math.PI;for(;r<-Math.PI;)n[t]+=2*Math.PI,r+=2*Math.PI}const i=a[1]-a[0];return{w:a,gd:n.map((t,r)=>0===r||r===n.length-1?0:-(n[r+1]-n[r-1])/(2*i))}}static isStable(){return!0}}class f{constructor(t,r=[1],e=[]){if(Math.abs(r[0]-1)>1e-12&&(t=t.map(t=>t/r[0]),r=r.map(t=>t/r[0])),this.b=t.slice(),this.a=r.slice(),this.sections=(e||[]).map(t=>({b:t.b.slice(),a:[1,t.a[1],t.a[2]]})),this.sections.length>0)this._sosState=this.sections.map(()=>({w1:0,w2:0}));else if(1===this.a.length)this._firIdx=0,this._firBuf=new Array(this.b.length).fill(0);else{const t=Math.max(this.b.length,this.a.length)-1;this._iirW=new Array(t).fill(0)}}reset(){this._sosState&&this._sosState.forEach(t=>{t.w1=0,t.w2=0}),this._firBuf&&(this._firBuf.fill(0),this._firIdx=0),this._iirW&&this._iirW.fill(0)}processSample(t){if(this.sections.length>0){let r=t;for(let t=0;t<this.sections.length;t++){const{b:e,a:a}=this.sections[t],s=this._sosState[t],n=r-a[1]*s.w1-a[2]*s.w2,i=e[0]*n+e[1]*s.w1+e[2]*s.w2;s.w2=s.w1,s.w1=n,r=i}return r}if(1===this.a.length){this._firBuf[this._firIdx]=t;let r=0,e=this._firIdx;for(let t=0;t<this.b.length;t++)r+=this.b[t]*this._firBuf[e],e=(e-1+this._firBuf.length)%this._firBuf.length;return this._firIdx=(this._firIdx+1)%this._firBuf.length,r}let r=t;for(let t=1;t<this.a.length;t++)r-=this.a[t]*(this._iirW[t-1]||0);let e=this.b[0]*r;for(let t=1;t<this.b.length;t++)e+=(this._iirW[t-1]||0)*this.b[t];for(let t=this._iirW.length-1;t>0;t--)this._iirW[t]=this._iirW[t-1];return this._iirW[0]=r,e}applySignal(t){const r=new Array(t.length);for(let e=0;e<t.length;e++)r[e]=this.processSample(t[e]);return r}frequencyResponse(t,r=1024){const e=l.freqz(this.b,this.a,r);return{f:e.w.map(r=>r*t/(2*Math.PI)),mag:e.mag,phase:e.phase,H:e.H}}toJSON(){return{b:this.b.slice(),a:this.a.slice()}}static fromTF(t,r){return new f(t,r)}static designFIR(t,r,e,a,s="hann"){const n=o.design(t,r,e,a,s);return new f(n.b,n.a)}static designButter(t,r,e,a){const s=h.butterworth(t,r,e,a);return new f(s.b,s.a,s.sections)}static designCheby1(t,r,e,a,s=1){const n=h.cheby1(t,r,e,a,s);return new f(n.b,n.a,n.sections)}}const u={design:(t,r,e,a,s="hann")=>o.design(t,r,e,a,s),apply:(t,r)=>o.apply(t,r),overlapAdd:(t,r,e)=>o.overlapAdd(t,r,e)},m={butterworth:(t,r,e,a)=>{const s=h.butterworth(t,r,e,a);return{b:s.b,a:s.a}},cheby1:(t,r,e,a,s=1)=>{const n=h.cheby1(t,r,e,a,s);return{b:n.b,a:n.a}},apply:(t,r,e)=>f.fromTF(t,r).applySignal(e)},p={evalHz:(t,r,e)=>l.evalHz(t,r,e),freqz:(t,r,e=512)=>l.freqz(t,r,e),groupDelay:(t,r,e=512)=>l.groupDelay(t,r,e),isStable:()=>l.isStable()};var b={ComplexNum:t,C:r,Util:e,FFT:a,Window:s,Kernels:i,FIRDesigner:o,IIRDesigner:h,Bilinear:c,ZDomain:l,Filter:f,FIR:u,IIR:m,Z:p};export{c as Bilinear,r as C,t as ComplexNum,a as FFT,u as FIR,o as FIRDesigner,f as Filter,m as IIR,h as IIRDesigner,i as Kernels,e as Util,s as Window,p as Z,l as ZDomain,b as default};
//# sourceMappingURL=dsp-filter-library.esm.min.js.map
