class t{static of(t=0,s=0){return{re:t,im:s}}static add(t,s){return{re:t.re+s.re,im:t.im+s.im}}static sub(t,s){return{re:t.re-s.re,im:t.im-s.im}}static mul(t,s){return{re:t.re*s.re-t.im*s.im,im:t.re*s.im+t.im*s.re}}static scale(t,s){return{re:t.re*s,im:t.im*s}}static conj(t){return{re:t.re,im:-t.im}}static div(t,s){const e=s.re*s.re+s.im*s.im||1e-300;return{re:(t.re*s.re+t.im*s.im)/e,im:(t.im*s.re-t.re*s.im)/e}}static abs(t){return Math.hypot(t.re,t.im)}static arg(t){return Math.atan2(t.im,t.re)}static expj(t){return{re:Math.cos(t),im:Math.sin(t)}}static pow(t,e){if(0===e)return{re:1,im:0};if(1===e)return t;if(-1===e)return s.div({re:1,im:0},t);if(e>0){let r={re:1,im:0};for(let a=0;a<e;a++)r=s.mul(r,t);return r}{let r={re:1,im:0};for(let a=0;a<-e;a++)r=s.mul(r,t);return s.div({re:1,im:0},r)}}static sqrt(t){const e=Math.sqrt(s.abs(t)),r=Math.atan2(t.im,t.re)/2;return{re:e*Math.cos(r),im:e*Math.sin(r)}}}const s=t;class e{static nextPow2(t){if(!Number.isFinite(t)||t<=1)return 1;let s=1;for(;s<t;)s*=2;return s}static linspace(t,s,e){if(e<=0)return[];if(1===e)return[t];const r=(s-t)/(e-1);return Array.from({length:e},(s,e)=>t+e*r)}static convolve(t,s){const e=new Array(t.length+s.length-1).fill(0);for(let r=0;r<t.length;r++){const a=t[r];for(let t=0;t<s.length;t++)e[r+t]+=a*s[t]}return e}static polymul(t,s){const e=t.length,r=s.length,a=new Array(e+r-1).fill(0);for(let i=0;i<e;i++)for(let e=0;e<r;e++)a[i+e]+=t[i]*s[e];return a}static polyadd(t,s){const e=Math.max(t.length,s.length),r=new Array(e).fill(0);for(let a=0;a<e;a++)a<t.length&&(r[a]+=t[a]),a<s.length&&(r[a]+=s[a]);return r}static polyfromroots(t,s=1e-12){const r=new Array(t.length).fill(!1);let a=[1];for(let i=0;i<t.length;i++){if(r[i])continue;const n=t[i];let o=-1;for(let e=i+1;e<t.length;e++){if(r[e])continue;const a=t[e];if(Math.abs(n.re-a.re)<s&&Math.abs(n.im+a.im)<s){o=e;break}}if(Math.abs(n.im)<1e-14)a=e.polymul(a,[1,-n.re]),r[i]=!0;else if(o>=0){const t=[1,-2*n.re,n.re*n.re+n.im*n.im];a=e.polymul(a,t),r[i]=r[o]=!0}else{const t=[1,-2*n.re,n.re*n.re+n.im*n.im];a=e.polymul(a,t),r[i]=!0}}return a}static prewarp(t,s){return 2*s*Math.tan(Math.PI*t/s)}static pairConjugates(t){const s=new Array(t.length).fill(!1),e=[];for(let r=0;r<t.length;r++){if(s[r])continue;const a=t[r];let i=-1;for(let e=r+1;e<t.length;e++){if(s[e])continue;const r=t[e];if(Math.abs(a.re-r.re)<1e-12&&Math.abs(a.im+r.im)<1e-12){i=e;break}}i>=0?(e.push([a,t[i]]),s[r]=s[i]=!0):(e.push([a]),s[r]=!0)}return e}static bilinearMapBiquad(t,s,e,r,a,i,n){const o=2*n,l=r*o*o+a*o+i;return{b:[(t*o*o+s*o+e)/l,2*(e-t*o*o)/l,(t*o*o-s*o+e)/l],a:[1,2*(i-r*o*o)/l,(r*o*o-a*o+i)/l]}}static evalHzAtZ(t,s,e){return t.reduce((t,s,r)=>t+s*Math.pow(e,-r),0)/s.reduce((t,s,r)=>t+s*Math.pow(e,-r),0)}}class r{static fft(s){let a=s.length;if(a<=1)return s;if(a&a-1){const i=e.nextPow2(a);return r.fft(s.concat(Array.from({length:i-a},()=>t.of(0,0))))}let i=0;for(let t=1;t<a-1;t++){let e=a>>1;for(;i&e;e>>=1)i^=e;if(i^=e,t<i){const e=s[t];s[t]=s[i],s[i]=e}}for(let e=2;e<=a;e<<=1){const r=-2*Math.PI/e;for(let i=0;i<a;i+=e)for(let a=0;a<e/2;a++){const n=t.expj(r*a),o=s[i+a],l=t.mul(s[i+a+(e>>1)],n);s[i+a]=t.add(o,l),s[i+a+(e>>1)]=t.sub(o,l)}}return s}static ifft(s){const e=s.length;return r.fft(s.map(t.conj)).map(t.conj).map(s=>t.scale(s,1/e))}static rfft(s){const a=e.nextPow2(s.length),i=Array.from({length:a},(e,r)=>t.of(s[r]||0,0));return r.fft(i)}static powerSpectrum(s){return r.rfft(s).map(t.abs).map(t=>t*t)}}class a{static rect(t){return Array.from({length:t},()=>1)}static rectangle(t){return a.rect(t)}static hann(t){return Array.from({length:t},(s,e)=>.5-.5*Math.cos(2*Math.PI*e/(t-1)))}static hamming(t){return Array.from({length:t},(s,e)=>.54-.46*Math.cos(2*Math.PI*e/(t-1)))}static blackman(t){return Array.from({length:t},(s,e)=>.42-.5*Math.cos(2*Math.PI*e/(t-1))+.08*Math.cos(4*Math.PI*e/(t-1)))}static blackmanHarris(t){return Array.from({length:t},(s,e)=>.35875-.48829*Math.cos(2*Math.PI*e/(t-1))+.14128*Math.cos(4*Math.PI*e/(t-1))-.01168*Math.cos(6*Math.PI*e/(t-1)))}static blackmanNuttall(t){return Array.from({length:t},(s,e)=>.3635819-.4891775*Math.cos(2*Math.PI*e/(t-1))+.1365995*Math.cos(4*Math.PI*e/(t-1))-.0106411*Math.cos(6*Math.PI*e/(t-1)))}static kaiser(t,s=8.6){const e=i(s),r=t-1;return Array.from({length:t},(t,a)=>{const n=2*a/r-1;return i(s*Math.sqrt(1-n*n))/e})}static tukey(t,s=.5){const e=t-1;return Array.from({length:t},(t,r)=>{const a=r/e;return s<=0?1:s>=1?.5*(1-Math.cos(2*Math.PI*a)):a<s/2?.5*(1+Math.cos(Math.PI*(2*a/s-1))):a<=1-s/2?1:.5*(1+Math.cos(Math.PI*(2*a/s-2/s+1)))})}static gauss(t,s=.4){const e=(t-1)/2;return Array.from({length:t},(t,r)=>{const a=(r-e)/(s*e);return Math.exp(-.5*a*a)})}static bartlett(t){const s=t-1;return Array.from({length:t},(t,e)=>1-Math.abs((e-s/2)/(s/2)))}static bartlettHann(t){const s=t-1;return Array.from({length:t},(t,e)=>{const r=e/s;return.62-.48*Math.abs(r-.5)-.38*Math.cos(2*Math.PI*r)})}static cosine(t){const s=t-1;return Array.from({length:t},(t,e)=>Math.sin(Math.PI*e/s))}static lanczos(t){const s=(t-1)/2;return Array.from({length:t},(t,e)=>{return 0===(r=(e-s)/s)?1:Math.sin(Math.PI*r)/(Math.PI*r);var r})}static bohman(t){const s=(t-1)/2;return Array.from({length:t},(t,e)=>{const r=Math.abs(e-s)/s;return r<=1?(1-r)*Math.cos(Math.PI*r)+1/Math.PI*Math.sin(Math.PI*r):0})}static flatTop(t){const s=t-1;return Array.from({length:t},(t,e)=>1-1.93*Math.cos(2*Math.PI*e/s)+1.29*Math.cos(4*Math.PI*e/s)-.388*Math.cos(6*Math.PI*e/s)+.028*Math.cos(8*Math.PI*e/s))}static byName(t,s,e={}){const{beta:r=8.6,alpha:i=.5,sigma:n=.4}=e||{};switch(t){case"hann":return a.hann(s);case"hamming":return a.hamming(s);case"blackman":return a.blackman(s);case"blackmanHarris":return a.blackmanHarris(s);case"blackmanNuttall":return a.blackmanNuttall(s);case"rectangle":case"rect":default:return a.rect(s);case"bartlett":return a.bartlett(s);case"bartlettHann":return a.bartlettHann(s);case"cosine":return a.cosine(s);case"lanczos":return a.lanczos(s);case"bohman":return a.bohman(s);case"gauss":case"gaussian":return a.gauss(s,n);case"tukey":return a.tukey(s,i);case"kaiser":return a.kaiser(s,r);case"flatTop":case"flattop":return a.flatTop(s)}}}const i=t=>{const s=Math.abs(t);if(s<3.75){const s=t/3.75,e=s*s;return 1+e*(3.5156229+e*(3.0899424+e*(1.2067492+e*(.2659732+e*(.0360768+.0045813*e)))))}{const t=3.75/s;return Math.exp(s)/Math.sqrt(s)*(.39894228+t*(.01328592+t*(.00225319+t*(t*(.00916281+t*(t*(.02635537+t*(.00392377*t-.01647633))-.02057706))-.00157565))))}};class n{static sinc(t){return 0===t?1:Math.sin(Math.PI*t)/(Math.PI*t)}static idealLowpass(t,s,e){const r=e-1,a=t/s;return Array.from({length:e},(t,s)=>n.sinc(2*(s-r/2)*a))}}class o{static design(t,s,e,r,i="hann"){const l=r+1,c=a.byName(i,l),h=l-1,u=t=>t.map((t,s)=>t*c[s]);if("lowpass"===t){const t=s;let r=n.idealLowpass(t,e,l);const a=2*t/e;return r=r.map(t=>t*a),{b:u(r),a:[1]}}if("highpass"===t){const t=s;return{b:o.design("lowpass",t,e,r,i).b.map((t,s)=>s===h/2?1-t:-t),a:[1]}}if("bandpass"===t){const[t,a]=s,n=o.design("lowpass",a,e,r,i).b,l=o.design("lowpass",t,e,r,i).b;return{b:n.map((t,s)=>t-l[s]),a:[1]}}if("bandstop"===t){const[t,a]=s;return{b:o.design("bandpass",[t,a],e,r,i).b.map((t,s)=>s===h/2?1-t:-t),a:[1]}}throw new Error("Unsupported FIR type")}static apply(t,s){return e.convolve(s,t)}static overlapAdd(s,a,i){const n=i||1024,o=s.length,l=e.nextPow2(n+o-1),c=r.fft(Array.from({length:l},(e,r)=>t.of(s[r]||0,0))),h=new Array(a.length+o-1).fill(0);for(let s=0;s<a.length;s+=n){const e=Array.from({length:l},(e,r)=>t.of(a[s+r]||0,0)),i=r.fft(e).map((s,e)=>t.mul(s,c[e])),u=r.ifft(i);for(let t=0;t<n+o-1;t++)h[s+t]+=u[t].re}return h}}class l{static validateCommonParameters(t,s,e,r){if(r<1)throw new Error("Order must be >= 1");if(e<=0)throw new Error("Sampling frequency must be positive");if("lowpass"===t||"highpass"===t){if(s<=0||s>=e/2)throw new Error("Cutoff frequency must be 0 < fc < fs/2")}else{if("bandpass"!==t&&"bandstop"!==t)throw new Error(`Unsupported filter kind: ${t}`);{const[t,r]=s;if(!(t>0&&r>t&&r<e/2))throw new Error("Invalid band edges: must satisfy 0 < f1 < f2 < fs/2")}}}static fromPrototype(t,s,r,a,i){const n=[],o=e.pairConjugates(r);for(const r of o){const[a,o]=2===r.length?r:[r[0],null];let l,c,h,u,f,p,d,g,m;if(o?(l=1,c=-2*a.re,h=a.re*a.re+a.im*a.im):(l=0,c=1,h=-a.re),"lowpass"===t)u=l,f=c*i,p=h*i*i,d=0,g=0,m=1;else{if("highpass"!==t)throw new Error("fromPrototype supports only lowpass/highpass");0!==l?(u=h,f=c*i,p=l*i*i,d=1,g=0,m=0):(u=0,f=h,p=c*i,d=0,g=1,m=0)}n.push(e.bilinearMapBiquad(d,g,m,u,f,p,s))}let l=[1],c=[1];for(const t of n)l=e.polymul(l,t.b),c=e.polymul(c,t.a);const h=1/e.evalHzAtZ(l,c,a);if(n.length>0){const t=n.length-1;n[t].b=n[t].b.map(t=>t*h)}l=[1],c=[1];for(const t of n)l=e.polymul(l,t.b),c=e.polymul(c,t.a);return{b:l,a:c,sections:n}}static calculatePoles(t,...s){throw new Error("calculatePoles must be implemented by subclass")}static design(t,s,e,r,...a){throw new Error("design must be implemented by subclass")}}class c extends l{static calculatePoles(s){const e=[];for(let r=0;r<s;r++){const a=Math.PI*(2*r+1+s)/(2*s),i=t.of(Math.cos(a),Math.sin(a));i.re<0&&e.push(i)}return e}static designLowHighPass(t,s,r,a){const i=s,n=e.prewarp(i,r),o=c.calculatePoles(a),h="lowpass"===t?1:-1;return l.fromPrototype(t,r,o,h,n)}static designBandPass(t,s,r){const[a,i]=t,n=c.designLowHighPass("highpass",a,s,r),o=c.designLowHighPass("lowpass",i,s,r);return{b:e.polymul(n.b,o.b),a:e.polymul(n.a,o.a),sections:n.sections.concat(o.sections)}}static designBandStop(t,s,r){const[a,i]=t,n=c.designLowHighPass("lowpass",a,s,r),o=c.designLowHighPass("highpass",i,s,r),l=e.polymul(n.a,o.a),h=e.polymul(n.b,o.a),u=e.polymul(o.b,n.a);return{b:e.polyadd(h,u),a:l,sections:[...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static designBandPassStop(t,s,e,r){if("bandpass"===t)return c.designBandPass(s,e,r);if("bandstop"===t)return c.designBandStop(s,e,r);throw new Error("Unsupported filter kind for band design")}static design(t,s,e,r){if(c.validateCommonParameters(t,s,e,r),r>12)throw new Error(`Butterworth filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t||"highpass"===t)return c.designLowHighPass(t,s,e,r);if("bandpass"===t||"bandstop"===t)return c.designBandPassStop(t,s,e,r);throw new Error("Unsupported filter kind")}}class h extends l{static validateParameters(t,s,e,r,a){if(h.validateCommonParameters(t,s,e,r),a<=0)throw new Error("Passband ripple must be positive");if(a>10)throw new Error("Passband ripple should be <= 10 dB for practical designs")}static calculatePoles(s,e){const r=Math.sqrt(Math.pow(10,e/10)-1),a=Math.asinh(1/r)/s,i=Math.sinh(a),n=Math.cosh(a),o=[];for(let e=0;e<s;e++){const r=Math.PI*(2*e+1)/(2*s),a=-i*Math.sin(r),l=n*Math.cos(r),c=t.of(a,l);c.re<0&&o.push(c)}return o}static designLowHighPass(t,s,r,a,i){const n=s,o=e.prewarp(n,r),c=h.calculatePoles(a,i),u="lowpass"===t?1:-1;return l.fromPrototype(t,r,c,u,o)}static designBandPass(t,s,r,a){const[i,n]=t,o=h.designLowHighPass("highpass",i,s,r,a),l=h.designLowHighPass("lowpass",n,s,r,a);return{b:e.polymul(o.b,l.b),a:e.polymul(o.a,l.a),sections:o.sections.concat(l.sections)}}static designBandStop(t,s,r,a){const[i,n]=t,o=h.designLowHighPass("lowpass",i,s,r,a),l=h.designLowHighPass("highpass",n,s,r,a),c=e.polymul(o.a,l.a),u=e.polymul(o.b,l.a),f=e.polymul(l.b,o.a);return{b:e.polyadd(u,f),a:c,sections:[...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...l.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static designBandPassStop(t,s,e,r,a){if("bandpass"===t)return h.designBandPass(s,e,r,a);if("bandstop"===t)return h.designBandStop(s,e,r,a);throw new Error("Unsupported filter kind for band design")}static design(t,s,e,r,a=1){if(h.validateParameters(t,s,e,r,a),r>12)throw new Error(`Chebyshev filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t||"highpass"===t)return h.designLowHighPass(t,s,e,r,a);if("bandpass"===t||"bandstop"===t)return h.designBandPassStop(t,s,e,r,a);throw new Error("Unsupported filter kind")}}class u extends l{static validateParameters(t,s,e,r,a){if(u.validateCommonParameters(t,s,e,r),!(a>0))throw new Error("Stopband attenuation must be positive")}static calculatePolesAndZeros(s,e){const r=1/(Math.pow(10,e/10)-1),a=Math.asinh(1/Math.sqrt(r))/s,i=[];for(let e=1;e<=s;e++){const r=Math.PI*(2*e-1)/(2*s),n=-Math.sinh(a)*Math.sin(r),o=Math.cosh(a)*Math.cos(r);i.push(t.of(n,o))}const n=[],o=Math.floor(s/2);for(let t=1;t<=o;t++){const e=Math.PI*(2*t-1)/(2*s);n.push(1/Math.cos(e))}return{poles:i,zerosW:n}}static mapSectionLP_HP(t,s,r,a,i){let n,o,l,c,h,u,f,p,d,g,m,b;if(2===s.length){const t=s[0];n=1,o=-2*t.re,l=t.re*t.re+t.im*t.im}else{n=0,o=1,l=-s[0].re}return null!=r?(c=1,h=0,u=r*r):(c=0,h=0,u=1),"lowpass"===t?(f=n,p=o*a,d=l*a*a,g=c,m=h*a,b=u*a*a):(0!==n?(f=l,p=o*a,d=n*a*a):(f=0,p=l,d=o*a),0!==c?(g=u,m=h*a,b=c*a*a):0!==h?(g=0,m=u,b=h*a):(g=u,m=0,b=0)),e.bilinearMapBiquad(g,m,b,f,p,d,i)}static designLPHP(t,s,r,a,i){const n=e.prewarp(s,r),{poles:o,zerosW:l}=this.calculatePolesAndZeros(a,i),c=e.pairConjugates(o),h=[];let u=0;for(const s of c){const e=u<l.length?l[u++]*n:null,a=this.mapSectionLP_HP(t,s,e,n,r);h.push(a)}let f=[1],p=[1];for(const t of h)f=e.polymul(f,t.b),p=e.polymul(p,t.a);const d="lowpass"===t?1:-1,g=1/e.evalHzAtZ(f,p,d);if(h.length){const t=h.length-1;h[t]={b:h[t].b.map(t=>t*g),a:h[t].a.slice()},f=[1],p=[1];for(const t of h)f=e.polymul(f,t.b),p=e.polymul(p,t.a)}return{b:f,a:p,sections:h}}static designLowPass(t,s,e,r){return this.designLPHP("lowpass",t,s,e,r)}static designHighPass(t,s,e,r){return this.designLPHP("highpass",t,s,e,r)}static designBandPass(t,s,r,a){const[i,n]=t,o=this.designHighPass(i,s,r,a),l=this.designLowPass(n,s,r,a);return{b:e.polymul(o.b,l.b),a:e.polymul(o.a,l.a),sections:[...o.sections,...l.sections]}}static designBandStop(t,s,r,a){const[i,n]=t,o=this.designLowPass(i,s,r,a),l=this.designHighPass(n,s,r,a),c=e.polymul(o.a,l.a),h=e.polymul(o.b,l.a),u=e.polymul(l.b,o.a);return{b:e.polyadd(h,u),a:c,sections:[...o.sections,...l.sections]}}static designBandPassStop(t,s,e,r,a){if("bandpass"===t)return this.designBandPass(s,e,r,a);if("bandstop"===t)return this.designBandStop(s,e,r,a);throw new Error("Unsupported filter kind for band design")}static design(t,s,e,r,a=40){if(this.validateParameters(t,s,e,r,a),r>12)throw new Error(`Chebyshev Type 2 filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t)return this.designLowPass(s,e,r,a);if("highpass"===t)return this.designHighPass(s,e,r,a);if("bandpass"===t||"bandstop"===t)return this.designBandPassStop(t,s,e,r,a);throw new Error("Unsupported filter kind")}}class f extends l{static validateParameters(t,s,e,r){if(f.validateCommonParameters(t,s,e,r),r<2)throw new Error("Order must be >= 2 for Linkwitz-Riley filters")}static design(t,s,r,a){if(f.validateParameters(t,s,r,a),a>12)throw new Error(`Linkwitz-Riley filter order ${a} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);const i=(a%2==0?a:a+1)/2,n=c.design(t,s,r,i),o=n.sections.concat(n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})));return{b:e.polymul(n.b,n.b),a:e.polymul(n.a,n.a),sections:o}}static designLowPass(t,s,e){return f.design("lowpass",t,s,e)}static designHighPass(t,s,e){return f.design("highpass",t,s,e)}static designBandPass(t,s,r){const[a,i]=t,n=f.design("highpass",a,s,r),o=f.design("lowpass",i,s,r);return{b:e.polymul(n.b,o.b),a:e.polymul(n.a,o.a),sections:n.sections.concat(o.sections)}}static designBandStop(t,s,r){const[a,i]=t,n=f.design("lowpass",a,s,r),o=f.design("highpass",i,s,r),l=e.polymul(n.a,o.a),c=e.polymul(n.b,o.a),h=e.polymul(o.b,n.a);return{b:e.polyadd(c,h),a:l,sections:[...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static getActualOrder(t){return t%2==0?t:t+1}static getHalfOrder(t){return f.getActualOrder(t)/2}static getNumberOfSections(t){return 2*f.getHalfOrder(t)}static getRecommendedOrders(){return{basic:2,standard:4,high:6,premium:8,professional:12}}static adjustOrderToEven(t){return t<2?2:t%2==0?t:t+1}static getFilterInfo(t){const s=f.getActualOrder(t),e=f.getHalfOrder(t);return{requestedOrder:t,actualOrder:s,halfOrder:e,sections:f.getNumberOfSections(t),isAdjusted:t!==s,description:`Linkwitz-Riley ${s}th order (${e}th order Butterworth cascaded twice)`}}}class p extends l{static design(t,s,e,r,a=1,i=40){if(r>12)throw new Error(`Elliptic filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);switch(t){case"lowpass":return this.designLowPass(s,e,r,a,i);case"highpass":return this.designHighPass(s,e,r,a,i);case"bandpass":if(Array.isArray(s)&&2===s.length)return this.designBandPass(s[0],s[1],e,r,a,i);throw new Error("Bandpass requires [lowCutoff, highCutoff] frequencies");case"bandstop":if(Array.isArray(s)&&2===s.length)return this.designBandStop(s[0],s[1],e,r,a,i);throw new Error("Bandstop requires [lowCutoff, highCutoff] frequencies");default:throw new Error(`Unsupported filter type: ${t}`)}}static designLowPass(t,s,r,a,i){const n=e.prewarp(t,s),{poles:o,zeros:l}=this.calculateEllipticPolesAndZeros(r,a,i);return this.fromPrototype("lowpass",s,o,1,n)}static designHighPass(t,r,a,i,n){const o=e.prewarp(t,r),{poles:l,zeros:c}=this.calculateEllipticPolesAndZeros(a,i,n),h=l.map(t=>s.div(s.of(1,0),t));return this.fromPrototype("highpass",r,h,-1,o)}static designBandPass(t,s,r,a,i,n){const o=this.designHighPass(t,r,a,i,n),l=this.designLowPass(s,r,a,i,n);return{b:e.polymul(o.b,l.b),a:e.polymul(o.a,l.a),sections:o.sections.concat(l.sections)}}static designBandStop(t,s,r,a,i,n){const o=this.designLowPass(t,r,a,i,n),l=this.designHighPass(s,r,a,i,n),c=e.polymul(o.a,l.a),h=e.polymul(o.b,l.a),u=e.polymul(l.b,o.a);return{b:e.polyadd(h,u),a:c,sections:[...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...l.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static calculateEllipticPolesAndZeros(t,e,r){const a=Math.sqrt(Math.pow(10,e/10)-1),i=Math.pow(10,r/20),n=a/Math.sqrt(i*i-1),o=this.calculateModularConstant(n,t),l=this.completeEllipticIntegral(o);this.completeEllipticIntegral(Math.sqrt(1-o*o));const c=[],h=[];for(let e=1;e<=Math.floor(t/2);e++){const r=(2*e-1)*l/t,a=this.jacobiSn(r,o),i=-a*this.jacobiCn(r,o)/(1-a*a),n=this.jacobiDn(r,o)/(1-a*a);c.push(s.of(i,n)),c.push(s.of(i,-n));const u=1/(o*a),f=0;h.push(s.of(u,f)),h.push(s.of(u,-f))}if(t%2==1){const e=l/t,r=this.jacobiSn(e,o);c.push(s.of(-r,0)),h.push(s.of(1/(o*r),0))}return{poles:c,zeros:h}}static calculateModularConstant(t,s){const e=Math.exp(-Math.PI*this.completeEllipticIntegral(Math.sqrt(1-t*t))/this.completeEllipticIntegral(t));let r=Math.sqrt(e);for(let t=0;t<10;t++){r-=(this.completeEllipticIntegral(r)/this.completeEllipticIntegral(Math.sqrt(1-r*r))-s*Math.log(e)/Math.PI)/this.ellipticIntegralDerivative(r)}return r}static completeEllipticIntegral(t){if(0===t)return Math.PI/2;if(1===t)return 1/0;let s=1,e=1;const r=t*t;for(let t=1;t<100&&(e*=(2*t-1)*(2*t-1)*r/(2*t*2*t),s+=e,!(Math.abs(e)<1e-15));t++);return Math.PI/2*s}static jacobiSn(t,s){const e=s*s;let r=0,a=1;for(let s=0;s<50&&(r+=a*Math.sin((2*s+1)*t),a*=e,!(Math.abs(a)<1e-15));s++);return r}static jacobiCn(t,s){const e=this.jacobiSn(t,s);return Math.sqrt(1-e*e)}static jacobiDn(t,s){const e=this.jacobiSn(t,s),r=s*s;return Math.sqrt(1-r*e*e)}static ellipticIntegralDerivative(t){const s=1-t*t;return this.completeEllipticIntegral(t)/(t*s)-this.completeEllipticIntegral(Math.sqrt(s))/(t*t)}static getRecommendedPassbandRipples(){return[.1,.2,.5,1,2,3,5]}static getRecommendedStopbandAttenuations(){return[20,30,40,50,60,70,80,90,100]}static calculateActualPassbandRipple(t,s,e){const r=Math.sqrt(Math.pow(10,s/10)-1),a=Math.pow(10,e/20),i=r*Math.pow(a,-1/t);return 10*Math.log10(1+i*i)}static calculateActualStopbandAttenuation(t,s,e){const r=Math.sqrt(Math.pow(10,s/10)-1),a=Math.pow(10,e/20)*Math.pow(r,1/t);return 20*Math.log10(a)}}class d extends l{static design(t,s,e,r){if(r>12)throw new Error(`Bessel filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);switch(t){case"lowpass":return this.designLowPass(s,e,r);case"highpass":return this.designHighPass(s,e,r);case"bandpass":if(Array.isArray(s)&&2===s.length)return this.designBandPass(s[0],s[1],e,r);throw new Error("Bandpass requires [lowCutoff, highCutoff] frequencies");case"bandstop":if(Array.isArray(s)&&2===s.length)return this.designBandStop(s[0],s[1],e,r);throw new Error("Bandstop requires [lowCutoff, highCutoff] frequencies");default:throw new Error(`Unsupported filter type: ${t}`)}}static designLowPass(t,s,r){const a=e.prewarp(t,s),i=this.calculateBesselPoles(r);return this.fromPrototype("lowpass",s,i,1,a)}static designHighPass(t,r,a){const i=e.prewarp(t,r),n=this.calculateBesselPoles(a).map(t=>s.div(s.of(1,0),t));return this.fromPrototype("highpass",r,n,-1,i)}static designBandPass(t,s,r,a){const i=this.designHighPass(t,r,a),n=this.designLowPass(s,r,a);return{b:e.polymul(i.b,n.b),a:e.polymul(i.a,n.a),sections:i.sections.concat(n.sections)}}static designBandStop(t,s,r,a){const i=this.designLowPass(t,r,a),n=this.designHighPass(s,r,a),o=e.polymul(i.a,n.a),l=e.polymul(i.b,n.a),c=e.polymul(n.b,i.a);return{b:e.polyadd(l,c),a:o,sections:[...i.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static calculateBesselPoles(t){const e={1:[s.of(-1,0)],2:[s.of(-1.5,.8660254037844386),s.of(-1.5,-.8660254037844386)],3:[s.of(-2.322185354626086,0),s.of(-1.838907322686957,1.754380959783721),s.of(-1.838907322686957,-1.754380959783721)],4:[s.of(-2.103789397179628,.6657060219931349),s.of(-2.103789397179628,-.6657060219931349),s.of(-1.896210602820372,1.744447419188405),s.of(-1.896210602820372,-1.744447419188405)],5:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146)],6:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189)],7:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095)],8:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095)],9:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095),s.of(-1.224744871391589,1.224744871391589),s.of(-1.224744871391589,-1.224744871391589)],10:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095),s.of(-1.224744871391589,1.224744871391589),s.of(-1.224744871391589,-1.224744871391589)]};return e[t]?e[t]:this.calculateBesselPolesNumerical(t)}static calculateBesselPolesNumerical(t){const e=[];if(t%2==0)for(let r=0;r<t/2;r++){const a=(2*r+1)*Math.PI/(2*t),i=-Math.cos(a),n=Math.sin(a);e.push(s.of(i,n)),e.push(s.of(i,-n))}else{e.push(s.of(-1,0));for(let r=0;r<(t-1)/2;r++){const a=(2*r+1)*Math.PI/(2*t),i=-Math.cos(a),n=Math.sin(a);e.push(s.of(i,n)),e.push(s.of(i,-n))}}return e}static calculateBesselPolynomial(t){if(0===t)return[1];if(1===t)return[1,1];let s=[1],e=[1,1];for(let r=2;r<=t;r++){const t=new Array(r+1).fill(0);for(let s=0;s<e.length;s++)t[s]+=(2*r-1)*e[s];for(let e=0;e<s.length;e++)t[e+2]+=s[e];s=e,e=t}return e}static getRecommendedOrders(){return[1,2,3,4,5,6,7,8,9,10]}static calculateGroupDelay(t,s,e){const r=t/(2*Math.PI*s);return Math.max(0,r)}static getCharacteristics(t){return{1:{groupDelay:1,rolloff:-6,phase:"Linear"},2:{groupDelay:1.5,rolloff:-12,phase:"Linear"},3:{groupDelay:2,rolloff:-18,phase:"Linear"},4:{groupDelay:2.5,rolloff:-24,phase:"Linear"},5:{groupDelay:3,rolloff:-30,phase:"Linear"},6:{groupDelay:3.5,rolloff:-36,phase:"Linear"},7:{groupDelay:4,rolloff:-42,phase:"Linear"},8:{groupDelay:4.5,rolloff:-48,phase:"Linear"},9:{groupDelay:5,rolloff:-54,phase:"Linear"},10:{groupDelay:5.5,rolloff:-60,phase:"Linear"}}[t]||{groupDelay:.5*t,rolloff:-6*t,phase:"Linear"}}}class g{static fromPrototype(t,s,e,r,a){return l.fromPrototype(t,s,e,r,a)}static butterworth(t,s,e,r){return c.design(t,s,e,r)}static cheby1(t,s,e,r,a=1){return h.design(t,s,e,r,a)}static cheby2(t,s,e,r,a=40){return u.design(t,s,e,r,a)}static linkwitzRiley(t,s,e,r=4){return f.design(t,s,e,r)}static elliptic(t,s,e,r,a=1,i=40){return p.design(t,s,e,r,a,i)}static bessel(t,s,e,r){return d.design(t,s,e,r)}}class m{static evalHz(s,e,r){const a=t.div(t.of(1,0),r),i=s=>{let e=t.of(1,0);for(let r=0;r<s;r++)e=t.mul(e,a);return e};let n=t.of(0,0);for(let e=0;e<s.length;e++)n=t.add(n,t.scale(i(e),s[e]));let o=t.of(1,0);for(let s=1;s<e.length;s++)o=t.add(o,t.scale(i(s),e[s]));return t.div(n,o)}static freqz(s,r,a=512){const i=e.linspace(0,Math.PI,a),n=i.map(e=>m.evalHz(s,r,t.expj(e))),o=n.map(t.abs),l=n.map(t.arg);return{w:i,H:n,mag:o,phase:l}}static groupDelay(t,s,e=512){const{w:r,phase:a}=m.freqz(t,s,e),i=[...a];for(let t=1;t<i.length;t++){let s=i[t]-i[t-1];for(;s>Math.PI;)i[t]-=2*Math.PI,s-=2*Math.PI;for(;s<-Math.PI;)i[t]+=2*Math.PI,s+=2*Math.PI}const n=r[1]-r[0];return{w:r,gd:i.map((t,s)=>0===s||s===i.length-1?0:-(i[s+1]-i[s-1])/(2*n))}}static isStable(){return!0}}class b{constructor(t,s=[1],e=[]){if(Math.abs(s[0]-1)>1e-12&&(t=t.map(t=>t/s[0]),s=s.map(t=>t/s[0])),this.b=t.slice(),this.a=s.slice(),this.sections=(e||[]).map(t=>({b:t.b.slice(),a:[1,t.a[1],t.a[2]]})),this.sections.length>0)this._sosState=this.sections.map(()=>({w1:0,w2:0}));else if(1===this.a.length)this._firIdx=0,this._firBuf=new Array(this.b.length).fill(0);else{const t=Math.max(this.b.length,this.a.length)-1;this._iirW=new Array(t).fill(0)}}reset(){this._sosState&&this._sosState.forEach(t=>{t.w1=0,t.w2=0}),this._firBuf&&(this._firBuf.fill(0),this._firIdx=0),this._iirW&&this._iirW.fill(0)}processSample(t){if(this.sections.length>0){let s=t;for(let t=0;t<this.sections.length;t++){const{b:e,a:r}=this.sections[t],a=this._sosState[t],i=s-r[1]*a.w1-r[2]*a.w2,n=e[0]*i+e[1]*a.w1+e[2]*a.w2;a.w2=a.w1,a.w1=i,s=n}return s}if(1===this.a.length){this._firBuf[this._firIdx]=t;let s=0,e=this._firIdx;for(let t=0;t<this.b.length;t++)s+=this.b[t]*this._firBuf[e],e=(e-1+this._firBuf.length)%this._firBuf.length;return this._firIdx=(this._firIdx+1)%this._firBuf.length,s}let s=t;for(let t=1;t<this.a.length;t++)s-=this.a[t]*(this._iirW[t-1]||0);let e=this.b[0]*s;for(let t=1;t<this.b.length;t++)e+=(this._iirW[t-1]||0)*this.b[t];for(let t=this._iirW.length-1;t>0;t--)this._iirW[t]=this._iirW[t-1];return this._iirW[0]=s,e}applySignal(t){const s=new Array(t.length);for(let e=0;e<t.length;e++)s[e]=this.processSample(t[e]);return s}frequencyResponse(t,s=1024){const e=m.freqz(this.b,this.a,s);return{f:e.w.map(s=>s*t/(2*Math.PI)),mag:e.mag,phase:e.phase,H:e.H}}toJSON(){return{b:this.b.slice(),a:this.a.slice()}}static fromTF(t,s){return new b(t,s)}static designFIR(t,s,e,r,a="hann"){const i=o.design(t,s,e,r,a);return new b(i.b,i.a)}static designButter(t,s,e,r){const a=g.butterworth(t,s,e,r);return new b(a.b,a.a,a.sections)}static designCheby1(t,s,e,r,a=1){const i=g.cheby1(t,s,e,r,a);return new b(i.b,i.a,i.sections)}static designCheby2(t,s,e,r,a=40){const i=g.cheby2(t,s,e,r,a);return new b(i.b,i.a,i.sections)}static designLinkwitzRiley(t,s,e,r=4){const a=g.linkwitzRiley(t,s,e,r);return new b(a.b,a.a,a.sections)}static designElliptic(t,s,e,r,a=1,i=40){const n=g.elliptic(t,s,e,r,a,i);return new b(n.b,n.a,n.sections)}static designBessel(t,s,e,r){const a=g.bessel(t,s,e,r);return new b(a.b,a.a,a.sections)}}const w={design:(t,s,e,r,a="hann")=>o.design(t,s,e,r,a),apply:(t,s)=>o.apply(t,s),overlapAdd:(t,s,e)=>o.overlapAdd(t,s,e)},y={butterworth:(t,s,e,r)=>{const a=g.butterworth(t,s,e,r);return{b:a.b,a:a.a}},cheby1:(t,s,e,r,a=1)=>{const i=g.cheby1(t,s,e,r,a);return{b:i.b,a:i.a}},cheby2:(t,s,e,r,a=40)=>{const i=g.cheby2(t,s,e,r,a);return{b:i.b,a:i.a}},linkwitzRiley:(t,s,e,r=4)=>{const a=g.linkwitzRiley(t,s,e,r);return{b:a.b,a:a.a}},apply:(t,s,e)=>b.fromTF(t,s).applySignal(e)},P={evalHz:(t,s,e)=>m.evalHz(t,s,e),freqz:(t,s,e=512)=>m.freqz(t,s,e),groupDelay:(t,s,e=512)=>m.groupDelay(t,s,e),isStable:()=>m.isStable()};var M={ComplexNum:t,C:s,Util:e,FFT:r,Window:a,Kernels:n,FIRDesigner:o,IIRDesigner:g,ZDomain:m,Filter:b,ButterworthFilter:c,ChebyshevFilter:h,ChebyshevType2Filter:u,LinkwitzRileyFilter:f,EllipticFilter:p,BesselFilter:d,BaseIIRFilter:l,FIR:w,IIR:y,Z:P};export{l as BaseIIRFilter,d as BesselFilter,c as ButterworthFilter,s as C,h as ChebyshevFilter,u as ChebyshevType2Filter,t as ComplexNum,p as EllipticFilter,r as FFT,w as FIR,o as FIRDesigner,b as Filter,y as IIR,g as IIRDesigner,n as Kernels,f as LinkwitzRileyFilter,e as Util,a as Window,P as Z,m as ZDomain,M as default};
//# sourceMappingURL=dsp-filter-library.esm.min.js.map
