!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).DSPFilterLibrary={})}(this,function(t){"use strict";class e{static of(t=0,e=0){return{re:t,im:e}}static add(t,e){return{re:t.re+e.re,im:t.im+e.im}}static sub(t,e){return{re:t.re-e.re,im:t.im-e.im}}static mul(t,e){return{re:t.re*e.re-t.im*e.im,im:t.re*e.im+t.im*e.re}}static scale(t,e){return{re:t.re*e,im:t.im*e}}static conj(t){return{re:t.re,im:-t.im}}static div(t,e){const s=e.re*e.re+e.im*e.im||1e-300;return{re:(t.re*e.re+t.im*e.im)/s,im:(t.im*e.re-t.re*e.im)/s}}static abs(t){return Math.hypot(t.re,t.im)}static arg(t){return Math.atan2(t.im,t.re)}static expj(t){return{re:Math.cos(t),im:Math.sin(t)}}static pow(t,e){if(0===e)return{re:1,im:0};if(1===e)return t;if(-1===e)return s.div({re:1,im:0},t);if(e>0){let r={re:1,im:0};for(let a=0;a<e;a++)r=s.mul(r,t);return r}{let r={re:1,im:0};for(let a=0;a<-e;a++)r=s.mul(r,t);return s.div({re:1,im:0},r)}}static sqrt(t){const e=Math.sqrt(s.abs(t)),r=Math.atan2(t.im,t.re)/2;return{re:e*Math.cos(r),im:e*Math.sin(r)}}}const s=e;class r{static nextPow2(t){if(!Number.isFinite(t)||t<=1)return 1;let e=1;for(;e<t;)e*=2;return e}static linspace(t,e,s){if(s<=0)return[];if(1===s)return[t];const r=(e-t)/(s-1);return Array.from({length:s},(e,s)=>t+s*r)}static convolve(t,e){const s=new Array(t.length+e.length-1).fill(0);for(let r=0;r<t.length;r++){const a=t[r];for(let t=0;t<e.length;t++)s[r+t]+=a*e[t]}return s}static polymul(t,e){const s=t.length,r=e.length,a=new Array(s+r-1).fill(0);for(let i=0;i<s;i++)for(let s=0;s<r;s++)a[i+s]+=t[i]*e[s];return a}static polyadd(t,e){const s=Math.max(t.length,e.length),r=new Array(s).fill(0);for(let a=0;a<s;a++)a<t.length&&(r[a]+=t[a]),a<e.length&&(r[a]+=e[a]);return r}static polyfromroots(t,e=1e-12){const s=new Array(t.length).fill(!1);let a=[1];for(let i=0;i<t.length;i++){if(s[i])continue;const n=t[i];let o=-1;for(let r=i+1;r<t.length;r++){if(s[r])continue;const a=t[r];if(Math.abs(n.re-a.re)<e&&Math.abs(n.im+a.im)<e){o=r;break}}if(Math.abs(n.im)<1e-14)a=r.polymul(a,[1,-n.re]),s[i]=!0;else if(o>=0){const t=[1,-2*n.re,n.re*n.re+n.im*n.im];a=r.polymul(a,t),s[i]=s[o]=!0}else{const t=[1,-2*n.re,n.re*n.re+n.im*n.im];a=r.polymul(a,t),s[i]=!0}}return a}static prewarp(t,e){return 2*e*Math.tan(Math.PI*t/e)}static pairConjugates(t){const e=new Array(t.length).fill(!1),s=[];for(let r=0;r<t.length;r++){if(e[r])continue;const a=t[r];let i=-1;for(let s=r+1;s<t.length;s++){if(e[s])continue;const r=t[s];if(Math.abs(a.re-r.re)<1e-12&&Math.abs(a.im+r.im)<1e-12){i=s;break}}i>=0?(s.push([a,t[i]]),e[r]=e[i]=!0):(s.push([a]),e[r]=!0)}return s}static bilinearMapBiquad(t,e,s,r,a,i,n){const o=2*n,l=r*o*o+a*o+i;return{b:[(t*o*o+e*o+s)/l,2*(s-t*o*o)/l,(t*o*o-e*o+s)/l],a:[1,2*(i-r*o*o)/l,(r*o*o-a*o+i)/l]}}static evalHzAtZ(t,e,s){return t.reduce((t,e,r)=>t+e*Math.pow(s,-r),0)/e.reduce((t,e,r)=>t+e*Math.pow(s,-r),0)}}class a{static fft(t){let s=t.length;if(s<=1)return t;if(s&s-1){const i=r.nextPow2(s);return a.fft(t.concat(Array.from({length:i-s},()=>e.of(0,0))))}let i=0;for(let e=1;e<s-1;e++){let r=s>>1;for(;i&r;r>>=1)i^=r;if(i^=r,e<i){const s=t[e];t[e]=t[i],t[i]=s}}for(let r=2;r<=s;r<<=1){const a=-2*Math.PI/r;for(let i=0;i<s;i+=r)for(let s=0;s<r/2;s++){const n=e.expj(a*s),o=t[i+s],l=e.mul(t[i+s+(r>>1)],n);t[i+s]=e.add(o,l),t[i+s+(r>>1)]=e.sub(o,l)}}return t}static ifft(t){const s=t.length;return a.fft(t.map(e.conj)).map(e.conj).map(t=>e.scale(t,1/s))}static rfft(t){const s=r.nextPow2(t.length),i=Array.from({length:s},(s,r)=>e.of(t[r]||0,0));return a.fft(i)}static powerSpectrum(t){return a.rfft(t).map(e.abs).map(t=>t*t)}}class i{static rect(t){return Array.from({length:t},()=>1)}static rectangle(t){return i.rect(t)}static hann(t){return Array.from({length:t},(e,s)=>.5-.5*Math.cos(2*Math.PI*s/(t-1)))}static hamming(t){return Array.from({length:t},(e,s)=>.54-.46*Math.cos(2*Math.PI*s/(t-1)))}static blackman(t){return Array.from({length:t},(e,s)=>.42-.5*Math.cos(2*Math.PI*s/(t-1))+.08*Math.cos(4*Math.PI*s/(t-1)))}static blackmanHarris(t){return Array.from({length:t},(e,s)=>.35875-.48829*Math.cos(2*Math.PI*s/(t-1))+.14128*Math.cos(4*Math.PI*s/(t-1))-.01168*Math.cos(6*Math.PI*s/(t-1)))}static blackmanNuttall(t){return Array.from({length:t},(e,s)=>.3635819-.4891775*Math.cos(2*Math.PI*s/(t-1))+.1365995*Math.cos(4*Math.PI*s/(t-1))-.0106411*Math.cos(6*Math.PI*s/(t-1)))}static kaiser(t,e=8.6){const s=n(e),r=t-1;return Array.from({length:t},(t,a)=>{const i=2*a/r-1;return n(e*Math.sqrt(1-i*i))/s})}static tukey(t,e=.5){const s=t-1;return Array.from({length:t},(t,r)=>{const a=r/s;return e<=0?1:e>=1?.5*(1-Math.cos(2*Math.PI*a)):a<e/2?.5*(1+Math.cos(Math.PI*(2*a/e-1))):a<=1-e/2?1:.5*(1+Math.cos(Math.PI*(2*a/e-2/e+1)))})}static gauss(t,e=.4){const s=(t-1)/2;return Array.from({length:t},(t,r)=>{const a=(r-s)/(e*s);return Math.exp(-.5*a*a)})}static bartlett(t){const e=t-1;return Array.from({length:t},(t,s)=>1-Math.abs((s-e/2)/(e/2)))}static bartlettHann(t){const e=t-1;return Array.from({length:t},(t,s)=>{const r=s/e;return.62-.48*Math.abs(r-.5)-.38*Math.cos(2*Math.PI*r)})}static cosine(t){const e=t-1;return Array.from({length:t},(t,s)=>Math.sin(Math.PI*s/e))}static lanczos(t){const e=(t-1)/2;return Array.from({length:t},(t,s)=>{return 0===(r=(s-e)/e)?1:Math.sin(Math.PI*r)/(Math.PI*r);var r})}static bohman(t){const e=(t-1)/2;return Array.from({length:t},(t,s)=>{const r=Math.abs(s-e)/e;return r<=1?(1-r)*Math.cos(Math.PI*r)+1/Math.PI*Math.sin(Math.PI*r):0})}static flatTop(t){const e=t-1;return Array.from({length:t},(t,s)=>1-1.93*Math.cos(2*Math.PI*s/e)+1.29*Math.cos(4*Math.PI*s/e)-.388*Math.cos(6*Math.PI*s/e)+.028*Math.cos(8*Math.PI*s/e))}static byName(t,e,s={}){const{beta:r=8.6,alpha:a=.5,sigma:n=.4}=s||{};switch(t){case"hann":return i.hann(e);case"hamming":return i.hamming(e);case"blackman":return i.blackman(e);case"blackmanHarris":return i.blackmanHarris(e);case"blackmanNuttall":return i.blackmanNuttall(e);case"rectangle":case"rect":default:return i.rect(e);case"bartlett":return i.bartlett(e);case"bartlettHann":return i.bartlettHann(e);case"cosine":return i.cosine(e);case"lanczos":return i.lanczos(e);case"bohman":return i.bohman(e);case"gauss":case"gaussian":return i.gauss(e,n);case"tukey":return i.tukey(e,a);case"kaiser":return i.kaiser(e,r);case"flatTop":case"flattop":return i.flatTop(e)}}}const n=t=>{const e=Math.abs(t);if(e<3.75){const e=t/3.75,s=e*e;return 1+s*(3.5156229+s*(3.0899424+s*(1.2067492+s*(.2659732+s*(.0360768+.0045813*s)))))}{const t=3.75/e;return Math.exp(e)/Math.sqrt(e)*(.39894228+t*(.01328592+t*(.00225319+t*(t*(.00916281+t*(t*(.02635537+t*(.00392377*t-.01647633))-.02057706))-.00157565))))}};class o{static sinc(t){return 0===t?1:Math.sin(Math.PI*t)/(Math.PI*t)}static idealLowpass(t,e,s){const r=s-1,a=t/e;return Array.from({length:s},(t,e)=>o.sinc(2*(e-r/2)*a))}}class l{static design(t,e,s,r,a="hann"){const n=r+1,c=i.byName(a,n),h=n-1,u=t=>t.map((t,e)=>t*c[e]);if("lowpass"===t){const t=e;let r=o.idealLowpass(t,s,n);const a=2*t/s;return r=r.map(t=>t*a),{b:u(r),a:[1]}}if("highpass"===t){const t=e;return{b:l.design("lowpass",t,s,r,a).b.map((t,e)=>e===h/2?1-t:-t),a:[1]}}if("bandpass"===t){const[t,i]=e,n=l.design("lowpass",i,s,r,a).b,o=l.design("lowpass",t,s,r,a).b;return{b:n.map((t,e)=>t-o[e]),a:[1]}}if("bandstop"===t){const[t,i]=e;return{b:l.design("bandpass",[t,i],s,r,a).b.map((t,e)=>e===h/2?1-t:-t),a:[1]}}throw new Error("Unsupported FIR type")}static apply(t,e){return r.convolve(e,t)}static overlapAdd(t,s,i){const n=i||1024,o=t.length,l=r.nextPow2(n+o-1),c=a.fft(Array.from({length:l},(s,r)=>e.of(t[r]||0,0))),h=new Array(s.length+o-1).fill(0);for(let t=0;t<s.length;t+=n){const r=Array.from({length:l},(r,a)=>e.of(s[t+a]||0,0)),i=a.fft(r).map((t,s)=>e.mul(t,c[s])),u=a.ifft(i);for(let e=0;e<n+o-1;e++)h[t+e]+=u[e].re}return h}}class c{static validateCommonParameters(t,e,s,r){if(r<1)throw new Error("Order must be >= 1");if(s<=0)throw new Error("Sampling frequency must be positive");if("lowpass"===t||"highpass"===t){if(e<=0||e>=s/2)throw new Error("Cutoff frequency must be 0 < fc < fs/2")}else{if("bandpass"!==t&&"bandstop"!==t)throw new Error(`Unsupported filter kind: ${t}`);{const[t,r]=e;if(!(t>0&&r>t&&r<s/2))throw new Error("Invalid band edges: must satisfy 0 < f1 < f2 < fs/2")}}}static fromPrototype(t,e,s,a,i){const n=[],o=r.pairConjugates(s);for(const s of o){const[a,o]=2===s.length?s:[s[0],null];let l,c,h,u,f,p,d,g,m;if(o?(l=1,c=-2*a.re,h=a.re*a.re+a.im*a.im):(l=0,c=1,h=-a.re),"lowpass"===t)u=l,f=c*i,p=h*i*i,d=0,g=0,m=1;else{if("highpass"!==t)throw new Error("fromPrototype supports only lowpass/highpass");0!==l?(u=h,f=c*i,p=l*i*i,d=1,g=0,m=0):(u=0,f=h,p=c*i,d=0,g=1,m=0)}n.push(r.bilinearMapBiquad(d,g,m,u,f,p,e))}let l=[1],c=[1];for(const t of n)l=r.polymul(l,t.b),c=r.polymul(c,t.a);const h=1/r.evalHzAtZ(l,c,a);if(n.length>0){const t=n.length-1;n[t].b=n[t].b.map(t=>t*h)}l=[1],c=[1];for(const t of n)l=r.polymul(l,t.b),c=r.polymul(c,t.a);return{b:l,a:c,sections:n}}static calculatePoles(t,...e){throw new Error("calculatePoles must be implemented by subclass")}static design(t,e,s,r,...a){throw new Error("design must be implemented by subclass")}}class h extends c{static calculatePoles(t){const s=[];for(let r=0;r<t;r++){const a=Math.PI*(2*r+1+t)/(2*t),i=e.of(Math.cos(a),Math.sin(a));i.re<0&&s.push(i)}return s}static designLowHighPass(t,e,s,a){const i=e,n=r.prewarp(i,s),o=h.calculatePoles(a),l="lowpass"===t?1:-1;return c.fromPrototype(t,s,o,l,n)}static designBandPass(t,e,s){const[a,i]=t,n=h.designLowHighPass("highpass",a,e,s),o=h.designLowHighPass("lowpass",i,e,s);return{b:r.polymul(n.b,o.b),a:r.polymul(n.a,o.a),sections:n.sections.concat(o.sections)}}static designBandStop(t,e,s){const[a,i]=t,n=h.designLowHighPass("lowpass",a,e,s),o=h.designLowHighPass("highpass",i,e,s),l=r.polymul(n.a,o.a),c=r.polymul(n.b,o.a),u=r.polymul(o.b,n.a);return{b:r.polyadd(c,u),a:l,sections:[...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static designBandPassStop(t,e,s,r){if("bandpass"===t)return h.designBandPass(e,s,r);if("bandstop"===t)return h.designBandStop(e,s,r);throw new Error("Unsupported filter kind for band design")}static design(t,e,s,r){if(h.validateCommonParameters(t,e,s,r),r>12)throw new Error(`Butterworth filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t||"highpass"===t)return h.designLowHighPass(t,e,s,r);if("bandpass"===t||"bandstop"===t)return h.designBandPassStop(t,e,s,r);throw new Error("Unsupported filter kind")}}class u extends c{static validateParameters(t,e,s,r,a){if(u.validateCommonParameters(t,e,s,r),a<=0)throw new Error("Passband ripple must be positive");if(a>10)throw new Error("Passband ripple should be <= 10 dB for practical designs")}static calculatePoles(t,s){const r=Math.sqrt(Math.pow(10,s/10)-1),a=Math.asinh(1/r)/t,i=Math.sinh(a),n=Math.cosh(a),o=[];for(let s=0;s<t;s++){const r=Math.PI*(2*s+1)/(2*t),a=-i*Math.sin(r),l=n*Math.cos(r),c=e.of(a,l);c.re<0&&o.push(c)}return o}static designLowHighPass(t,e,s,a,i){const n=e,o=r.prewarp(n,s),l=u.calculatePoles(a,i),h="lowpass"===t?1:-1;return c.fromPrototype(t,s,l,h,o)}static designBandPass(t,e,s,a){const[i,n]=t,o=u.designLowHighPass("highpass",i,e,s,a),l=u.designLowHighPass("lowpass",n,e,s,a);return{b:r.polymul(o.b,l.b),a:r.polymul(o.a,l.a),sections:o.sections.concat(l.sections)}}static designBandStop(t,e,s,a){const[i,n]=t,o=u.designLowHighPass("lowpass",i,e,s,a),l=u.designLowHighPass("highpass",n,e,s,a),c=r.polymul(o.a,l.a),h=r.polymul(o.b,l.a),f=r.polymul(l.b,o.a);return{b:r.polyadd(h,f),a:c,sections:[...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...l.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static designBandPassStop(t,e,s,r,a){if("bandpass"===t)return u.designBandPass(e,s,r,a);if("bandstop"===t)return u.designBandStop(e,s,r,a);throw new Error("Unsupported filter kind for band design")}static design(t,e,s,r,a=1){if(u.validateParameters(t,e,s,r,a),r>12)throw new Error(`Chebyshev filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t||"highpass"===t)return u.designLowHighPass(t,e,s,r,a);if("bandpass"===t||"bandstop"===t)return u.designBandPassStop(t,e,s,r,a);throw new Error("Unsupported filter kind")}}class f extends c{static validateParameters(t,e,s,r,a){if(f.validateCommonParameters(t,e,s,r),!(a>0))throw new Error("Stopband attenuation must be positive")}static calculatePolesAndZeros(t,s){const r=1/(Math.pow(10,s/10)-1),a=Math.asinh(1/Math.sqrt(r))/t,i=[];for(let s=1;s<=t;s++){const r=Math.PI*(2*s-1)/(2*t),n=-Math.sinh(a)*Math.sin(r),o=Math.cosh(a)*Math.cos(r);i.push(e.of(n,o))}const n=[],o=Math.floor(t/2);for(let e=1;e<=o;e++){const s=Math.PI*(2*e-1)/(2*t);n.push(1/Math.cos(s))}return{poles:i,zerosW:n}}static mapSectionLP_HP(t,e,s,a,i){let n,o,l,c,h,u,f,p,d,g,m,b;if(2===e.length){const t=e[0];n=1,o=-2*t.re,l=t.re*t.re+t.im*t.im}else{n=0,o=1,l=-e[0].re}return null!=s?(c=1,h=0,u=s*s):(c=0,h=0,u=1),"lowpass"===t?(f=n,p=o*a,d=l*a*a,g=c,m=h*a,b=u*a*a):(0!==n?(f=l,p=o*a,d=n*a*a):(f=0,p=l,d=o*a),0!==c?(g=u,m=h*a,b=c*a*a):0!==h?(g=0,m=u,b=h*a):(g=u,m=0,b=0)),r.bilinearMapBiquad(g,m,b,f,p,d,i)}static designLPHP(t,e,s,a,i){const n=r.prewarp(e,s),{poles:o,zerosW:l}=this.calculatePolesAndZeros(a,i),c=r.pairConjugates(o),h=[];let u=0;for(const e of c){const r=u<l.length?l[u++]*n:null,a=this.mapSectionLP_HP(t,e,r,n,s);h.push(a)}let f=[1],p=[1];for(const t of h)f=r.polymul(f,t.b),p=r.polymul(p,t.a);const d="lowpass"===t?1:-1,g=1/r.evalHzAtZ(f,p,d);if(h.length){const t=h.length-1;h[t]={b:h[t].b.map(t=>t*g),a:h[t].a.slice()},f=[1],p=[1];for(const t of h)f=r.polymul(f,t.b),p=r.polymul(p,t.a)}return{b:f,a:p,sections:h}}static designLowPass(t,e,s,r){return this.designLPHP("lowpass",t,e,s,r)}static designHighPass(t,e,s,r){return this.designLPHP("highpass",t,e,s,r)}static designBandPass(t,e,s,a){const[i,n]=t,o=this.designHighPass(i,e,s,a),l=this.designLowPass(n,e,s,a);return{b:r.polymul(o.b,l.b),a:r.polymul(o.a,l.a),sections:[...o.sections,...l.sections]}}static designBandStop(t,e,s,a){const[i,n]=t,o=this.designLowPass(i,e,s,a),l=this.designHighPass(n,e,s,a),c=r.polymul(o.a,l.a),h=r.polymul(o.b,l.a),u=r.polymul(l.b,o.a);return{b:r.polyadd(h,u),a:c,sections:[...o.sections,...l.sections]}}static designBandPassStop(t,e,s,r,a){if("bandpass"===t)return this.designBandPass(e,s,r,a);if("bandstop"===t)return this.designBandStop(e,s,r,a);throw new Error("Unsupported filter kind for band design")}static design(t,e,s,r,a=40){if(this.validateParameters(t,e,s,r,a),r>12)throw new Error(`Chebyshev Type 2 filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);if("lowpass"===t)return this.designLowPass(e,s,r,a);if("highpass"===t)return this.designHighPass(e,s,r,a);if("bandpass"===t||"bandstop"===t)return this.designBandPassStop(t,e,s,r,a);throw new Error("Unsupported filter kind")}}class p extends c{static validateParameters(t,e,s,r){if(p.validateCommonParameters(t,e,s,r),r<2)throw new Error("Order must be >= 2 for Linkwitz-Riley filters")}static design(t,e,s,a){if(p.validateParameters(t,e,s,a),a>12)throw new Error(`Linkwitz-Riley filter order ${a} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);const i=(a%2==0?a:a+1)/2,n=h.design(t,e,s,i),o=n.sections.concat(n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})));return{b:r.polymul(n.b,n.b),a:r.polymul(n.a,n.a),sections:o}}static designLowPass(t,e,s){return p.design("lowpass",t,e,s)}static designHighPass(t,e,s){return p.design("highpass",t,e,s)}static designBandPass(t,e,s){const[a,i]=t,n=p.design("highpass",a,e,s),o=p.design("lowpass",i,e,s);return{b:r.polymul(n.b,o.b),a:r.polymul(n.a,o.a),sections:n.sections.concat(o.sections)}}static designBandStop(t,e,s){const[a,i]=t,n=p.design("lowpass",a,e,s),o=p.design("highpass",i,e,s),l=r.polymul(n.a,o.a),c=r.polymul(n.b,o.a),h=r.polymul(o.b,n.a);return{b:r.polyadd(c,h),a:l,sections:[...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static getActualOrder(t){return t%2==0?t:t+1}static getHalfOrder(t){return p.getActualOrder(t)/2}static getNumberOfSections(t){return 2*p.getHalfOrder(t)}static getRecommendedOrders(){return{basic:2,standard:4,high:6,premium:8,professional:12}}static adjustOrderToEven(t){return t<2?2:t%2==0?t:t+1}static getFilterInfo(t){const e=p.getActualOrder(t),s=p.getHalfOrder(t);return{requestedOrder:t,actualOrder:e,halfOrder:s,sections:p.getNumberOfSections(t),isAdjusted:t!==e,description:`Linkwitz-Riley ${e}th order (${s}th order Butterworth cascaded twice)`}}}class d extends c{static design(t,e,s,r,a=1,i=40){if(r>12)throw new Error(`Elliptic filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);switch(t){case"lowpass":return this.designLowPass(e,s,r,a,i);case"highpass":return this.designHighPass(e,s,r,a,i);case"bandpass":if(Array.isArray(e)&&2===e.length)return this.designBandPass(e[0],e[1],s,r,a,i);throw new Error("Bandpass requires [lowCutoff, highCutoff] frequencies");case"bandstop":if(Array.isArray(e)&&2===e.length)return this.designBandStop(e[0],e[1],s,r,a,i);throw new Error("Bandstop requires [lowCutoff, highCutoff] frequencies");default:throw new Error(`Unsupported filter type: ${t}`)}}static designLowPass(t,e,s,a,i){const n=r.prewarp(t,e),{poles:o,zeros:l}=this.calculateEllipticPolesAndZeros(s,a,i);return this.fromPrototype("lowpass",e,o,1,n)}static designHighPass(t,e,a,i,n){const o=r.prewarp(t,e),{poles:l,zeros:c}=this.calculateEllipticPolesAndZeros(a,i,n),h=l.map(t=>s.div(s.of(1,0),t));return this.fromPrototype("highpass",e,h,-1,o)}static designBandPass(t,e,s,a,i,n){const o=this.designHighPass(t,s,a,i,n),l=this.designLowPass(e,s,a,i,n);return{b:r.polymul(o.b,l.b),a:r.polymul(o.a,l.a),sections:o.sections.concat(l.sections)}}static designBandStop(t,e,s,a,i,n){const o=this.designLowPass(t,s,a,i,n),l=this.designHighPass(e,s,a,i,n),c=r.polymul(o.a,l.a),h=r.polymul(o.b,l.a),u=r.polymul(l.b,o.a);return{b:r.polyadd(h,u),a:c,sections:[...o.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...l.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static calculateEllipticPolesAndZeros(t,e,r){const a=Math.sqrt(Math.pow(10,e/10)-1),i=Math.pow(10,r/20),n=a/Math.sqrt(i*i-1),o=this.calculateModularConstant(n,t),l=this.completeEllipticIntegral(o);this.completeEllipticIntegral(Math.sqrt(1-o*o));const c=[],h=[];for(let e=1;e<=Math.floor(t/2);e++){const r=(2*e-1)*l/t,a=this.jacobiSn(r,o),i=-a*this.jacobiCn(r,o)/(1-a*a),n=this.jacobiDn(r,o)/(1-a*a);c.push(s.of(i,n)),c.push(s.of(i,-n));const u=1/(o*a),f=0;h.push(s.of(u,f)),h.push(s.of(u,-f))}if(t%2==1){const e=l/t,r=this.jacobiSn(e,o);c.push(s.of(-r,0)),h.push(s.of(1/(o*r),0))}return{poles:c,zeros:h}}static calculateModularConstant(t,e){const s=Math.exp(-Math.PI*this.completeEllipticIntegral(Math.sqrt(1-t*t))/this.completeEllipticIntegral(t));let r=Math.sqrt(s);for(let t=0;t<10;t++){r-=(this.completeEllipticIntegral(r)/this.completeEllipticIntegral(Math.sqrt(1-r*r))-e*Math.log(s)/Math.PI)/this.ellipticIntegralDerivative(r)}return r}static completeEllipticIntegral(t){if(0===t)return Math.PI/2;if(1===t)return 1/0;let e=1,s=1;const r=t*t;for(let t=1;t<100&&(s*=(2*t-1)*(2*t-1)*r/(2*t*2*t),e+=s,!(Math.abs(s)<1e-15));t++);return Math.PI/2*e}static jacobiSn(t,e){const s=e*e;let r=0,a=1;for(let e=0;e<50&&(r+=a*Math.sin((2*e+1)*t),a*=s,!(Math.abs(a)<1e-15));e++);return r}static jacobiCn(t,e){const s=this.jacobiSn(t,e);return Math.sqrt(1-s*s)}static jacobiDn(t,e){const s=this.jacobiSn(t,e),r=e*e;return Math.sqrt(1-r*s*s)}static ellipticIntegralDerivative(t){const e=1-t*t;return this.completeEllipticIntegral(t)/(t*e)-this.completeEllipticIntegral(Math.sqrt(e))/(t*t)}static getRecommendedPassbandRipples(){return[.1,.2,.5,1,2,3,5]}static getRecommendedStopbandAttenuations(){return[20,30,40,50,60,70,80,90,100]}static calculateActualPassbandRipple(t,e,s){const r=Math.sqrt(Math.pow(10,e/10)-1),a=Math.pow(10,s/20),i=r*Math.pow(a,-1/t);return 10*Math.log10(1+i*i)}static calculateActualStopbandAttenuation(t,e,s){const r=Math.sqrt(Math.pow(10,e/10)-1),a=Math.pow(10,s/20)*Math.pow(r,1/t);return 20*Math.log10(a)}}class g extends c{static design(t,e,s,r){if(r>12)throw new Error(`Bessel filter order ${r} exceeds maximum allowed order of 12. For higher orders, consider using cascaded lower-order sections or alternative filter types.`);switch(t){case"lowpass":return this.designLowPass(e,s,r);case"highpass":return this.designHighPass(e,s,r);case"bandpass":if(Array.isArray(e)&&2===e.length)return this.designBandPass(e[0],e[1],s,r);throw new Error("Bandpass requires [lowCutoff, highCutoff] frequencies");case"bandstop":if(Array.isArray(e)&&2===e.length)return this.designBandStop(e[0],e[1],s,r);throw new Error("Bandstop requires [lowCutoff, highCutoff] frequencies");default:throw new Error(`Unsupported filter type: ${t}`)}}static designLowPass(t,e,s){const a=r.prewarp(t,e),i=this.calculateBesselPoles(s);return this.fromPrototype("lowpass",e,i,1,a)}static designHighPass(t,e,a){const i=r.prewarp(t,e),n=this.calculateBesselPoles(a).map(t=>s.div(s.of(1,0),t));return this.fromPrototype("highpass",e,n,-1,i)}static designBandPass(t,e,s,a){const i=this.designHighPass(t,s,a),n=this.designLowPass(e,s,a);return{b:r.polymul(i.b,n.b),a:r.polymul(i.a,n.a),sections:i.sections.concat(n.sections)}}static designBandStop(t,e,s,a){const i=this.designLowPass(t,s,a),n=this.designHighPass(e,s,a),o=r.polymul(i.a,n.a),l=r.polymul(i.b,n.a),c=r.polymul(n.b,i.a);return{b:r.polyadd(l,c),a:o,sections:[...i.sections.map(t=>({b:t.b.slice(),a:t.a.slice()})),...n.sections.map(t=>({b:t.b.slice(),a:t.a.slice()}))]}}static calculateBesselPoles(t){const e={1:[s.of(-1,0)],2:[s.of(-1.5,.8660254037844386),s.of(-1.5,-.8660254037844386)],3:[s.of(-2.322185354626086,0),s.of(-1.838907322686957,1.754380959783721),s.of(-1.838907322686957,-1.754380959783721)],4:[s.of(-2.103789397179628,.6657060219931349),s.of(-2.103789397179628,-.6657060219931349),s.of(-1.896210602820372,1.744447419188405),s.of(-1.896210602820372,-1.744447419188405)],5:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146)],6:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189)],7:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095)],8:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095)],9:[s.of(-2.324674303181611,0),s.of(-2.048290428681656,1.000044768299361),s.of(-2.048290428681656,-1.000044768299361),s.of(-1.673416736234146,1.673416736234146),s.of(-1.673416736234146,-1.673416736234146),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095),s.of(-1.224744871391589,1.224744871391589),s.of(-1.224744871391589,-1.224744871391589)],10:[s.of(-2.13290631146253,.4718706301774892),s.of(-2.13290631146253,-.4718706301774892),s.of(-1.905412542845325,1.552914270615124),s.of(-1.905412542845325,-1.552914270615124),s.of(-1.606938159156189,1.606938159156189),s.of(-1.606938159156189,-1.606938159156189),s.of(-1.414213562373095,1.414213562373095),s.of(-1.414213562373095,-1.414213562373095),s.of(-1.224744871391589,1.224744871391589),s.of(-1.224744871391589,-1.224744871391589)]};return e[t]?e[t]:this.calculateBesselPolesNumerical(t)}static calculateBesselPolesNumerical(t){const e=[];if(t%2==0)for(let r=0;r<t/2;r++){const a=(2*r+1)*Math.PI/(2*t),i=-Math.cos(a),n=Math.sin(a);e.push(s.of(i,n)),e.push(s.of(i,-n))}else{e.push(s.of(-1,0));for(let r=0;r<(t-1)/2;r++){const a=(2*r+1)*Math.PI/(2*t),i=-Math.cos(a),n=Math.sin(a);e.push(s.of(i,n)),e.push(s.of(i,-n))}}return e}static calculateBesselPolynomial(t){if(0===t)return[1];if(1===t)return[1,1];let e=[1],s=[1,1];for(let r=2;r<=t;r++){const t=new Array(r+1).fill(0);for(let e=0;e<s.length;e++)t[e]+=(2*r-1)*s[e];for(let s=0;s<e.length;s++)t[s+2]+=e[s];e=s,s=t}return s}static getRecommendedOrders(){return[1,2,3,4,5,6,7,8,9,10]}static calculateGroupDelay(t,e,s){const r=t/(2*Math.PI*e);return Math.max(0,r)}static getCharacteristics(t){return{1:{groupDelay:1,rolloff:-6,phase:"Linear"},2:{groupDelay:1.5,rolloff:-12,phase:"Linear"},3:{groupDelay:2,rolloff:-18,phase:"Linear"},4:{groupDelay:2.5,rolloff:-24,phase:"Linear"},5:{groupDelay:3,rolloff:-30,phase:"Linear"},6:{groupDelay:3.5,rolloff:-36,phase:"Linear"},7:{groupDelay:4,rolloff:-42,phase:"Linear"},8:{groupDelay:4.5,rolloff:-48,phase:"Linear"},9:{groupDelay:5,rolloff:-54,phase:"Linear"},10:{groupDelay:5.5,rolloff:-60,phase:"Linear"}}[t]||{groupDelay:.5*t,rolloff:-6*t,phase:"Linear"}}}class m{static fromPrototype(t,e,s,r,a){return c.fromPrototype(t,e,s,r,a)}static butterworth(t,e,s,r){return h.design(t,e,s,r)}static cheby1(t,e,s,r,a=1){return u.design(t,e,s,r,a)}static cheby2(t,e,s,r,a=40){return f.design(t,e,s,r,a)}static linkwitzRiley(t,e,s,r=4){return p.design(t,e,s,r)}static elliptic(t,e,s,r,a=1,i=40){return d.design(t,e,s,r,a,i)}static bessel(t,e,s,r){return g.design(t,e,s,r)}}class b{static evalHz(t,s,r){const a=e.div(e.of(1,0),r),i=t=>{let s=e.of(1,0);for(let r=0;r<t;r++)s=e.mul(s,a);return s};let n=e.of(0,0);for(let s=0;s<t.length;s++)n=e.add(n,e.scale(i(s),t[s]));let o=e.of(1,0);for(let t=1;t<s.length;t++)o=e.add(o,e.scale(i(t),s[t]));return e.div(n,o)}static freqz(t,s,a=512){const i=r.linspace(0,Math.PI,a),n=i.map(r=>b.evalHz(t,s,e.expj(r))),o=n.map(e.abs),l=n.map(e.arg);return{w:i,H:n,mag:o,phase:l}}static groupDelay(t,e,s=512){const{w:r,phase:a}=b.freqz(t,e,s),i=[...a];for(let t=1;t<i.length;t++){let e=i[t]-i[t-1];for(;e>Math.PI;)i[t]-=2*Math.PI,e-=2*Math.PI;for(;e<-Math.PI;)i[t]+=2*Math.PI,e+=2*Math.PI}const n=r[1]-r[0];return{w:r,gd:i.map((t,e)=>0===e||e===i.length-1?0:-(i[e+1]-i[e-1])/(2*n))}}static isStable(){return!0}}class w{constructor(t,e=[1],s=[]){if(Math.abs(e[0]-1)>1e-12&&(t=t.map(t=>t/e[0]),e=e.map(t=>t/e[0])),this.b=t.slice(),this.a=e.slice(),this.sections=(s||[]).map(t=>({b:t.b.slice(),a:[1,t.a[1],t.a[2]]})),this.sections.length>0)this._sosState=this.sections.map(()=>({w1:0,w2:0}));else if(1===this.a.length)this._firIdx=0,this._firBuf=new Array(this.b.length).fill(0);else{const t=Math.max(this.b.length,this.a.length)-1;this._iirW=new Array(t).fill(0)}}reset(){this._sosState&&this._sosState.forEach(t=>{t.w1=0,t.w2=0}),this._firBuf&&(this._firBuf.fill(0),this._firIdx=0),this._iirW&&this._iirW.fill(0)}processSample(t){if(this.sections.length>0){let e=t;for(let t=0;t<this.sections.length;t++){const{b:s,a:r}=this.sections[t],a=this._sosState[t],i=e-r[1]*a.w1-r[2]*a.w2,n=s[0]*i+s[1]*a.w1+s[2]*a.w2;a.w2=a.w1,a.w1=i,e=n}return e}if(1===this.a.length){this._firBuf[this._firIdx]=t;let e=0,s=this._firIdx;for(let t=0;t<this.b.length;t++)e+=this.b[t]*this._firBuf[s],s=(s-1+this._firBuf.length)%this._firBuf.length;return this._firIdx=(this._firIdx+1)%this._firBuf.length,e}let e=t;for(let t=1;t<this.a.length;t++)e-=this.a[t]*(this._iirW[t-1]||0);let s=this.b[0]*e;for(let t=1;t<this.b.length;t++)s+=(this._iirW[t-1]||0)*this.b[t];for(let t=this._iirW.length-1;t>0;t--)this._iirW[t]=this._iirW[t-1];return this._iirW[0]=e,s}applySignal(t){const e=new Array(t.length);for(let s=0;s<t.length;s++)e[s]=this.processSample(t[s]);return e}frequencyResponse(t,e=1024){const s=b.freqz(this.b,this.a,e);return{f:s.w.map(e=>e*t/(2*Math.PI)),mag:s.mag,phase:s.phase,H:s.H}}toJSON(){return{b:this.b.slice(),a:this.a.slice()}}static fromTF(t,e){return new w(t,e)}static designFIR(t,e,s,r,a="hann"){const i=l.design(t,e,s,r,a);return new w(i.b,i.a)}static designButter(t,e,s,r){const a=m.butterworth(t,e,s,r);return new w(a.b,a.a,a.sections)}static designCheby1(t,e,s,r,a=1){const i=m.cheby1(t,e,s,r,a);return new w(i.b,i.a,i.sections)}static designCheby2(t,e,s,r,a=40){const i=m.cheby2(t,e,s,r,a);return new w(i.b,i.a,i.sections)}static designLinkwitzRiley(t,e,s,r=4){const a=m.linkwitzRiley(t,e,s,r);return new w(a.b,a.a,a.sections)}static designElliptic(t,e,s,r,a=1,i=40){const n=m.elliptic(t,e,s,r,a,i);return new w(n.b,n.a,n.sections)}static designBessel(t,e,s,r){const a=m.bessel(t,e,s,r);return new w(a.b,a.a,a.sections)}}const y={design:(t,e,s,r,a="hann")=>l.design(t,e,s,r,a),apply:(t,e)=>l.apply(t,e),overlapAdd:(t,e,s)=>l.overlapAdd(t,e,s)},P={butterworth:(t,e,s,r)=>{const a=m.butterworth(t,e,s,r);return{b:a.b,a:a.a}},cheby1:(t,e,s,r,a=1)=>{const i=m.cheby1(t,e,s,r,a);return{b:i.b,a:i.a}},cheby2:(t,e,s,r,a=40)=>{const i=m.cheby2(t,e,s,r,a);return{b:i.b,a:i.a}},linkwitzRiley:(t,e,s,r=4)=>{const a=m.linkwitzRiley(t,e,s,r);return{b:a.b,a:a.a}},apply:(t,e,s)=>w.fromTF(t,e).applySignal(s)},M={evalHz:(t,e,s)=>b.evalHz(t,e,s),freqz:(t,e,s=512)=>b.freqz(t,e,s),groupDelay:(t,e,s=512)=>b.groupDelay(t,e,s),isStable:()=>b.isStable()};var I={ComplexNum:e,C:s,Util:r,FFT:a,Window:i,Kernels:o,FIRDesigner:l,IIRDesigner:m,ZDomain:b,Filter:w,ButterworthFilter:h,ChebyshevFilter:u,ChebyshevType2Filter:f,LinkwitzRileyFilter:p,EllipticFilter:d,BesselFilter:g,BaseIIRFilter:c,FIR:y,IIR:P,Z:M};t.BaseIIRFilter=c,t.BesselFilter=g,t.ButterworthFilter=h,t.C=s,t.ChebyshevFilter=u,t.ChebyshevType2Filter=f,t.ComplexNum=e,t.EllipticFilter=d,t.FFT=a,t.FIR=y,t.FIRDesigner=l,t.Filter=w,t.IIR=P,t.IIRDesigner=m,t.Kernels=o,t.LinkwitzRileyFilter=p,t.Util=r,t.Window=i,t.Z=M,t.ZDomain=b,t.default=I,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=dsp-filter-library.min.js.map
